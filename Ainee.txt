Directory structure:
└── nekoparapa-ainiee/
    ├── README.md
    ├── AiNiee.py
    ├── hyperscan.py
    ├── LICENSE
    ├── README_EN.md
    ├── requirements.txt
    ├── requirements_no_deps.txt
    ├── Base/
    │   ├── Base.py
    │   ├── EventManager.py
    │   └── PluginManager.py
    ├── ModuleFolders/
    │   ├── Cache/
    │   │   ├── BaseCache.py
    │   │   ├── CacheFile.py
    │   │   ├── CacheItem.py
    │   │   ├── CacheManager.py
    │   │   └── CacheProject.py
    │   ├── FileAccessor/
    │   │   ├── README.md
    │   │   ├── BabeldocPdfAccessor.py
    │   │   ├── DocxAccessor.py
    │   │   ├── EpubAccessor.py
    │   │   └── ZipUtil.py
    │   ├── FileConverter/
    │   │   ├── BaseConverter.py
    │   │   └── OfficeFileConverter.py
    │   ├── FileOutputer/
    │   │   ├── AssWriter.py
    │   │   ├── AutoTypeWriter.py
    │   │   ├── BabeldocPdfWriter.py
    │   │   ├── BaseWriter.py
    │   │   ├── DirectoryWriter.py
    │   │   ├── DocxWriter.py
    │   │   ├── EpubWriter.py
    │   │   ├── FileOutputer.py
    │   │   ├── I18nextWriter.py
    │   │   ├── LrcWriter.py
    │   │   ├── MdWriter.py
    │   │   ├── MToolWriter.py
    │   │   ├── OfficeConversionWriter.py
    │   │   ├── ParatranzWriter.py
    │   │   ├── PoWriter.py
    │   │   ├── RenpyWriter.py
    │   │   ├── SrtWriter.py
    │   │   ├── TPPWriter.py
    │   │   ├── TransWriter.py
    │   │   ├── TxtWriter.py
    │   │   ├── VntWriter.py
    │   │   ├── VttWriter.py
    │   │   └── WriterUtil.py
    │   ├── FileReader/
    │   │   ├── AssReader.py
    │   │   ├── AutoTypeReader.py
    │   │   ├── BabeldocPdfReader.py
    │   │   ├── BaseReader.py
    │   │   ├── DirectoryReader.py
    │   │   ├── DocxReader.py
    │   │   ├── EpubReader.py
    │   │   ├── FileReader.py
    │   │   ├── I18nextReader.py
    │   │   ├── LrcReader.py
    │   │   ├── MdReader.py
    │   │   ├── MToolReader.py
    │   │   ├── OfficeConversionReader.py
    │   │   ├── ParatranzReader.py
    │   │   ├── PoReader.py
    │   │   ├── ReaderUtil.py
    │   │   ├── RenpyReader.py
    │   │   ├── SrtReader.py
    │   │   ├── TPPReader.py
    │   │   ├── TransReader.py
    │   │   ├── TxtReader.py
    │   │   ├── VntReader.py
    │   │   ├── VttReader.py
    │   │   └── unused/
    │   │       └── LanguageDetectorONNX.py
    │   ├── LLMRequester/
    │   │   ├── AmazonbedrockRequester.py
    │   │   ├── AnthropicRequester.py
    │   │   ├── CohereRequester.py
    │   │   ├── DashscopeRequester.py
    │   │   ├── GoogleRequester.py
    │   │   ├── LLMClientFactory.py
    │   │   ├── LLMRequester.py
    │   │   ├── LocalLLMRequester.py
    │   │   ├── OpenaiRequester.py
    │   │   └── SakuraRequester.py
    │   ├── NERProcessor/
    │   │   └── NERProcessor.py
    │   ├── PromptBuilder/
    │   │   ├── PromptBuilder.py
    │   │   ├── PromptBuilderEnum.py
    │   │   ├── PromptBuilderLocal.py
    │   │   ├── PromptBuilderPolishing.py
    │   │   └── PromptBuilderSakura.py
    │   ├── RequestLimiter/
    │   │   └── RequestLimiter.py
    │   ├── ResponseChecker/
    │   │   ├── AdvancedChecks.py
    │   │   ├── BaseChecks.py
    │   │   ├── ResponseChecker.py
    │   │   └── TranslationChecker.py
    │   ├── ResponseExtractor/
    │   │   └── ResponseExtractor.py
    │   ├── SimpleExecutor/
    │   │   └── SimpleExecutor.py
    │   ├── TaskConfig/
    │   │   ├── TaskConfig.py
    │   │   └── TaskType.py
    │   ├── TaskExecutor/
    │   │   ├── PolisherTask.py
    │   │   ├── TaskExecutor.py
    │   │   ├── TranslatorTask.py
    │   │   └── TranslatorUtil.py
    │   └── TextProcessor/
    │       ├── PolishTextProcessor.py
    │       └── TextProcessor.py
    ├── PluginScripts/
    │   ├── README.md
    │   ├── PluginBase.py
    │   ├── BilingualPlugin/
    │   │   └── BilingualPlugin.py
    │   ├── GeneralTextFilter/
    │   │   └── GeneralTextFilter.py
    │   ├── IncrementalFilePlugin/
    │   │   └── IncrementalFilePlugin.py
    │   ├── IOPlugins/
    │   │   └── CustomRegistry.py
    │   ├── LanguageFilter/
    │   │   └── LanguageFilter.py
    │   ├── MToolOptimizer/
    │   │   └── MToolOptimizer.py
    │   ├── SpecialTextFilter/
    │   │   └── SpecialTextFilter.py
    │   ├── TextLayoutRepairPlugin/
    │   │   └── TextLayoutRepairPlugin.py
    │   ├── TextNormalizer/
    │   │   └── TextNormalizer.py
    │   └── TranslationCheckPlugin/
    │       └── TranslationCheckPlugin.py
    ├── Resource/
    │   ├── Localization/
    │   │   ├── APIManagement.json
    │   │   ├── AppFluentWindow.json
    │   │   ├── ApplicationSettings.json
    │   │   ├── BasicTablePage.json
    │   │   ├── EditView.json
    │   │   ├── MonitoringPage.json
    │   │   ├── OutputSettings.json
    │   │   ├── PolishingSettings.json
    │   │   ├── PromptSettings.json
    │   │   ├── StartupPage.json
    │   │   ├── TableSettings.json
    │   │   ├── TaskSettings.json
    │   │   ├── TranslationChecker.json
    │   │   ├── TranslationSettings.json
    │   │   └── VersionManager.json
    │   ├── Models/
    │   │   ├── language_detection-ONNX/
    │   │   │   └── .gitkeep
    │   │   └── ner/
    │   │       └── ja_core_news_md/
    │   │           ├── README.md
    │   │           ├── accuracy.json
    │   │           ├── config.cfg
    │   │           ├── LICENSE
    │   │           ├── meta.json
    │   │           ├── attribute_ruler/
    │   │           │   └── patterns
    │   │           ├── morphologizer/
    │   │           │   ├── cfg
    │   │           │   └── model
    │   │           ├── ner/
    │   │           │   ├── cfg
    │   │           │   └── moves
    │   │           ├── parser/
    │   │           │   ├── cfg
    │   │           │   └── moves
    │   │           ├── senter/
    │   │           │   └── cfg
    │   │           ├── tokenizer/
    │   │           │   └── cfg
    │   │           └── vocab/
    │   │               └── vectors.cfg
    │   ├── platforms/
    │   │   └── preset.json
    │   ├── Prompt/
    │   │   ├── Format/
    │   │   │   └── format_system_zh.txt
    │   │   ├── Local/
    │   │   │   ├── local_system_en.txt
    │   │   │   └── local_system_zh.txt
    │   │   ├── Polishing/
    │   │   │   ├── common_system_zh_s.txt
    │   │   │   └── common_system_zh_t.txt
    │   │   ├── Sakura/
    │   │   │   └── sakura_system_zh.txt
    │   │   └── Translate/
    │   │       ├── common_system_en.txt
    │   │       ├── common_system_zh.txt
    │   │       ├── cot_system_en.txt
    │   │       ├── cot_system_zh.txt
    │   │       ├── think_system_en.txt
    │   │       └── think_system_zh.txt
    │   ├── Regex/
    │   │   ├── check_regex.json
    │   │   └── regex.json
    │   └── Version/
    │       └── version.json
    ├── skimage/
    │   └── metrics.py
    ├── StevExtraction/
    │   ├── config.yaml
    │   ├── main.py
    │   ├── main更新记录.txt
    │   ├── rpgmaker_codes.txt
    │   ├── scratchpad.py
    │   ├── 使用说明.md
    │   ├── 更新记录.txt
    │   └── 自动换行.js
    ├── Tools/
    │   ├── pyinstall.py
    │   └── rust_updater/
    │       ├── Cargo.toml
    │       └── src/
    │           └── main.rs
    ├── UserInterface/
    │   ├── AppFluentWindow.py
    │   ├── BaseNavigationItem.py
    │   ├── EditView/
    │   │   ├── BasicTablePage.py
    │   │   ├── EditViewPage.py
    │   │   ├── Check/
    │   │   │   ├── CheckResultPage.py
    │   │   │   └── LanguageCheckDialog.py
    │   │   ├── Monitoring/
    │   │   │   └── MonitoringPage.py
    │   │   ├── Search/
    │   │   │   ├── SearchDialog.py
    │   │   │   └── SearchResultPage.py
    │   │   ├── Startup/
    │   │   │   └── StartupPage.py
    │   │   ├── Term/
    │   │   │   ├── TermExtractionDialog.py
    │   │   │   └── TermResultPage.py
    │   │   └── Timer/
    │   │       └── ScheduledDialogPage.py
    │   ├── Extraction_Tool/
    │   │   ├── Export_Source_Text.py
    │   │   ├── Export_Update_Text.py
    │   │   └── Import_Translated_Text.py
    │   ├── NameExtractor/
    │   │   └── NameExtractor.py
    │   ├── Platform/
    │   │   ├── APIEditPage.py
    │   │   ├── ArgsEditPage.py
    │   │   ├── LimitEditPage.py
    │   │   ├── ModelBrowserDialog.py
    │   │   └── PlatformPage.py
    │   ├── PolishingSettings/
    │   │   ├── PolishingBasicSettingsPage.py
    │   │   ├── PolishingStylePromptPage.py
    │   │   └── PolishingSystemPromptPage.py
    │   ├── Settings/
    │   │   ├── AppSettingsPage.py
    │   │   ├── OutputSettingsPage.py
    │   │   ├── PluginsSettingsPage.py
    │   │   └── TaskSettingsPage.py
    │   ├── Table/
    │   │   ├── ExclusionListPage.py
    │   │   ├── PromptDictionaryPage.py
    │   │   ├── TextReplaceAPage.py
    │   │   └── TextReplaceBPage.py
    │   ├── TableHelper/
    │   │   └── TableHelper.py
    │   ├── TranslationSettings/
    │   │   ├── CharacterizationPromptPage.py
    │   │   ├── SystemPromptPage.py
    │   │   ├── TranslationExamplePromptPage.py
    │   │   ├── TranslationSettingsPage.py
    │   │   ├── WorldBuildingPromptPage.py
    │   │   └── WritingStylePromptPage.py
    │   └── VersionManager/
    │       └── VersionManager.py
    ├── Widget/
    │   ├── ActionCard.py
    │   ├── APITypeCard.py
    │   ├── CombinedLineCard.py
    │   ├── ComboBoxCard.py
    │   ├── CommandBarCard.py
    │   ├── DashboardCard.py
    │   ├── EditableComboBoxCard.py
    │   ├── EmptyCard.py
    │   ├── FlowCard.py
    │   ├── FolderDropCard.py
    │   ├── GameDropCard.py
    │   ├── GroupCard.py
    │   ├── InterfaceDropZoneWidget.py
    │   ├── LineEditCard.py
    │   ├── LineEditMessageBox.py
    │   ├── PlainTextEditCard.py
    │   ├── ProgressRingCard.py
    │   ├── PushButtonCard.py
    │   ├── SliderCard.py
    │   ├── SpinCard.py
    │   ├── SwitchButtonCard.py
    │   ├── VerticalSeparator.py
    │   └── WaveformCard.py
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── bug_issue.yml
        │   └── opinion.yml
        └── workflows/
            └── main.yml

================================================
FILE: README.md
================================================
[Binary file]


================================================
FILE: AiNiee.py
================================================
#
#                        _oo0oo_
#                       o8888888o
#                       88" . "88
#                       (| -_- |)
#                       0\  =  /0
#                     ___/`---'\___
#                   .' \\|     |// '.
#                  / \\|||  :  |||// \
#                 / _||||| -:- |||||- \
#                |   | \\\  -  /// |   |
#                | \_|  ''\---/''  |_/ |
#                \  .-\__  '-'  ___/-. /
#              ___'. .'  /--.--\  `. .'___
#           ."" '<  `.___\_<|>_/___.' >' "".
#          | | :  `- \`.;`\ _ /`;.`/ - ` : | |
#          \  \ `_.   \_ __\ /__ _/   .-` /  /
#      =====`-.____`.___ \_____/___.-`___.-'=====
#                        `=---='
#
#
#      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#             赛博佛祖光耀照，程序运行永无忧。
#             翻译之路顺畅通，字字珠玑无误漏。

import os
import sys
import multiprocessing
import warnings

import rapidjson as json
from bs4 import MarkupResemblesLocatorWarning
from rich import print
from PyQt5.QtGui import QFont, QIcon, QColor
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QApplication, QSplashScreen


# 过滤protobuf的警告信息
warnings.filterwarnings(
    action='ignore',
    message=r'.*SymbolDatabase\.GetPrototype\(\) is deprecated.*',  # 使用正则表达式匹配警告消息
    category=UserWarning,
    module=r'google\.protobuf\.symbol_database'  # 警告来源的模块 (正则)
)
# 过滤pBeautiful Soup的警告信息
warnings.filterwarnings("ignore", category=MarkupResemblesLocatorWarning)

def display_banner():
    print(" █████   ██  ███    ██  ██  ███████  ███████ ")
    print("██   ██  ██  ████   ██  ██  ██       ██      ")
    print("███████  ██  ██ ██  ██  ██  █████    █████   ")
    print("██   ██  ██  ██  ██ ██  ██  ██       ██      ")
    print("██   ██  ██  ██   ████  ██  ███████  ███████ ")
    print("                                        ")
    print("                                        ")

# 载入配置文件
def load_config() -> dict:
    config = {}
    config_path = os.path.join(".", "Resource", "config.json")
    if os.path.exists(config_path):
        with open(config_path, "r", encoding="utf-8") as reader:
            config = json.load(reader)
    return config

# 载入版本信息函数
def load_version() -> str:
    """从 Resource/Version/version.json 加载版本信息"""
    version_path = os.path.join(".", "Resource", "Version", "version.json")
    default_version = "Unknown Version"
    if os.path.exists(version_path):
        try:
            with open(version_path, "r", encoding="utf-8") as f:
                version_data = json.load(f)
                # 使用 .get() 方法安全地获取值，如果 "version" 键不存在，则返回默认值
                return version_data.get("version", default_version)
        except (json.JSONDecodeError, IOError) as e:
            print(f"[[red]ERROR[/]] 读取版本文件失败: {e}")
            return default_version
    else:
        print(f"[[yellow]WARNING[/]] 版本文件 {version_path} 未找到, 将使用默认版本号。")
        return default_version

# 启动画面消息
def update_splash_message(splash, message, app, font_size=10, font_weight=QFont.Bold):
    font = QFont("Microsoft YaHei")
    font.setPointSize(font_size)
    font.setWeight(font_weight)
    
    # 创建淡粉红色
    text_color = QColor(255, 182, 193)
    
    splash.setFont(font)
    
    # 应用淡粉红颜色到文本
    splash.showMessage(message, Qt.AlignBottom | Qt.AlignCenter, text_color)
    
    app.processEvents()

if __name__ == "__main__":
    # 开启子进程支持
    multiprocessing.freeze_support()

    # 启用了高 DPI 缩放
    QApplication.setHighDpiScaleFactorRoundingPolicy(Qt.HighDpiScaleFactorRoundingPolicy.PassThrough)
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)

    # 设置工作目录
    script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
    os.chdir(script_dir) # 确保工作目录在脚本所在目录
    sys.path.append(script_dir)

    # 加载配置文件
    config = load_config()
    
    # 加载版本信息
    app_version = load_version()

    # 设置全局缩放比例
    scale_factor_str = config.get("scale_factor", "")
    if scale_factor_str == "50%":
        os.environ["QT_SCALE_FACTOR"] = "0.50"
    elif scale_factor_str == "75%":
        os.environ["QT_SCALE_FACTOR"] = "0.75"
    elif scale_factor_str == "125%":
        os.environ["QT_SCALE_FACTOR"] = "1.25"
    elif scale_factor_str == "150%":
        os.environ["QT_SCALE_FACTOR"] = "1.50"
    elif scale_factor_str == "200%":
        os.environ["QT_SCALE_FACTOR"] = "2.00"

    # 创建全局应用对象
    app = QApplication(sys.argv)

    display_banner()
    print(f"[[green]INFO[/]] Application Version: {app_version}") # 打印版本号
    print(f"[[green]INFO[/]] Current working directory is {script_dir}")
    print(f"[[green]INFO[/]] Starting AiNiee Application...")

    # 启动页面
    logo_path = os.path.join(".", "Resource", "Logo", "Logo.png")
    icon = QIcon(logo_path)  # 使用QIcon加载logo
    pixmap = icon.pixmap(400, 200)  # 从QIcon获取指定大小的QPixmap
    # 跟随缩放比例
    if "QT_SCALE_FACTOR" in os.environ:
        scale_factor = float(os.environ["QT_SCALE_FACTOR"])
        pixmap = pixmap.scaled(
            int(pixmap.width() * scale_factor),
            int(pixmap.height() * scale_factor),
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation
        )
    splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
    splash.setEnabled(False)  # 禁用用户交互，可能改善渲染

    # 显示启动页面
    splash.show()
    update_splash_message(splash, "正在初始化...", app)  # 显示初始化消息



    # 设置全局字体属性，解决狗牙问题
    font = QFont("Consolas")
    if config.get("font_hinting", True):
        font.setHintingPreference(QFont.PreferFullHinting)
    else:
        font.setHintingPreference(QFont.PreferNoHinting)
    app.setFont(font)

    # 创建全局插件管理器
    update_splash_message(splash, "正在加载插件管理器... (10%)", app) # 更新启动页消息
    from Base.PluginManager import PluginManager
    plugin_manager = PluginManager()
    plugin_path = os.path.join(".", "PluginScripts")
    plugin_manager.load_plugins_from_directory(plugin_path)

    # 创建全局缓存器
    update_splash_message(splash, "正在加缓存器... (15%)", app)
    from ModuleFolders.Cache.CacheManager import CacheManager
    cache_manager = CacheManager()

    # 创建全局文件读写器(高性能消耗)
    update_splash_message(splash, "正在加载文件读写器... (25%)", app) 
    from ModuleFolders.FileReader.FileReader import FileReader
    file_reader = FileReader()
    from ModuleFolders.FileOutputer.FileOutputer import FileOutputer
    file_writer = FileOutputer()


    # 创建窗口对象(高性能消耗)
    update_splash_message(splash, "正在加载核心组件... (50%)", app)
    from UserInterface.AppFluentWindow import AppFluentWindow
    app_fluent_window = AppFluentWindow(
        version=app_version,
        plugin_manager=plugin_manager,
        cache_manager=cache_manager,
        file_reader =file_reader,
    )

    # 创建简易执行器对象，并初始化订阅事件
    update_splash_message(splash, "正在加载简易执行器... (60%)", app)
    from ModuleFolders.SimpleExecutor.SimpleExecutor import SimpleExecutor
    simple_executor = SimpleExecutor()

    # 创建任务执行器，并初始化订阅事件(高性能消耗)
    update_splash_message(splash, "正在加载任务执行器... (75%)", app)
    from ModuleFolders.TaskExecutor.TaskExecutor import TaskExecutor
    task_executor = TaskExecutor(
        plugin_manager=plugin_manager,
        cache_manager=cache_manager,
        file_reader=file_reader, 
        file_writer=file_writer
    )


    update_splash_message(splash, "启动完成，正在打开应用... (100%)", app)

    # 显示全局窗口
    app_fluent_window.show()

    # 隐藏启动页面
    splash.finish(app_fluent_window)

    # 进入事件循环，等待用户操作
    sys.exit(app.exec_())


================================================
FILE: hyperscan.py
================================================
# BabelDOC用于存储术语表，此处仅用于占位



================================================
FILE: LICENSE
================================================
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.


================================================
FILE: README_EN.md
================================================
<div align="center">
  <a href="https://github.com/NEKOparapa/AiNiee-chatgpt">
    <img src="https://github.com/NEKOparapa/AiNiee-chatgpt/blob/main/Example%20image/logo.png" width=60% >
  </a>
</div>


<div align="center">
  
![GitHub stars](https://img.shields.io/github/stars/NEKOparapa/AiNiee?style=flat)  
![GitHub all releases downloads](https://img.shields.io/github/downloads/NEKOparapa/AiNiee/total?style=flat&color=orange)  
![Yesterday Activity](https://img.shields.io/endpoint?url=https://ai-niee-vercel.vercel.app/api/stats%3Ftype%3Dyesterday) 
![Average Activity](https://img.shields.io/endpoint?url=https://ai-niee-vercel.vercel.app/api/stats%3Ftype%3Daverage)

</div>

---


## Introduction🧾 

  
<div align="center">
<strong>AiNiee</strong> is a tool specializing in AI translation,<br>enabling one-click automatic translation of complex long-text content such as games, books, subtitles, and documents.
</div>

*   **All-in-One Format Support, Broad Coverage**
    *   🎮 **Game Translation**: In-depth support for game text export tools like Mtool, Renpy, Translator++, ParaTranzr, VNText, and SExtractor.
    *   📚 **Diverse Support**: Effortlessly processes I18Next data, Epub/TXT e-books, Srt/Vtt/Lrc subtitles, Word/PDF/MD documents, and more.

*   **Smart & Efficient, Saves Time & Effort**
    *   🚀 **One-Click Operation**: Simply drag and drop; automatically identifies files and languages, no setup required.
    *   ⏱️ **Rapid Translation**: Get your translated text in the time it takes to enjoy a cup of tea.

*   **Optimized for Long Texts, Exceptional Quality**
    *   🎯 **Overcoming Limitations**: Employs techniques like streamlined translation formats, chain-of-thought translation, AI glossaries, and contextual awareness to ensure coherence and accuracy in long-text translations.

    *   💎 **Quality Focus**: Supports prompt adjustments for basic instructions, character introductions, background settings, translation styles, etc. Equipped with features such as one-click AI refinement, one-click AI formatting, and AI terminology extraction, it caters to users who demand higher translation quality.

---

## Three Steps to Use AiNiee 📢

* **Step 1: Configure Interface**
  > <img src="https://raw.githubusercontent.com/NEKOparapa/AiNiee/main/Example%20image/三步走/Step1.png">

  - Online Interface: Paid but cost-effective, no GPU requirements, full language support, [Interface Setup Guide - DeepSeek](https://github.com/NEKOparapa/AiNiee/wiki/QuickStartDeepSeek)
  - Online Interface: Same as above, if DeepSeek official website is not accessible, you can use this alternative, [Interface Setup Guide - Volcano Engine](https://github.com/NEKOparapa/AiNiee/wiki/QuickStartHuo)
  
* **Step 2: Drag into the folder**
  > <img src="https://raw.githubusercontent.com/NEKOparapa/AiNiee/main/Example%20image/三步走/Step2.png">

  - Target Language: In the translation settings, change the target language to the one you need.<br>

  - Input Folder: Place the original files in this folder; novels, subtitles, documents can be translated directly, games require text extraction tools<br>

* **Step 3: Start Translation**

  > <img src="https://raw.githubusercontent.com/NEKOparapa/AiNiee/main/Example%20image/三步走/Step3.png">

  - Click the start button and wait for the task to complete.

  - [AiNiee Download Link](https://github.com/NEKOparapa/AiNiee/releases)

---

<details>
<summary>

## Feature Description[![](https://raw.githubusercontent.com/aregtech/areg-sdk/master/docs/img/pin.svg)](#feature-description)
</summary>



<details>
<summary>

### Settings Description
</summary>

- [Feature - API Management](https://github.com/NEKOparapa/AiNiee/wiki/%E5%8A%9F%E8%83%BD%E2%80%90%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86)
- [Feature - Gemini Translation](https://github.com/NEKOparapa/AiNiee/wiki/%E5%8F%8C%E5%AD%90%E6%98%9F%E7%BF%BB%E8%AF%91%E4%BB%8B%E7%BB%8D)

</details>



<details>
<summary>

### Table Description
</summary>

- [Table - AI Glossary](https://github.com/NEKOparapa/AiNiee/wiki/%E8%A1%A8%E6%A0%BC%E2%80%90AI%E6%9C%AF%E8%AF%AD%E8%A1%A8%E4%BB%8B%E7%BB%8D)
- [Table - AI Do Not Translate List](https://github.com/NEKOparapa/AiNiee/wiki/%E8%A1%A8%E6%A0%BC%E2%80%90AI%E7%A6%81%E7%BF%BB%E8%A1%A8%E4%BB%8B%E7%BB%8D)
- [Table - Text Replacement](https://github.com/NEKOparapa/AiNiee/wiki/%E8%A1%A8%E6%A0%BC%E2%80%90%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2%E4%BB%8B%E7%BB%8D)

</details>




<details>
<summary>

### Plugin Description
</summary>

- [Plugin - Language Filter](https://github.com/NEKOparapa/AiNiee/wiki/%E6%8F%92%E4%BB%B6%E2%80%90LanguageFilter)
- [Plugin - Text Normalizer](https://github.com/NEKOparapa/AiNiee/wiki/%E6%8F%92%E4%BB%B6%E2%80%90TextNormalizer)

</details>



<details>
<summary>

### Other Notes
</summary>

* `Multiple Key Rotation`
  > If you want to use multiple keys to distribute the load and speed up translation based on the number of keys, please use keys from the same account type. When inputting, add an English comma between each key, without line breaks. For example: key1,key2,key3

* `Batch File Translation`
  > Simply place all files that need translation into the input folder. It also supports multi-folder structures.

* `Configuration Migration`
  > Configuration information is stored in `resource/config.json`. When you download a new version, you can copy this file to the `resource` folder of the new version.

</details>





</details>

---

<details>
<summary>

## Contribution Guidelines[![](https://raw.githubusercontent.com/aregtech/areg-sdk/master/docs/img/pin.svg)](#contribution-guidelines)  
</summary>


* **`Develop Enhanced Plugins`**: Please follow the [Plugin Development Guide](https://github.com/NEKOparapa/AiNiee/blob/main/PluginScripts/README.md) to develop plugins with stronger functionality

* **`Improve or Add Supported Files`**: Requires some programming ability to pull the source code and make improvements. Specific file reading code is in the ModuleFolders\FileReader and FileOutputer folders. [Reader-Writer System Development Guide](https://github.com/NEKOparapa/AiNiee/blob/main/ModuleFolders/FileAccessor/README.md). UI support is in UserInterface\Setting\ProjectSettingsPage.

* **`Improve the Regex Library`**: A comprehensive regex library will greatly help with in-game embedding work and benefit future game translation work and other translation users. The regex library is in the [Resource\Regex](https://github.com/NEKOparapa/AiNiee/blob/main/Resource/Regex/regex.json) folder

* **`Improve Interface Translation`**: The UI text for multilingual interfaces may not be translated accurately or appropriately. You can submit your modification suggestions or make changes directly. Localization text is in the [Resource\Localization](https://github.com/NEKOparapa/AiNiee/tree/main/Resource/Localization) folder

</details>


---

## Special Statement[![](https://raw.githubusercontent.com/aregtech/areg-sdk/master/docs/img/pin.svg)](#special-statement)   
AiNiee's continuous development and iteration to this day is due to ongoing personal research and development of key functional frameworks since the project's inception, user feedback and suggestions, and the joint efforts and creations of contributors through PRs.
This is a process of continuous exploration, improvement, and joint construction over two years, which has formed AiNiee's relatively mature and complete AI translation system today.
Please respect the open-source spirit while using and learning, attribute the source project, and don't forget to give the project a star.

This AI translation tool is for personal legal use only. Any direct or indirect illegal profit-making activities using this tool are not within the scope of authorization and are not supported or endorsed.

* **`Community Groups`**: TG Group: https://t.me/+JVHbDSGo8SI2Njhl

---



================================================
FILE: requirements.txt
================================================
# System
pyinstaller
openai
boto3
cohere
anthropic
google-genai
tiktoken
numpy
openpyxl
PyQt5
PyQt-Fluent-Widgets[full]
opencc
beautifulsoup4
lxml
chardet
PyYAML
requests
httpx[http2]

# Tools
polib
pandas
rich
tqdm
jaconv
python-rapidjson
protobuf==4.25.7
# 获取iso语言代码对应的友好名称
language-data
langcodes
msgspec

#NER
spacy
sudachipy
sudachidict-core

# mediapipe
absl-py
attrs>=19.1.0
flatbuffers>=2.0
matplotlib
sounddevice>=0.4.4

# BabelDOC
# onnx 新版本打包后不能运行，这里使用 onnx==1.16.1 onnxruntime==1.20.1
# rapidocr-onnxruntime 依赖了 opencv-python，所以去除了 opencv-python-headless
# 不使用 babeldoc.document_il.midend.detect_scanned_file.DetectScannedFile 所以去除 scikit-image>=0.25.2
bitstring>=4.3.0
configargparse>=1.7
httpx[socks]>=0.27.0
huggingface-hub>=0.27.0
numpy>=2.0.2
onnx==1.16.1
onnxruntime==1.20.1
openai>=1.59.3
orjson>=3.10.14
pdfminer-six==20250416
peewee>=3.17.8
psutil>=7.0.0
pymupdf>=1.25.1
rich>=13.9.4
toml>=0.10.2
tqdm>=4.67.1
xsdata[cli,lxml,soap]>=24.12
msgpack>=1.1.0
pydantic>=2.10.6
tenacity>=9.0.0
freetype-py>=2.5.1
tiktoken>=0.9.0
python-levenshtein>=0.27.1
rapidocr-onnxruntime>=1.4.4
pyzstd
rtree
scikit-learn>=1.7.1



================================================
FILE: requirements_no_deps.txt
================================================
# 无依赖安装 pip install --no-deps
mediapipe==0.10.14
BabelDOC



================================================
FILE: Base/Base.py
================================================
[Binary file]


================================================
FILE: Base/EventManager.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtCore import QObject
from PyQt5.QtCore import pyqtSignal

class EventManager(QObject):

    # 单一实例
    _singleton = None

    # 自定义信号
    # 字典类型或者其他复杂对象应该使用 object 作为信号参数类型，这样可以传递任意 Python 对象，包括 dict
    signal = pyqtSignal(int, object)

    # 事件列表
    event_callbacks = {}

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.signal.connect(self.process_event, Qt.QueuedConnection)

    # 获取单例
    def get_singleton():
        if EventManager._singleton == None:
            EventManager._singleton = EventManager()

        return EventManager._singleton

    # 处理事件
    def process_event(self, event: int, data: dict):
        if event in self.event_callbacks:
            for hanlder in self.event_callbacks[event]:
                hanlder(event, data)

    # 触发事件
    def emit(self, event: int, data: dict):
        self.signal.emit(event, data)

    # 订阅事件
    def subscribe(self, event: int, hanlder: callable):
        if event not in self.event_callbacks:
            self.event_callbacks[event] = []
        self.event_callbacks[event].append(hanlder)

    # 取消订阅事件
    def unsubscribe(self, event: int, hanlder: callable):
        if event in self.event_callbacks:
            self.event_callbacks[event].remove(hanlder)



================================================
FILE: Base/PluginManager.py
================================================
import importlib
import os
from pathlib import Path
from PluginScripts.PluginBase import PluginBase

class PluginManager:

    def __init__(self):

        # 使用字典来存储每个事件对应的插件列表
        self.event_plugins = {}

        # 记录每个插件的启用状态
        self.plugins_enable = {}

    def load_plugin(self, plugin_class):
        plugin_instance = plugin_class()
        plugin_instance.load()

        # 注册插件到所有它感兴趣的事件，但不进行排序
        for event_info in plugin_instance.events:
            event_name = event_info['event']
            if event_name not in self.event_plugins:
                self.event_plugins[event_name] = []
            self.event_plugins[event_name].append(plugin_instance)

    def unload_plugin(self, plugin_instance):
        pass

    def broadcast_event(self, event_name, config=None, event_data=None):
        # 只触发注册了该事件的插件，并在调用前进行排序
        if event_name in self.event_plugins:
            # 根据优先级进行排序
            sorted_plugins = sorted(
                self.event_plugins[event_name],
                key=lambda x: next((event['priority'] for event in x.events if event['event'] == event_name), 0),
                reverse=True
            )

            # 根据启用状态进行过滤，默认为启用
            sorted_plugins = [plugin for plugin in sorted_plugins if self.plugins_enable.get(plugin.name, True)]

            #print(sorted_plugins) #bug用
            for plugin in sorted_plugins:
                plugin.on_event(event_name, config, event_data)

    def load_plugins_from_directory(self, directory):
        directory_path = Path(directory)
        for py_file in directory_path.rglob('*.py'):  # 使用rglob递归地查找所有.py文件
            if py_file.name.startswith('__'):  # 跳过以__开头的文件
                continue
            if py_file.stem == "Plugin_Manager.py":  # 跳过Plugin_Manager.py文件
                continue

            # 构建模块名，需要将文件路径转换为模块路径
            module_path = py_file.relative_to(directory_path.parent).with_suffix('')
            module_name = str(module_path).replace(os.sep, '.')

            # 动态导入模块
            module = importlib.import_module(module_name)

            # 遍历模块属性，查找插件
            for attribute_name in dir(module):
                attribute = getattr(module, attribute_name)
                if isinstance(attribute, type) and issubclass(attribute, PluginBase) and attribute is not PluginBase:
                    self.load_plugin(attribute)

    # 生成插件列表
    def get_plugins(self) -> dict:
        plugins = {}

        for k, v in self.event_plugins.items():
            for item in v:
                if item.visibility == True:
                    plugins[item.name] = item

        return plugins

    # 更新插件启用状态
    def update_plugins_enable(self, plugins_enable):
        self.plugins_enable = plugins_enable


================================================
FILE: ModuleFolders/Cache/BaseCache.py
================================================
import copy
import threading
from contextlib import contextmanager
from dataclasses import dataclass, fields
from functools import cache
from reprlib import Repr
from types import UnionType
from typing import Any, ClassVar, Union, get_args, get_origin

_ATOMIC_TYPES = frozenset([
    bool,
    int,
    float,
    str,
])


@cache
def _get_fields(cls):
    return fields(cls)


class DictMixin:

    def _to_dict_part(self, obj, keep_none=False) -> Any:
        if type(obj) in _ATOMIC_TYPES:
            # 基本数据类型
            return obj
        elif isinstance(obj, DictMixin):
            return obj.to_dict(keep_none)
        elif isinstance(obj, tuple) and hasattr(obj, '_fields'):
            # namedtuple
            return type(obj)(*map(self._to_dict_part, obj))
        elif isinstance(obj, (list, tuple, set, frozenset)):
            # 集合
            return type(obj)(map(self._to_dict_part, obj))
        elif isinstance(obj, dict):
            if hasattr(type(obj), 'default_factory'):
                # defaltdict
                result = type(obj)(getattr(obj, 'default_factory'))
                for k, v in obj.items():
                    result[self._to_dict_part(k)] = self._to_dict_part(v)
                return result
            return type(obj)(
                (self._to_dict_part(k), self._to_dict_part(v))
                for k, v in obj.items()
            )
        else:
            return copy.deepcopy(obj)

    def to_dict(self, keep_none=False) -> dict[str, Any]:
        result = {}
        for f in _get_fields(self.__class__):
            name = f.name
            value = getattr(self, name)
            # 默认None不参与dict转换
            if name.startswith("_") or (value is None and not keep_none):
                continue
            else:
                result[name] = self._to_dict_part(value, keep_none)
        return result

    @classmethod
    def _from_define(cls, type_, data) -> Any:
        if type(type_) is type:
            if type_ in _ATOMIC_TYPES and type(data) in _ATOMIC_TYPES:
                # 基本数据类型
                return data
            elif issubclass(type_, DictMixin) and isinstance(data, dict):
                return type_.from_dict(data)
            elif hasattr(type_, "_fields") and issubclass(type_, tuple) and isinstance(data, (list, tuple)):
                return type_(*(cls._from_define(Any, x) for x in data))
            elif data is None:
                return None
            raise ValueError(f"不能从定义 {type_} 加载数据 {data}")
        elif type_ is Any:
            return copy.deepcopy(data)
        elif data is None:
            return None

        type_origin = get_origin(type_)
        args = get_args(type_)

        # 容器类型必须定义泛型
        if type_origin is None or args is None:
            raise ValueError(f"不支持的类型 {type_} {data} {args}")
        elif type_origin in [Union, UnionType]:  # Union类型的处理
            # 尝试使用能够匹配的第一个类型
            for arg in args:
                if arg is type(None) and data is None:
                    return None
                try:
                    return cls._from_define(arg, data)
                except (ValueError, TypeError):
                    continue
            # 如果都不匹配，直接返回数据
            return data
        elif issubclass(type_origin, tuple) and isinstance(data, (list, tuple)):
            # 元组
            if len(args) == 2 and args[1] is Ellipsis:
                # tuple[int, ...]
                return type_(cls._from_define(args[0], x) for x in data)
            else:
                # tuple[int, str, float, int]
                if len(args) != len(data):
                    raise ValueError(f"元组的定义 {type_} 不符合数据 {data}")
                return type_(cls._from_define(arg, dat) for arg, dat in zip(args, data))
        elif issubclass(type_origin, (list, set, frozenset)) and isinstance(data, (list, set, frozenset)):
            # 集合
            return type_origin(cls._from_define(args[0], x) for x in data)
        elif issubclass(type_origin, dict) and isinstance(data, dict):
            # 字典
            key_type, value_type = args
            if hasattr(type_origin, 'default_factory'):
                # defaultdict
                return type_origin(value_type, (
                    (cls._from_define(key_type, k), cls._from_define(value_type, v))
                    for k, v in data.items()
                ))
            else:
                return type_origin(
                    (cls._from_define(key_type, k), cls._from_define(value_type, v))
                    for k, v in data.items()
                )
        else:
            raise ValueError(f"不能从定义 {type_} 加载数据 {data}")

    @classmethod
    def from_dict[T: DictMixin](cls: type[T], data: dict[str, Any]) -> T:
        # dacite 会覆盖__post_init__的属性，所以不用
        init_vars = {}
        for field_ in _get_fields(cls):
            field_name = field_.name
            field_type = field_.type
            if field_name in data:
                init_vars[field_name] = cls._from_define(field_type, data[field_name])
        return cls(**init_vars)

    _repr: ClassVar[Repr] = Repr(maxdict=1, maxother=256)

    def __repr__(self) -> str:
        fields_str = []
        for name, value in vars(self).items():
            if name.startswith("_"):
                continue
            fields_str.append(f"{name}={self._repr.repr(value)}")
        return f"{self.__class__.__name__}({', '.join(fields_str)})"


@dataclass(repr=False)
class ThreadSafeCache(DictMixin):

    @property
    def _lock(self):
        return self._LOCK_POOL[id(self) % self._LOCK_POOL_SIZE]

    @contextmanager
    def atomic_scope(self):
        """一次读/写多个属性"""
        with self._lock:
            yield

    def to_dict(self, keep_none=False) -> dict[str, Any]:
        with self._lock:
            return super().to_dict(keep_none)

    # 质数减少取模后的碰撞
    _LOCK_POOL_SIZE: ClassVar[int] = 997
    _LOCK_POOL: ClassVar[tuple[threading.RLock]] = tuple(threading.RLock() for _ in range(_LOCK_POOL_SIZE))


class ExtraMixin:
    """统一管理extra属性的方法"""

    def _extra(self) -> dict[str, Any]:
        raise NotImplementedError

    def set_extra(self, key, value):
        if value is not None:
            self._extra()[key] = value

    def get_extra(self, key, default=None):
        return self._extra().get(key, default)

    def require_extra(self, key):
        return self._extra()[key]



================================================
FILE: ModuleFolders/Cache/CacheFile.py
================================================
import os
from dataclasses import dataclass, field
from functools import cached_property
from typing import Any

from ModuleFolders.Cache.BaseCache import ExtraMixin, ThreadSafeCache
from ModuleFolders.Cache.CacheItem import CacheItem


@dataclass(repr=False)
class CacheFile(ThreadSafeCache, ExtraMixin):
    """文件元数据"""

    storage_path: str = ""
    """文件相对路径"""

    encoding: str = "utf-8"
    """默认编码"""

    file_project_type: str = ""
    """文件项目类型"""

    line_ending: str = os.linesep
    """默认换行符"""

    items: list[CacheItem] = field(default_factory=list)
    """原文片段列表"""

    language_stats: list[tuple[str, int, float]] = field(default_factory=list)
    """检测到的语言次数与对应的平均置信度，可能有多种语言的存在"""

    lc_language_stats: list[tuple[str, int, float]] = field(default_factory=list)
    """检测到的低置信度的语言统计，主要在语言检测器中有用"""

    extra: dict[str, Any] = field(default_factory=dict)
    """额外属性，用于存储特定reader产生的文件的额外属性，共用属性请加到CacheFile中"""

    @property
    def file_name(self):
        return os.path.split(self.storage_path)[1]

    def add_item(self, item: CacheItem) -> None:
        """线程安全添加缓存项"""
        with self._lock:
            if hasattr(self, "items_dict"):
                del self.items_dict
            self.items.append(item)

    def get_item(self, text_index: int) -> CacheItem:
        """线程安全获取缓存项"""
        with self._lock:
            return self.items[self.items_index_dict[text_index]]

    @cached_property
    def items_index_dict(self):
        """item的全局唯一id对应当前file items里的下标"""
        return {v.text_index: i for i, v in enumerate(self.items)}

    def index_of(self, text_index):
        return self.items_index_dict[text_index]

    def _extra(self) -> dict[str, Any]:
        return self.extra



================================================
FILE: ModuleFolders/Cache/CacheItem.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/Cache/CacheManager.py
================================================
from collections import defaultdict
import os
import re
import threading
import time
from dataclasses import fields
from typing import Dict, List, Tuple

import msgspec
import rapidjson as json

from Base.Base import Base
from ModuleFolders.TaskConfig.TaskType import TaskType
from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.Cache.CacheProject import (
    CacheProject,
    CacheProjectStatistics
)


class CacheManager(Base):
    SAVE_INTERVAL = 8  # 缓存保存间隔（秒）

    def __init__(self) -> None:
        super().__init__()

        # 线程锁
        self.file_lock = threading.Lock()

        # 注册事件
        self.subscribe(Base.EVENT.TASK_START, self.start_interval_saving)
        self.subscribe(Base.EVENT.APP_SHUT_DOWN, self.app_shut_down)
        self.subscribe(Base.EVENT.TASK_MANUAL_SAVE_CACHE, self.on_manual_save_cache_requested)
        
    def start_interval_saving(self, event: int, data: dict):
                # 如果是继续任务，则在开始前保存并重载缓存
        if data.get("continue_status") is True:
            config = self.load_config()
            output_path = config.get("label_output_path", "./output")
            if output_path and os.path.isdir(output_path):
                # 强制保存当前内存中的缓存状态到磁盘，以包含编排表的修改
               if hasattr(self, "project"): #判断内容是否变化                
                self.save_to_file_require_path = output_path 
                self.save_to_file() 
                
                # 从磁盘重载缓存，确保后续任务基于最新的状态
                self.load_from_file(output_path)
        
        # 定时器
        self.save_to_file_stop_flag = False
        threading.Thread(target=self.save_to_file_tick, daemon=True).start()

    # 应用关闭事件
    def app_shut_down(self, event: int, data: dict) -> None:
        self.save_to_file_stop_flag = True

    # 手动保存缓存请求事件
    def on_manual_save_cache_requested(self, event: int, data: dict) -> None:
        """处理手动保存缓存的请求"""
        output_path = data.get("output_path")
        if output_path and hasattr(self, "project"):
            # 设置保存路径并立即执行保存
            self.save_to_file_require_path = output_path
            self.save_to_file()
            self.info("缓存文件已通过手动请求保存。")
        elif not hasattr(self, "project"):
             self.warning("手动保存缓存失败：项目数据尚未加载。")
        else:
            self.warning("手动保存缓存失败：未提供有效的 'output_path'。")

    # 保存缓存到文件
    def save_to_file(self) -> None:
        """保存缓存到文件，采用原子写入方式防止竞态条件
        缓存结构：
        {
            "project_id": "aaa",
            "project_type": "Type",
            "files": {
                "path/to/file1.txt": {
                    "storage_path": "...",
                    "file_name": "...",
                    "items": {
                        1: {"text_index": 1, "source_text": "...", ...},
                        2: {"text_index": 2, "source_text": "...", ...},
                    }
                },
                "path/to/file2.txt": { ... }
            }
        }
        """
        cache_dir = os.path.join(self.save_to_file_require_path, "cache")
        path = os.path.join(cache_dir, "AinieeCacheData.json")
        # 定义临时文件路径，确保在同一文件系统下以支持原子性替换
        tmp_path = path + f".{os.getpid()}.tmp"

        with self.file_lock:
            try:
                os.makedirs(cache_dir, exist_ok=True)
                content_bytes = msgspec.json.encode(self.project)

                # 先将完整内容写入临时文件
                with open(tmp_path, "wb") as writer:
                    writer.write(content_bytes)

                # 使用原子操作替换旧文件。这能保证其他进程/线程
                # 要么读到旧的完整文件，要么读到新的完整文件，绝不会读到一半。
                os.replace(tmp_path, path)

                # 写入项目整体翻译状态文件
                if self.project and self.project.stats_data:
                    total_line = self.project.stats_data.total_line # 获取需翻译总行数
                    line = self.project.stats_data.line # 获取已翻译行数
                    project_name = self.project.project_name # 获取项目名字
                    json_data = {"total_line": total_line, "line": line, "project_name": project_name}

                    json_path = os.path.join(cache_dir, "ProjectStatistics.json")
                    json_tmp_path = json_path + f".{os.getpid()}.tmp"
                    try:
                        with open(json_tmp_path, "w", encoding="utf-8") as writer:
                            json.dump(json_data, writer, ensure_ascii=False, indent=4)
                        os.replace(json_tmp_path, json_path)
                    finally:
                        if os.path.exists(json_tmp_path):
                            try:
                                os.remove(json_tmp_path)
                            except OSError:
                                pass
                else:
                    # 如果stats_data不存在，则调用 Base 类中的 warning 方法打印警告并跳过
                    self.warning(f"CacheManager: self.project.stats_data is None. Skipping ProjectStatistics.json update.")
            finally:
                # 确保临时文件在任何情况下（包括异常）都会被清理
                if os.path.exists(tmp_path):
                    os.remove(tmp_path)


    # 保存缓存到文件的定时任务
    def save_to_file_tick(self) -> None:
        """定时保存任务"""
        while not self.save_to_file_stop_flag:
            time.sleep(self.SAVE_INTERVAL)
            if getattr(self, "save_to_file_require_flag", False):
                self.save_to_file()
                self.save_to_file_require_flag = False

    # 请求保存缓存到文件
    def require_save_to_file(self, output_path: str) -> None:
        """请求保存缓存"""
        self.save_to_file_require_path = output_path
        self.save_to_file_require_flag = True

    # 从项目中加载
    def load_from_project(self, data: CacheProject):
        self.project = data

    # 从缓存文件读取数据
    def load_from_file(self, output_path: str) -> None:
        """从文件加载数据"""
        path = os.path.join(output_path, "cache", "AinieeCacheData.json")
        with self.file_lock:
            if os.path.isfile(path):
                self.project = self.read_from_file(path)

    @classmethod
    def read_from_file(cls, cache_path) -> CacheProject:
        with open(cache_path, "rb") as reader:
            content_bytes = reader.read()
        try:
            # 反序列化严格按照dataclass定义，如source_text这种非optional类型不能为None，否则反序列化失败
            return msgspec.json.decode(content_bytes, type=CacheProject)
        except msgspec.ValidationError:
            content = json.loads(content_bytes.decode('utf-8'))
            if isinstance(content, dict):
                return CacheProject.from_dict(content)
            else:
                return cls._read_from_old_content(content)

    @classmethod
    def _read_from_old_content(cls, content: list) -> CacheProject:
        # 兼容旧版缓存
        data_iter = iter(content)
        project_data = next(data_iter)
        init_data = {
            "project_id": project_data["project_id"],
            "project_type": project_data["project_type"],
        }
        CacheProject().detected_line_ending
        if "data" in project_data:
            init_data["stats_data"] = CacheProjectStatistics.from_dict(project_data["data"])
        if "file_encoding" in project_data:
            init_data["detected_encoding"] = project_data["file_encoding"]
        if "line_ending" in project_data:
            init_data["detected_line_ending"] = project_data["line_ending"]
        files_props = {}
        new_item_fields = set(fld.name for fld in fields(CacheItem))
        # 这两个属性之前是放item，现在放file
        file_extra_keys = set(["subtitle_title", "top_text"])
        file_prop_keys = set(["file_project_type"])
        for old_item in data_iter:
            storage_path = old_item["storage_path"]
            if storage_path not in files_props:
                files_props[storage_path] = {
                    "items": [],
                    "extra": {},
                    "file_project_type": project_data["project_type"],
                    'storage_path': storage_path,
                }
            new_item = CacheItem.from_dict(old_item)
            for k, v in old_item.items():
                if k == 'file_name':
                    continue
                if k not in new_item_fields:
                    if k in file_prop_keys:
                        files_props[storage_path][k] = v
                    elif k in file_extra_keys:
                        files_props[storage_path]["extra"][k] = v
                    else:
                        new_item.set_extra(k, v)
            files_props[storage_path]["items"].append(new_item)

        init_data["files"] = {
            k: CacheFile(**v)
            for k, v in files_props.items()
        }
        return CacheProject(**init_data)

    # 获取缓存内全部文本对数量
    def get_item_count(self) -> int:
        """获取总缓存项数量"""
        return self.project.count_items()

    # 获取某翻译状态的条目数量
    def get_item_count_by_status(self, status: int) -> int:
        return self.project.count_items(status)

    # 检测是否存在需要翻译的条目
    def get_continue_status(self) -> bool:
        """检查是否存在可继续翻译的状态"""
        has_translated = False
        has_untranslated = False
        for item in self.project.items_iter():
            status = item.translation_status
            if status == TranslationStatus.TRANSLATED:
                has_translated = True
            elif status == TranslationStatus.UNTRANSLATED:
                has_untranslated = True
            if has_translated and has_untranslated:
                return True
        return has_translated and has_untranslated

    # 生成上文数据条目片段
    def generate_previous_chunks(self, all_items: list[CacheItem], previous_item_count: int, start_idx: int) -> List[CacheItem]:

        # 如果没有条目，或者上文条目数小于等于0，或者起始索引小于等于0，则返回空列表
        if not all_items or previous_item_count <= 0 or start_idx <= 0:
            return []

        # 计算实际要获取的上文的起始索引 (包含)
        from_idx = max(0, start_idx - previous_item_count)

        # 计算实际要获取的上文的结束索引 (不包含)
        to_idx = min(start_idx, len(all_items)) # 通常就是 start_idx

        # 如果计算出的范围无效，返回空列表
        if from_idx >= to_idx:
            return []

        # 直接切片获取所需范围的条目，切片会自动处理边界情况，例如 from_idx=0
        collected = all_items[from_idx:to_idx]

        return collected

    # 生成待翻译片段
    def generate_item_chunks(self, limit_type: str, limit_count: int, previous_line_count: int, task_mode) -> \
            Tuple[List[List[CacheItem]], List[List[CacheItem]], List[str]]:
        chunks, previous_chunks, file_paths = [], [], []

        for file in self.project.files.values():
            # 1. 筛选出当前任务需要的条目
            if task_mode == TaskType.TRANSLATION:
                items = [item for item in file.items if item.translation_status == TranslationStatus.UNTRANSLATED]
            elif task_mode == TaskType.POLISH:
                items = [item for item in file.items if item.translation_status == TranslationStatus.TRANSLATED]
            else:
                items = []

            if not items:
                continue

            current_chunk, current_length = [], 0
            # 2. 记录当前 chunk 在 `items` 这个筛选后列表中的起始索引
            chunk_start_idx_in_filtered_list = 0

            # 3. 使用 enumerate 同时获取筛选后列表的索引 `i` 和条目 `item`
            for i, item in enumerate(items):
                item_length = item.get_token_count(item.source_text) if limit_type == "token" else 1

                # 当一个新 chunk 开始时，记录它的起始索引 `i`
                if not current_chunk:
                    chunk_start_idx_in_filtered_list = i

                # 如果当前 chunk 满了，提交它
                if current_chunk and (current_length + item_length > limit_count):
                    chunks.append(current_chunk)
                    # 4. 使用记录的、相对于 `items` 列表的正确索引来获取上文
                    previous_chunks.append(
                        self.generate_previous_chunks(items, previous_line_count, chunk_start_idx_in_filtered_list)
                    )
                    file_paths.append(file.storage_path)

                    # 重置，为下一个 chunk 做准备
                    current_chunk, current_length = [], 0
                    # 再次记录新 chunk 的起始索引
                    chunk_start_idx_in_filtered_list = i

                # 添加当前条目到 chunk
                current_chunk.append(item)
                current_length += item_length

            # 处理循环结束后剩余的最后一个 chunk
            if current_chunk:
                chunks.append(current_chunk)
                # 同样使用记录的正确索引
                previous_chunks.append(
                    self.generate_previous_chunks(items, previous_line_count, chunk_start_idx_in_filtered_list)
                )
                file_paths.append(file.storage_path)

        return chunks, previous_chunks, file_paths


    # 获取文件层级结构
    def get_file_hierarchy(self) -> Dict[str, List[str]]:
        """
        从缓存中读取文件列表，并按文件夹层级组织。
        """
        hierarchy = defaultdict(list)
        if not self.project or not self.project.files:
            return {}
            
        with self.file_lock:
            for file_path in self.project.files.keys():
                # os.path.split 将路径分割成 (目录, 文件名)
                directory, filename = os.path.split(file_path)
                # 如果文件在根目录，directory会是空字符串，用'.'代替
                if not directory:
                    directory = '.'
                hierarchy[directory].append(filename)

        # 对每个文件夹下的文件名进行排序
        for dir_path in hierarchy:
            hierarchy[dir_path].sort()
            
        return dict(hierarchy)

    # 更新缓存中的特定文本项
    def update_item_text(self, storage_path: str, text_index: int, field_name: str, new_text: str) -> None:
        """
        更新缓存中指定文件、指定索引的文本项的某个字段。
        """
        with self.file_lock:
            cache_file = self.project.get_file(storage_path)
            if not cache_file:
                print(f"Error: 找不到文件 {storage_path}")
                return
            
            item_to_update = cache_file.get_item(text_index)
            
            # 修改原文
            if field_name == 'source_text':
                if new_text and new_text.strip():
                    if item_to_update.source_text != new_text:
                        item_to_update.source_text = new_text

            # 修改译文
            elif field_name == 'translated_text':
                item_to_update.translated_text = new_text
                # 如果译文被清空，状态应重置为未翻译，同时清空润文
                if not new_text or not new_text.strip():
                    item_to_update.translation_status = TranslationStatus.UNTRANSLATED
                    item_to_update.polished_text = ""
                # 如果有译文内容，则标记为已翻译
                else:
                    item_to_update.translation_status = TranslationStatus.TRANSLATED

            # 修改润文
            elif field_name == 'polished_text':
                item_to_update.polished_text = new_text
                # 如果润文被清空，状态应回退到已翻译
                if not new_text or not new_text.strip():
                    item_to_update.translation_status = TranslationStatus.TRANSLATED
                # 如果有润文内容，则标记为已润色
                else:
                    item_to_update.translation_status = TranslationStatus.POLISHED

    # 缓存全搜索方法
    def search_items(self, query: str, scope: str, is_regex: bool, search_flagged: bool) -> list:
        """
        在整个项目中搜索条目。

        Args:
            query (str): 搜索查询字符串。
            scope (str): 搜索范围 ('all', 'source_text', 'translated_text', 'polished_text')。
            is_regex (bool): 是否使用正则表达式。
            search_flagged (bool): 是否仅搜索被标记的行。

        Returns:
            list: 包含元组 (file_path, original_row_num, CacheItem) 的结果列表。
        """
        results = []
        fields_to_check = []

        if scope == 'all':
            fields_to_check = ['source_text', 'translated_text', 'polished_text']
        else:
            fields_to_check = [scope]

        try:
            if is_regex:
                # 预编译正则表达式以提高效率
                regex = re.compile(query)
                matcher = lambda text: regex.search(text)
            else:
                matcher = lambda text: query in text
        except re.error as e:
            # 正则表达式无效，可以发出一个错误信号或直接返回空
            self.error(f"无效的正则表达式: {e}")
            # 这里可以向UI发送一个错误提示
            return []

        with self.file_lock:
            for file_path, cache_file in self.project.files.items():
                for item_index, item in enumerate(cache_file.items):
                    # 如果要求搜索标记行，则先进行标记过滤
                    if search_flagged:
                        is_item_flagged = False
                        if item.extra:
                            if scope == 'translated_text':
                                is_item_flagged = item.extra.get('language_mismatch_translation', False)
                            elif scope == 'polished_text':
                                is_item_flagged = item.extra.get('language_mismatch_polish', False)
                            elif scope == 'all':
                                is_item_flagged = (item.extra.get('language_mismatch_translation', False) or
                                                   item.extra.get('language_mismatch_polish', False))
                            # 对于 'source_text' 范围, is_item_flagged 保持 False, 自动跳过

                        if not is_item_flagged:
                            continue  # 如果不满足标记条件，则直接跳到下一个条目

                    # 通过标记过滤后，再执行文本/正则搜索
                    # 如果查询为空，则所有通过标记过滤的条目都匹配
                    if not query.strip():
                        # 仅在search_flagged为True时，空查询才有意义（即列出所有标记行）
                        if search_flagged:
                             results.append((file_path, item_index + 1, item))
                        continue # 否则，空查询不匹配任何内容                    
                    found = False
                    for field_name in fields_to_check:
                        text_to_check = getattr(item, field_name, None)
                        if text_to_check and matcher(text_to_check):
                            # (文件路径, 原始行号, 完整的CacheItem对象)
                            results.append((file_path, item_index + 1, item))
                            found = True
                            break  # 找到一个匹配就跳出字段循环，避免重复添加
                    if found:
                        continue
        return results

    # 获取全部的原文与文件路径
    def get_all_source_items(self) -> list:
        """
        获取项目中所有文件的所有原文文本项。
        Returns:
            list: 包含字典的列表，每个字典代表一个需要处理的条目。
                  格式: [{"source_text": str, "file_path": str}, ...]
        """
        all_items_data = []
        with self.file_lock:
            for file_path, cache_file in self.project.files.items():
                for item in cache_file.items:
                    # 只添加包含有效原文的条目
                    if item.source_text and item.source_text.strip():
                        all_items_data.append({
                            "source_text": item.source_text,
                            "file_path": file_path
                        })
        return all_items_data




================================================
FILE: ModuleFolders/Cache/CacheProject.py
================================================
import time
from dataclasses import dataclass, field
from functools import cached_property
from typing import Any

from ModuleFolders.Cache.BaseCache import ExtraMixin, ThreadSafeCache
from ModuleFolders.Cache.CacheFile import CacheFile


class ProjectType:
    AUTO_TYPE = "AutoType"
    DOCX = "Docx"
    EPUB = "Epub"
    LRC = "Lrc"
    MD = "Md"
    MTOOL = "Mtool"
    OFFICE_CONVERSION_PDF = "OfficeConversionPdf"
    OFFICE_CONVERSION_DOC = "OfficeConversionDoc"
    PARATRANZ = "Paratranz"
    RENPY = "Renpy"
    SRT = "Srt"
    ASS = "Ass"
    TPP = "Tpp"
    TRANS = "Trans"
    TXT = "Txt"
    VNT = "Vnt"
    VTT = "Vtt"
    I18NEXT = "I18next"
    PO = "Po"
    BABELDOC_PDF = "BabeldocPdf"


@dataclass(repr=False)
class CacheProjectStatistics(ThreadSafeCache):
    total_requests: int = 0
    error_requests: int = 0
    start_time: float = field(default_factory=time.time)
    total_line: int = 0
    line: int = 0
    token: int = 0
    total_completion_tokens: int = 0
    time: float = 0.0


@dataclass(repr=False)
class CacheProject(ThreadSafeCache, ExtraMixin):
    project_id: str = ''
    project_type: str = ''
    project_name: str = ''
    stats_data: CacheProjectStatistics = None
    files: dict[str, CacheFile] = field(default_factory=dict)
    detected_encoding: str = "utf-8"
    detected_line_ending: str = "\n"
    extra: dict[str, Any] = field(default_factory=dict)

    # 添加文件
    def add_file(self, file: CacheFile) -> None:
        """线程安全添加文件"""
        with self._lock:
            if hasattr(self, "file_project_types"):
                del self.file_project_types  # 清除缓存
            self.files[file.storage_path] = file

    # 根据相对路径获取文件
    def get_file(self, storage_path: str) -> CacheFile:
        """线程安全获取文件"""
        with self._lock:
            return self.files.get(storage_path)

    def items_iter(self, project_types: str | frozenset[str] = None):
        if isinstance(project_types, str):
            project_types = frozenset([project_types])
        with self._lock:
            for file in self.files.values():
                if project_types is None or file.file_project_type in project_types:
                    for item in file.items:
                        yield item

    def count_items(self, status=None):
        with self._lock:
            if status is None:
                return sum(len(file.items) for file in self.files.values())
            else:
                return sum(
                    1 for item in self.items_iter() if item.translation_status == status
                )

    @cached_property
    def file_project_types(self) -> frozenset[str]:
        with self._lock:
            return frozenset(file.file_project_type for file in self.files.values())

    def _extra(self) -> dict[str, Any]:
        return self.extra



================================================
FILE: ModuleFolders/FileAccessor/README.md
================================================

# 读写器 (Reader / Writer) 系统编写指南

欢迎来到读写器系统编写指南！本文档将帮助您了解如何为项目编写读写器

## 目录

- [读写器 (Reader / Writer) 系统编写指南](#读写器-reader--writer-系统编写指南)
  - [目录](#目录)
  - [读写器编写步骤](#读写器编写步骤)
  - [Reader介绍](#reader介绍)
    - [Reader基类](#reader基类)
    - [Reader生命周期](#reader生命周期)
    - [Reader示例代码](#reader示例代码)
  - [Writer介绍](#writer介绍)
    - [Writer基类](#writer基类)
    - [Writer生命周期](#writer生命周期)
    - [Writer示例代码](#writer示例代码)
  - [缓存介绍](#缓存介绍)
  - [Accessor介绍（可选）](#accessor介绍可选)
  - [FileConverter介绍（可选）](#fileconverter介绍可选)
  - [插件式读写器解释（可选）](#插件式读写器解释可选)
  - [贡献指南](#贡献指南)

## 读写器编写步骤

1. **环境准备**
   确保您的开发环境满足以下要求：
   - Python 3.12
   - 相关依赖库（请查看 `requirements.txt` 和 `requirements_no_deps.txt`）
2. **读写器文件**
   在项目的 `ModuleFolders/FileReader` 和 `ModuleFolders/FileOutputer` 目录下创建新的 `.py` 文件， 例如 `XXXReader.py, XXXWriter.py` 。
3. **编写读写器代码** 按照以下模板编写您的读写器代码，并确保继承自对应的基类。
4. **复杂文件访问（可选）** 部分文件的读写逻辑比较复杂，可以把文件本身的读写逻辑抽取出来，参考 `DocxAccessor` 。
5. **复杂文件转换（可选）** 部分文件可能无法直接翻译，可以把转换成中间格式做翻译，再转换回来，参考 `OfficeFileConverter` 。

## Reader介绍

### Reader基类

在编写Reader时，您需要创建一个继承自 `BaseSourceReader` 的新类，并实现 `get_project_type`、`support_file`和`on_read_source` 方法。

以下是 `BaseSourceReader` 类的简化定义：

```python
class BaseSourceReader(ABC):
    """Reader基类，在其生命周期内可以输入多个文件"""
    def __init__(self, input_config: InputConfig) -> None:
        self.input_config = input_config

    def __enter__(self):
        """申请整个Reader生命周期用到的耗时资源，单个文件的资源则在read_source_file方法中申请释放"""
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        """释放耗时资源"""
        pass

    @classmethod
    @abstractmethod
    def get_project_type(cls) -> str:
        """获取Reader对应的项目类型标识符（用于动态实例化），如 Mtool"""
        pass

    @property
    @abstractmethod
    def support_file(self) -> str:
        """该读取器支持处理的文件扩展名（不带点），如 json"""
        pass

    def read_source_file(self, file_path: Path) -> CacheFile:
        """读取文件内容，并返回原文(译文)片段"""
        # 模板方法
        pre_read_metadata = self.pre_read_source(file_path)
        file_data = self.on_read_source(file_path, pre_read_metadata)
        file_data.encoding = pre_read_metadata.encoding
        return self.post_read_source(file_data)

    def pre_read_source(self, file_path: Path) -> PreReadMetadata:
        """读取文件之前的操作，可以是检测文件编码"""
        # 猜测的文件编码
        detected_encoding = detect_file_encoding(file_path)
        use_encoding = detected_encoding if not detected_encoding.startswith("non_text") else "utf-8"
        return PreReadMetadata(encoding=use_encoding)

    @abstractmethod
    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        """接收pre_read_source的结果，读取文件内容，并返回原文(译文)片段"""
        pass

    def post_read_source(self, file_data: CacheFile) -> CacheFile:
        """对原文(译文)片段做统一处理"""
        return file_data

    def can_read(self, file_path: Path, fast=True) -> bool:
        """验证文件兼容性，返回False则不会读取该文件"""
        if fast:
            return self.can_read_by_extension(file_path)
        try:
            return self.can_read_by_content(file_path)
        except Exception:
            return False

    @classmethod
    def is_environ_supported(cls) -> bool:
        """用于判断当前环境是否支持该reader"""
        return True

    def can_read_by_extension(self, file_path: Path):
        """根据文件后缀判断是否可读"""
        return file_path.suffix.replace('.', '', 1) == self.support_file

    def can_read_by_content(self, file_path: Path) -> bool:
        """根据文件内容判断是否可读"""
        # 默认实现用后缀判断
        return self.can_read_by_extension(file_path)

    def get_file_project_type(self, file_path: Path) -> str:
        """根据文件判断项目类型，无法判断时返回None"""
        return self.get_project_type()

    @property
    def exclude_rules(self) -> list[str]:
        """用于排除缓存文件/目录"""
        return []
```

### Reader生命周期

1. **Reader注册**
   - 所有的Reader都通过 `FileReader` 的 `register_reader` 方法注册
   - 为保证通用性，注册的内容为 Reader工厂，可以简单理解为一个创建 Reader 的函数

2. **Reader实例化**

   - `FileReader` 结合用户选择的 项目设置 -> 项目类型 和 `get_project_type` 中声明的项目类型，实例化对应的Reader
   - 每个Reader都被包装在 `DirectoryReader` 中，在读取目录前执行 `__enter__` 申请耗时资源
   - `DirectoryReader` 会把目录下的文件**一个一个**的传给Reader

3. **文件读取**

    Reader接收的文件满足 `can_read` 则执行 `on_read_source` 方法

4. **Reader销毁**

    当 `DirectoryReader` 读取完目录后，Reader 销毁，执行 `__exit__` 释放资源

### Reader示例代码

以下是 `TxtReader` 的示例

1. 用户界面的 Txt小说文件 对应 `get_project_type` 里声明的 `Txt`
2. 该Reader只支持 `support_file` 中声明的 `txt` 类型文件类型
3. 在 `on_read_source` 读取源文件，把源文档会被分拆成多个片段，并返回原文片段列表 `list[CacheItem]`
4. `CacheItem` 中只定义了通用的属性，若实在有需要可直接给 `CacheItem` 赋值，如 `item.sentence_indent = spaces`
5. 为保持可读性和可维护性，一些复杂的计算逻辑可提取成函数如 `_count_next_empty_line`
6. 使用了从 `DirectoryReader` 传入的 `detected_encoding` 参数，适用于大部分情况下的**纯文本**可靠解码

```python
class TxtReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig, max_empty_line_check=None):
        super().__init__(input_config)
        self.max_empty_line_check = max_empty_line_check

    @classmethod
    def get_project_type(cls):
        return ProjectType.TXT

    @property
    def support_file(self):
        return "txt"

    # 读取单个txt的文本及其他信息
    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        items = []
        # 切行
        # 使用传入的 `detected_encoding` 参数正确读取未知编码的纯文本文件，并使用`splitlines()`正确切分行
        lines = file_path.read_text(encoding=pre_read_metadata.encoding).splitlines()

        for i, line in enumerate(lines):
            # 如果当前行是空行
            # 并且位置不是文本开头，则跳过当前行
            if not line.strip() and i != 0:
                continue

            # 去掉文本开头的空格
            line_lstrip = line.lstrip()
            # 获取文本行开头的原始空格
            spaces = line[:len(line) - len(line_lstrip)]
            extra = {
                "sentence_indent": spaces,
                # 原始空格保存至变量中，后续Writer中还原
                "line_break": self._count_next_empty_line(lines, i)
            }
            item = CacheItem(source_text=line_lstrip, extra=extra)

            items.append(item)
        return CacheFile(items=items)

    def _count_next_empty_line(self, lines, line_index):
        """检查后续行是否连续空行，最多检查 max_empty_line_check 行"""
        max_empty_line_check = self.max_empty_line_check if self.max_empty_line_check is not None else len(lines)
        empty_line_index = line_index
        for empty_line_index in range(line_index + 1, min(len(lines), line_index + 1 + max_empty_line_check)):
            if lines[empty_line_index].strip() != '':
                empty_line_index -= 1
                break
        return empty_line_index - line_index
```

## Writer介绍

### Writer基类

Writer可能有多份输出，比如既要输出译文文件又要输出双语文件

1. 所有Writer必须间接继承自 `BaseTranslationWriter` 类且实现 `get_project_type` 方法
2. 如果只做译文输出则继承 `BaseTranslatedWriter` 类且实现 `write_translated_file` 方法
3. 如果要同时做译文输出和双语输出，则要同时继承 `BaseTranslatedWriter` 和 `BaseBilingualWriter` 类且实现对应的方法

以下是这些类的简化定义

```python
class BaseTranslationWriter(ABC):
    """Writer基类，在其生命周期内可以输出多个文件"""
    def __init__(self, output_config: OutputConfig) -> None:
        self.output_config = output_config

        # 提取译文输出的编码和换行符配置
        self.translated_encoding = output_config.translated_config.file_encoding or "utf-8"
        self.translated_line_ending = output_config.translated_config.line_ending or os.linesep

    class TranslationMode(Enum):
        TRANSLATED = ('translated_config', 'write_translated_file')
        BILINGUAL = ('bilingual_config', 'write_bilingual_file')

        def __init__(self, config_attr, write_method) -> None:
            self.config_attr = config_attr
            self.write_method = write_method

    def can_write(self, mode: TranslationMode) -> bool:
        """判断writer是否支持该输出方式"""
        if mode == self.TranslationMode.TRANSLATED:
            return isinstance(self, BaseTranslatedWriter) and self.output_config.translated_config.enabled
        elif mode == self.TranslationMode.BILINGUAL:
            return isinstance(self, BaseBilingualWriter) and self.output_config.bilingual_config.enabled
        return False

    def __enter__(self):
        """申请整个Writer生命周期用到的耗时资源，单个文件的资源则在write_xxx_file方法中申请释放"""
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        """释放耗时资源"""
        pass

    @classmethod
    @abstractmethod
    def get_project_type(self) -> str:
        """获取Writer对应的项目类型标识符（用于动态实例化），如 Mtool"""
        pass

    @classmethod
    def is_environ_supported(cls) -> bool:
        """用于判断当前环境是否支持该writer"""
        return True


class BaseTranslatedWriter(BaseTranslationWriter):
    """译文输出基类"""

    def write_translated_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        """输出译文文件"""
        pre_write_metadata = self.pre_write_translated(cache_file)
        self.on_write_translated(translation_file_path, cache_file, pre_write_metadata, source_file_path)
        self.post_write_translated(translation_file_path)

    def pre_write_translated(self, cache_file: CacheFile) -> PreWriteMetadata:
        """根据文件内容做输出前操作，如输出编码检测"""
        return PreWriteMetadata()

    @abstractmethod
    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        """执行实际的文件写入操作"""
        pass

    def post_write_translated(self, translation_file_path: Path):
        """输出后操作，如验证"""
        pass


class BaseBilingualWriter(BaseTranslationWriter):
    """双语输出基类"""

    def write_bilingual_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        """输出双语文件"""
        pre_write_metadata = self.pre_write_bilingual(cache_file)
        self.on_write_bilingual(translation_file_path, cache_file, pre_write_metadata, source_file_path)
        self.post_write_bilingual(translation_file_path)

    def pre_write_bilingual(self, cache_file: CacheFile) -> PreWriteMetadata:
        """根据文件内容做输出前操作，如输出编码检测"""
        return PreWriteMetadata()

    @abstractmethod
    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        """执行实际的文件写入操作"""
        pass

    def post_write_bilingual(self, translation_file_path: Path):
        """输出后操作，如验证"""
        pass
```

### Writer生命周期

1. **Writer注册**
   - 所有的Writer都在 `FileOutputer` 实例化的时候通过 `register_writer` 方法注册
   - 为保证通用性，注册的内容为 Writer工厂，可以简单理解为一个创建 Writer 的函数

2. **Writer实例化**

   - `FileOutputer` 结合用户选择的 项目设置 -> 项目类型 和 `get_project_type` 中声明的项目类型，实例化对应的Writer
   - 每个Writer都被包装在 `DirectoryWriter` 中，在写入目录前执行 `__enter__` 申请耗时资源
   - `DirectoryWriter` 会把目录下的文件**一个一个**的传给Writer

3. **文件输出**

    1. 当Writer的 `output_config` 中 `enable` 了对应的输出方式
    2. 正确的继承了对应的输出基类
    3. 则执行具体的 `on_write_xxx` 方法，如译文输出就是 `on_write_translated`
    4. 部分文档需要保留原文的复杂样式，此时可使用方法参数中的 `source_file_path` 读取到源文档，再结合译文做文档重构，参考 `RenpyWriter`

4. **Writer销毁**

    当 `DirectoryWriter` 读取完目录后，Writer 销毁，执行 `__exit__` 释放资源

### Writer示例代码

以下是 `TxtWriter` 的配置

1. `TxtWriter` 要同时支持译文输出和双语输出，所以 `bilingual_config.enable` 也是 `True`
2. `name_suffix` 代表输出文件的后缀，如果后缀是 `_translated`，那么 `aaa.txt` 的译文文件名是 `aaa_translated.txt`
3. `output_root` 代表输出的根目录，也就是用户界面 项目配置 -> 输出文件夹，此处译文文件直接在 输出文件夹 下输出，而双语文件在 输出文件夹的子文件夹`bilingual_txt` 下输出
4. `file_encoding` 代表从之前 `DirectoryReader` 中保存至 `CacheProject` 中的 `file_encoding`（**多数文件**的原始文件编码），<br/>以及从译后的所有文本中判断（`DirectoryWriter`）获取的兼容编码
5. **此参数暂时被遗弃**~~`line_ending` 代表从之前Reader中保存至 `CacheProject` 中的 `line_ending`（原始行尾序列）~~

```python
OutputConfig(
    translated_config=TranslationOutputConfig(
        enabled=True, name_suffix="_translated", output_root=output_path, 
        file_encoding=file_encoding, line_ending=line_ending
    ),
    bilingual_config=TranslationOutputConfig(
        enabled=True, name_suffix="_bilingual", output_root=output_path / "bilingual_txt", 
        file_encoding=file_encoding, line_ending=line_ending
    ),
)
```

以下是 `TxtWriter` 的示例

1. 用户界面的 Txt小说文件 对应 `get_project_type` 里声明的 `Txt`
2. 该Writer要支持译文输出和双语输出，于是继承了 `BaseBilingualWriter` 和 `BaseTranslatedWriter`
3. 在 `write_bilingual_file` 方法中输出双语文件，在 `write_translated_file` 方法中输出译文文件
4. 译文和双语的区别在于怎么替换原文片段，建议抽出公共方法如 `_write_translation_file`，把替换原文片段的逻辑作为参数传入
5. 此处用到了 `CacheItem` 中未定义的属性 `item.sentence_indent` ，如果不保证属性存在请使用 `getattr`
6. 保存文件时用到的 `encoding=self.translated_encoding`，是从项目（`DirectoryReader`），以及译后的所有文本中（`DirectoryWriter`）综合判断所获取到的兼容编码

```python
class TxtWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(translation_file_path, cache_file, pre_write_metadata, self._item_to_bilingual_line)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(translation_file_path, cache_file, pre_write_metadata, self._item_to_translated_line)

    def _write_translation_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        item_to_line: Callable[[CacheItem], str],
    ):
        if not cache_file.items:
            translation_file_path.touch()
            return

        # 处理所有项目
        lines = list(map(item_to_line, cache_file.items))

        translation_file_path.write_text("".join(lines), encoding=self.translated_encoding)

    def _item_to_bilingual_line(self, item: CacheItem):
        # 至少2个换行，让双语排版不那么紧凑
        line_break = "\n" * max(item.require_extra("line_break") + 1, 2)
        indent = item.require_extra("sentence_indent")

        return (
            f"{indent}{item.source_text.lstrip()}\n"
            f"{indent}{item.translated_text.lstrip()}{line_break}"
        )

    def _item_to_translated_line(self, item: CacheItem):
        line_break = "\n" * (item.require_extra("line_break") + 1)

        return f"{item.require_extra("sentence_indent")}{item.translated_text.lstrip()}{line_break}"

    @classmethod
    def get_project_type(self):
        return ProjectType.TXT
```

## 缓存介绍

当前有三个层级的缓存对象 `CacheProject` `CacheFile` `CacheItem`，其分别对应 项目(目录)、文件、条目

1. `CacheProject` 用于存储项目相关的信息，如项目类型、项目统计信息等。
2. `CacheFile` 用于存储文件相关的信息，如文件相对路径，文件编码等。
3. `CacheItem` 用于存储条目相关的信息，如原文，模型等。
4. 如果要新增公共属性（也就是每个reader/writer都会用到的属性），请加到对应的类中。比如要增加文件的公共属性，则在 `CacheFile` 类中添加。
5. **三个类都不允许额外的属性**，如果有额外属性请放到 `extra` 中。比如 txt 的条目需要换行数，则把属性 `line_break` 放到 `CacheItem` 的 `extra` 中

## Accessor介绍（可选）

1. Accessor主要是把复杂的文件读写逻辑从 Reader/Writer 中剥离，通过 `content` 与 Reader/Writer 交互
2. Reader/Writer 只用关心如何读取/修改 `content`，而具体怎么从文件中读取 `content` 还是把 `content` 写入到文件则由Accessor负责
3. 参考`DocxReader` 和 `DocxWriter` 读取和写入都用到了 `DocxAccessor` 的 `read_content` 方法

## FileConverter介绍（可选）

1. Converter主要是把难以直接读写的文件格式转换成易读写中间格式。
2. 参考 `OfficeConversionReader` 和 `OfficeConversionWriter` 通过 `OfficeFileConverter` 把 pdf 文件转换成 docx 文件实现翻译。

## 插件式读写器解释（可选）

插件式读写器主要用于处理一些冷门的文件类型，也支持在打包后的程序中增加新的实现。

1. 文件存放路径：
   - 插件文件统一存放在 PluginScripts/IOPlugins 目录下
   - 新增的插件读写器也需放置于此目录
   - 注意：该目录下的文件不纳入代码版本管理（详见 .gitignore 文件）
2. 实现要求：

   - 自定义读取器：需继承 CustomReader 类
   - 自定义输出器：需继承 CustomWriter 类，并选择继承以下基类：
      - BaseTranslationWriter
      - BaseTranslatedWriter

## 贡献指南

1. Fork本项目
2. 创建您的特性分支 (`git checkout -b my-new-feature`)
3. 提交您的改动 (`git commit -am 'Add some feature'`)
4. 将您的分支推送到 GitHub (`git push origin my-new-feature`)
5. 创建新的Pull Request



================================================
FILE: ModuleFolders/FileAccessor/BabeldocPdfAccessor.py
================================================
import logging
from concurrent.futures import Executor, Future
from concurrent.futures.thread import _WorkItem
from pathlib import Path

from babeldoc import progress_monitor
from babeldoc.babeldoc_exception.BabelDOCException import ExtractTextError
from babeldoc.docvision.doclayout import DocLayoutModel
from babeldoc.docvision.table_detection.rapidocr import RapidOCRModel
from babeldoc.format.pdf.document_il.midend import il_translator
from babeldoc.format.pdf.high_level import TRANSLATE_STAGES, do_translate
from babeldoc.format.pdf.translation_config import (
    TranslateResult,
    TranslationConfig,
    WatermarkOutputMode
)
from babeldoc.main import create_parser
from babeldoc.progress_monitor import ProgressMonitor
from babeldoc.translator.translator import BaseTranslator
from rich.progress import (
    BarColumn,
    MofNCompleteColumn,
    Progress,
    TextColumn,
    TimeElapsedColumn,
    TimeRemainingColumn
)

from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.FileOutputer.BaseWriter import OutputConfig


class FinishReading(Exception):
    @classmethod
    def raise_after_call(cls, func):
        def warpper(*args, **kwargs):
            func(*args, **kwargs)
            raise FinishReading
        return warpper


class IgnoreStyleNoneFilter(logging.Filter):
    def filter(self, record):
        return record.getMessage().startswith("Style is None")


class IgnoreFinishReadingException(logging.Filter):
    def filter(self, record):
        if record.exc_info:
            exc_type = record.exc_info[0]
            return exc_type and issubclass(exc_type, FinishReading)
        return False


# 屏蔽告警
logging.getLogger("babeldoc.format.pdf.document_il.midend.typesetting").addFilter(IgnoreStyleNoneFilter())
logging.getLogger("babeldoc.format.pdf.high_level").addFilter(IgnoreFinishReadingException())


class PdfSourceVisitor(BaseTranslator):
    def __init__(self):
        super().__init__('', '', True)
        # do_translate本身是多线程操作，但是更换为单线程的线程池后没有线程安全问题
        self.source_texts: list[str] = []

    def translate(self, text, *args, **kwargs):
        return self.do_translate(text)

    def do_translate(self, text, rate_limit_params: dict = None):
        self.source_texts.append(text)
        return text

    def do_llm_translate(self, text, rate_limit_params: dict = None):
        raise NotImplementedError


class TranslatedItemsTranslator(BaseTranslator):
    def __init__(self, items: list[CacheItem]):
        super().__init__('', '', True)
        self.source_texts = set(x.source_text for x in items)
        self.translated_iter = ((x.source_text, x.final_text) for x in items)

    def translate(self, text, *args, **kwargs):
        return self.do_translate(text)

    def do_translate(self, text, rate_limit_params: dict = None):
        if text in self.source_texts:
            for source_text, translated_text in self.translated_iter:
                if text == source_text:
                    return translated_text
        return text

    def do_llm_translate(self, text, rate_limit_params: dict = None):
        raise NotImplementedError


class MainThreadExecutor(Executor):
    def __init__(self, *args, **kwargs) -> None:
        pass

    def submit(self, fn, /, *args, **kwargs):
        if "priority" in kwargs:
            del kwargs["priority"]
        f = Future()
        _WorkItem(f, fn, args, kwargs).run()
        return f

    def shutdown(self, wait: bool = True, *, cancel_futures: bool = False) -> None:
        pass


class TranslationStage:
    __init__ = progress_monitor.TranslationStage.__init__

    def __enter__(self):
        # 在read_content 和 write_content 中对pm附加的属性 pm.pbar_manager = Progress()
        self.pbar = self.pm.pbar_manager.add_task(self.name, total=self.total)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if hasattr(self, "pbar"):
            with self.lock:
                diff = self.total - self.current
                self.pm.pbar_manager.update(self.pbar, advance=diff)

    def advance(self, n: int = 1):
        if hasattr(self, "pbar"):
            with self.lock:
                self.current += n
                self.pm.pbar_manager.update(self.pbar, advance=n)

    @classmethod
    def create_progress(cls):
        return Progress(
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            MofNCompleteColumn(),
            TimeElapsedColumn(),
            TimeRemainingColumn(),
        )


class BabeldocPdfAccessor:
    def __init__(self, tmp_directory: Path, output_config: OutputConfig | None) -> None:
        self.tmp_directory = tmp_directory
        self.output_config = output_config
        self._result_cache: dict[(Path, int), TranslateResult] = {}
        self._init_babeldoc_args()

    def _init_babeldoc_args(self):
        parser = create_parser()
        cmd_args = [
            "--no-watermark", "--ignore-cache", "--skip-scanned-detection",
            "--working-dir", str(self.tmp_directory / "babeldoc_working"),
            "--output", str(self.tmp_directory),
        ]
        if self.output_config:
            if not self.output_config.translated_config.enabled:
                cmd_args.append("--no-mono")
            if not self.output_config.bilingual_config.enabled:
                cmd_args.append("--no-dual")
        self.babeldoc_args = parser.parse_args(cmd_args)
        return self

    _OldExecutor = il_translator.PriorityThreadPoolExecutor
    _OldTranslationStage = progress_monitor.TranslationStage

    def read_content(self, source_file_path: Path):
        visitor = PdfSourceVisitor()
        babeldoc_translation_config = self._create_babeldoc_translation_config(
            self.babeldoc_args, str(source_file_path), visitor
        )

        old_il_translate = il_translator.ILTranslator.translate
        old_il_stage_name = il_translator.ILTranslator.stage_name
        new_il_stage_name = "Read Paragraphs"

        try:
            progress_monitor.TranslationStage = TranslationStage
            il_translator.ILTranslator.stage_name = new_il_stage_name
            il_translator.PriorityThreadPoolExecutor = MainThreadExecutor

            # 提取完原文就可以终止了，不需要后面的写入
            new_il_translate = FinishReading.raise_after_call(old_il_translate)
            il_translator.ILTranslator.translate = new_il_translate

            new_stages = [
                (new_il_stage_name, *stage[1:]) if stage[0] == old_il_stage_name else stage
                for stage in TRANSLATE_STAGES
            ]
            with ProgressMonitor(new_stages) as pm, TranslationStage.create_progress() as pbar_manager:
                pm.pbar_manager = pbar_manager
                do_translate(pm, babeldoc_translation_config)
        except ExtractTextError:
            print(f"`{source_file_path!s}` 不包含可复制的文本，可能是扫描件，不处理")
        except FinishReading:
            pass
        finally:
            il_translator.ILTranslator.translate = old_il_translate
            il_translator.PriorityThreadPoolExecutor = self._OldExecutor
            il_translator.ILTranslator.stage_name = old_il_stage_name
            progress_monitor.TranslationStage = self._OldTranslationStage
        return visitor.source_texts

    def write_content(self, source_file_path: Path, items: list[CacheItem]):
        # Babeldoc会同时输出译文和双语文件，为了性能考虑不修改config写两次，而选择一次性输出译文和双语文件，同时缓存输出文件路径
        # lru_cache不接受list，这里手写，简单认为items数组的id代表数组
        cache_id = (source_file_path, id(items))
        result = self._result_cache.get(cache_id)
        if result is not None:
            return result

        translator = TranslatedItemsTranslator(items)
        babeldoc_translation_config = self._create_babeldoc_translation_config(
            self.babeldoc_args, str(source_file_path), translator
        )
        try:
            progress_monitor.TranslationStage = TranslationStage
            il_translator.PriorityThreadPoolExecutor = MainThreadExecutor

            with ProgressMonitor(TRANSLATE_STAGES) as pm, TranslationStage.create_progress() as pbar_manager:
                pm.pbar_manager = pbar_manager
                result = do_translate(pm, babeldoc_translation_config)
        except ExtractTextError:
            print(f"`{source_file_path!s}` 不包含可复制的文本，可能是扫描件，不处理")
        finally:
            il_translator.PriorityThreadPoolExecutor = self._OldExecutor
            progress_monitor.TranslationStage = self._OldTranslationStage

        self._result_cache.clear()
        self._result_cache[cache_id] = result
        return result

    @classmethod
    def _create_babeldoc_translation_config(cls, args, file, translator):
        table_model = RapidOCRModel() if args.translate_table_text else None
        return TranslationConfig(
            input_file=file,
            font=None,
            pages=args.pages,
            output_dir=args.output,
            translator=translator,
            debug=args.debug,
            lang_in=args.lang_in,
            lang_out=args.lang_out,
            no_dual=args.no_dual,
            no_mono=args.no_mono,
            qps=args.qps,
            formular_font_pattern=args.formular_font_pattern,
            formular_char_pattern=args.formular_char_pattern,
            split_short_lines=args.split_short_lines,
            short_line_split_factor=args.short_line_split_factor,
            doc_layout_model=DocLayoutModel.load_onnx(),
            skip_clean=args.skip_clean,
            dual_translate_first=args.dual_translate_first,
            disable_rich_text_translate=args.disable_rich_text_translate,
            enhance_compatibility=args.enhance_compatibility,
            use_alternating_pages_dual=args.use_alternating_pages_dual,
            report_interval=args.report_interval,
            min_text_length=args.min_text_length,
            watermark_output_mode=WatermarkOutputMode.NoWatermark,
            split_strategy=None,  # 源码中对应args.max_pages_per_part，这里不要
            table_model=table_model,
            show_char_box=args.show_char_box,
            skip_scanned_detection=args.skip_scanned_detection,
            ocr_workaround=args.ocr_workaround,
            custom_system_prompt=None,
        )



================================================
FILE: ModuleFolders/FileAccessor/DocxAccessor.py
================================================
import zipfile
from pathlib import Path

from bs4 import BeautifulSoup, NavigableString, PageElement, Tag

from ModuleFolders.FileAccessor import ZipUtil


class DocxAccessor:

    def read_content(self, source_file_path: Path):
        with zipfile.ZipFile(source_file_path) as zipf:
            content = zipf.read("word/document.xml").decode("utf-8")
        # 读取xml内容
        xml_soup = BeautifulSoup(content, 'xml')

        # 遍历每个段落并合并相邻且格式相同的 run
        for paragraph in xml_soup.find_all('w:p', recursive=True):
            self._merge_adjacent_same_style_run(paragraph)
        return xml_soup

    def write_content(
        self, content: BeautifulSoup, write_file_path: Path,
        source_file_path: Path,
    ):
        ZipUtil.replace_in_zip_file(
            source_file_path, write_file_path, {"word/document.xml": str(content)}
        )

    def _get_style(self, run: Tag):
        rpr = run.find("w:rPr")
        if not rpr:
            return {}
        return {
            tag.name: tag.attrs for tag in rpr.find_all(recursive=False)
        }

    def _is_tag_of(self, ele: PageElement, tag_name: str):
        return isinstance(ele, Tag) and ele.name == tag_name

    def _is_empty_string(self, ele: PageElement):
        return isinstance(ele, NavigableString) and ele.strip() == ""

    def _merge_adjacent_same_style_run(self, paragraph: Tag):

        # 排除掉语法检测和空字符串
        child_nodes = [
            ele for ele in paragraph.children
            if not self._is_tag_of(ele, "proofErr") and not self._is_empty_string(ele)
        ]
        new_children = []
        i = 0
        n = len(child_nodes)

        while i < n:
            current = child_nodes[i]

            # 如果不是run节点，直接保留
            if not self._is_tag_of(current, "r"):
                new_children.append(current)
                i += 1
                continue
            # 如果是 run 节点，但是没有文本内容也直接保留
            elif not (current_text := current.find("w:t")) or current_text.string is None:
                new_children.append(current)
                i += 1
                continue

            # 如果是run节点，尝试合并后续相同格式的run
            merged_run = current
            j = i + 1
            while j < n:
                next_node = child_nodes[j]

                # 遇到其他类型节点，停止合并
                if not self._is_tag_of(current, "r"):
                    break

                # 格式相同则合并文本内容
                if self._get_style(merged_run) == self._get_style(next_node):
                    current_t = merged_run.find("w:t")
                    next_t = next_node.find("w:t")
                    if next_t:
                        if next_t.get("xml:space") == "preserve":
                            current_t["xml:space"] = "preserve"
                        current_t.string += next_t.get_text()
                    j += 1
                else:
                    break
            new_children.append(merged_run)
            i = j  # 跳过已处理的节点

        # 用重构后的子节点列表替换原始内容
        paragraph.clear()
        for node in new_children:
            paragraph.append(node)



================================================
FILE: ModuleFolders/FileAccessor/EpubAccessor.py
================================================
import posixpath
import zipfile
from pathlib import Path

from bs4 import BeautifulSoup

from ModuleFolders.FileAccessor import ZipUtil


class EpubAccessor:

    def read_content(self, source_file_path: Path):
        with zipfile.ZipFile(source_file_path, 'r') as zipf:
            meta_content = zipf.read("META-INF/container.xml")
            meta_soup = BeautifulSoup(meta_content, "xml")
            opf_file = None

            for root_file in meta_soup.select('container rootfiles rootfile'):
                if root_file.get("media-type") == "application/oebps-package+xml":
                    opf_file = root_file.get("full-path")
            if opf_file is None:
                return []
            items = []
            opf_soup = BeautifulSoup(zipf.read(opf_file), "xml")
            files = {x.filename: x for x in zipf.infolist()}
            for item in opf_soup.select("manifest item"):
                # 检查是否是文本内容，且文件存在压缩包内
                filename = posixpath.join(posixpath.dirname(opf_file), item["href"])
                if item.get("media-type") == "application/xhtml+xml" and filename in files:
                    content = zipf.read(files[filename]).decode("utf-8")
                    items.append((item["id"], filename, content))
            return items

    def write_content(
        self, content: dict[str, str], write_file_path: Path,
        source_file_path: Path,
    ):
        ZipUtil.replace_in_zip_file(source_file_path, write_file_path, content)



================================================
FILE: ModuleFolders/FileAccessor/ZipUtil.py
================================================
import zipfile
from pathlib import Path


def decompress_zip_to_path(zip_file_path: Path, decompress_path: Path):
    decompress_path.mkdir(exist_ok=True)
    # 解压docx文件到暂存文件夹中
    with zipfile.ZipFile(zip_file_path, 'r') as zipf:
        # 提取所有文件
        zipf.extractall(decompress_path)


def compress_to_zip_file(compress_path: Path, zip_file_path: Path):
    if compress_path.is_dir():
        with zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            # 遍历文件夹中的所有文件和子文件夹
            for root, _, files in compress_path.walk():
                for file in files:
                    file_path = root / file
                    # 获取文件在压缩文件中的相对路径
                    relative_file_path = file_path.relative_to(compress_path)
                    # 将文件添加到压缩文件中
                    zipf.write(file_path, relative_file_path)
    else:
        with zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
            zipf.write(compress_path)


def replace_in_zip_file(
    src_zip_file_path: Path, dst_zip_file_path: Path,
    content: dict[str, str],
):
    with (
        zipfile.ZipFile(src_zip_file_path, 'r') as zin,
        zipfile.ZipFile(dst_zip_file_path, 'w') as zout,
    ):
        # 遍历原始 ZIP 中的所有文件
        for item in zin.infolist():
            # 如果是目标文件，替换为新内容
            if item.filename in content:
                zout.writestr(item, content[item.filename])
            else:  # 否则直接复制
                zout.writestr(item, zin.read(item.filename))



================================================
FILE: ModuleFolders/FileConverter/BaseConverter.py
================================================
from abc import ABC, abstractmethod
from pathlib import Path


class BaseFileConverter(ABC):
    def __enter__(self):
        """申请整个converter生命周期用到的耗时资源，单个文件的资源则在convert_file方法中申请释放"""
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        """释放耗时资源"""
        pass

    @abstractmethod
    def can_convert(self, output_file_path: Path) -> bool:
        pass

    @abstractmethod
    def convert_file(self, input_file_path: Path, output_file_path: Path):
        """把文件从 input_file_path 转换成 output_file_path"""
        pass



================================================
FILE: ModuleFolders/FileConverter/OfficeFileConverter.py
================================================
from pathlib import Path

from ModuleFolders.FileConverter.BaseConverter import BaseFileConverter


class OfficeFileConverter(BaseFileConverter):

    FILE_SUFFIX_MAPPING = {
        ".doc": 0,  # wdFormatDocument
        ".rtf": 6,  # wdFormatRTF
        ".docx": 16,  # wdFormatDocumentDefault
        ".pdf": 17,  # wdFormatPDF
    }

    def __enter__(self):
        import pythoncom
        from win32com import client

        pythoncom.CoInitialize()
        try:
            self.office = client.Dispatch("Word.Application")
            self.office.Visible = False  # 不显示 Word 界面
            self.office.DisplayAlerts = False  # 关闭所有弹窗
            self.office.AutomationSecurity = 1  # 禁用宏和安全性弹窗（重要！）
            return self
        except Exception as e:
            pythoncom.CoUninitialize()
            raise RuntimeError("不能打开Word程序，请确保安装了 Microsoft Office") from e

    def __exit__(self, exc_type, exc, exc_tb):
        import pythoncom

        # Dispatch函数会复用已有的Word进程，多次退出会导致后面的com对象没有Quit函数
        if self.office and hasattr(self.office, 'Quit'):
            self.office.Quit()
        pythoncom.CoUninitialize()

    def can_convert(self, input_file_path: Path, output_file_path: Path) -> bool:
        # 输出文件类型不在类型映射中暂不支持
        if output_file_path.suffix not in self.FILE_SUFFIX_MAPPING:
            return False

        # wps 不支持 pdf 转其他格式
        if input_file_path.suffix != '.pdf':
            return True
        app_name = self.office.Name.lower()
        is_wps = 'wps' in app_name or 'kingsoft' in app_name
        if is_wps:
            print("wps不支持把pdf文件转换为其他格式")
        return not is_wps

    def convert_file(self, input_file_path: Path, output_file_path: Path):
        if not output_file_path.parent.exists():
            output_file_path.parent.mkdir(parents=True)
        # 打开文件另存为
        doc = self.office.Documents.Open(str(input_file_path), ReadOnly=1)
        try:
            # 禁用校对，防止把段落切碎
            doc_range = doc.Content
            doc_range.NoProofing = True

            doc.SaveAs(str(output_file_path), self.FILE_SUFFIX_MAPPING[output_file_path.suffix])
        finally:
            doc.Close()



================================================
FILE: ModuleFolders/FileOutputer/AssWriter.py
================================================
### AssWriter.py

from itertools import count
from pathlib import Path
from typing import Callable, Iterator

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)

class AssWriter(BaseBilingualWriter, BaseTranslatedWriter):
    """
    ASS (Advanced SubStation Alpha) 字幕文件写入器。
    能够恢复在读取时被分离的行首样式标签，以保留原始的样式和元数据。
    """
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_ass_file(translation_file_path, cache_file, pre_write_metadata, self._yield_translated_line)

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_ass_file(translation_file_path, cache_file, pre_write_metadata, self._yield_bilingual_lines)

    def _write_ass_file(
        self, 
        translation_file_path: Path, 
        cache_file: CacheFile, 
        pre_write_metadata: PreWriteMetadata,
        line_generator: Callable[[CacheItem], Iterator[str]]
    ):
        header_footer = cache_file.extra.get('ass_header_footer', [])
        
        output_lines = []
        events_written = False

        for line in header_footer:
            output_lines.append(line)
            if line.strip().lower() == '[events]':
                for item in cache_file.items:
                    for dialogue_line in line_generator(item):
                        output_lines.append(dialogue_line)
                events_written = True
        
        if not events_written:
             for item in cache_file.items:
                for dialogue_line in line_generator(item):
                    output_lines.append(dialogue_line)

        translation_file_path.write_text("\n".join(output_lines), encoding=pre_write_metadata.encoding)

    def _yield_translated_line(self, item: CacheItem) -> Iterator[str]:
        """生成单句翻译的Dialogue行"""
        if item.final_text:
            prefix = item.require_extra("dialogue_prefix")
            # 修改点 3: 从 extra 中获取行首标签，并与翻译文本组合
            leading_tags = item.extra.get("leading_tags", "")
            yield f"{prefix},{leading_tags}{item.final_text}"

    def _yield_bilingual_lines(self, item: CacheItem) -> Iterator[str]:
        """生成原文和译文两条Dialogue行"""
        prefix = item.require_extra("dialogue_prefix")
        # 修改点 4: 同样，在写回原文和译文时，都加上行首标签
        leading_tags = item.extra.get("leading_tags", "")
        
        if self._strip_text(item.source_text):
            # 组合行首标签和原文，以恢复原始行
            yield f"{prefix},{leading_tags}{item.source_text}"
        if self._strip_text(item.final_text):
            # 组合行首标签和译文
            yield f"{prefix},{leading_tags}{item.final_text}"

    def _strip_text(self, text: str):
        return (text or "").strip()

    @classmethod
    def get_project_type(cls):
        return ProjectType.ASS


================================================
FILE: ModuleFolders/FileOutputer/AutoTypeWriter.py
================================================
from functools import partial
from pathlib import Path
from typing import Callable, Iterable, Type

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    BaseTranslationWriter,
    OutputConfig,
    PreWriteMetadata
)


class AutoTypeWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(
        self, output_config: OutputConfig,
        writer_factories: Iterable[Callable[..., BaseTranslationWriter]],
        writer_init_params_factory: Callable[[str], OutputConfig]
    ):
        super().__init__(output_config)
        self.writer_factories = list(writer_factories)
        self.writer_init_params_factory = writer_init_params_factory
        self._writers: dict[str, BaseTranslationWriter] = {}
        self._active_writers = set()

        self._initialize_writers()

    def _initialize_writers(self):
        for writer_factory in self.writer_factories:
            writer_class = self._get_writer_class(writer_factory)
            if writer_class is AutoTypeWriter:
                continue
            writer_init_params = self.writer_init_params_factory(writer_class.get_project_type())
            writer = writer_factory(**writer_init_params)
            self._writers[writer_class.get_project_type()] = writer

    @classmethod
    def _get_writer_class(cls, writer_factory) -> Type[BaseTranslationWriter]:
        if isinstance(writer_factory, partial):
            return writer_factory.func
        elif issubclass(writer_factory, BaseTranslationWriter):
            return writer_factory
        else:
            raise ValueError(f"不支持的writer工厂`{writer_factory}`")

    def __exit__(self, exc_type, exc, exc_tb):
        errors = []
        for project_type in list(self._active_writers):
            try:
                writer = self._writers[project_type]
                writer.__exit__(exc_type, exc, exc_tb)
            except Exception as e:
                errors.append(f"释放{writer}失败: {str(e)}")
            finally:
                self._active_writers.discard(project_type)  # 确保移除
        if errors:
            raise RuntimeError("释放时发生异常:\n" + "\n".join(errors))

    def write_bilingual_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        self._write_translation_file(
            translation_file_path, cache_file, source_file_path, BaseTranslationWriter.TranslationMode.BILINGUAL
        )

    def write_translated_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        self._write_translation_file(
            translation_file_path, cache_file, source_file_path, BaseTranslationWriter.TranslationMode.TRANSLATED
        )

    def _write_translation_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path,
        translation_mode: BaseTranslationWriter.TranslationMode
    ):
        file_project_type = cache_file.file_project_type
        if file_project_type not in self._writers:
            return
        writer = self._writers[file_project_type]
        if writer.can_write(translation_mode):
            write_translation_file = getattr(writer, translation_mode.write_method)
            if file_project_type not in self._active_writers:
                writer.__enter__()
                self._active_writers.add(file_project_type)
            write_translation_file(translation_file_path, cache_file, source_file_path)

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError

    @classmethod
    def get_project_type(self):
        return ProjectType.AUTO_TYPE



================================================
FILE: ModuleFolders/FileOutputer/BabeldocPdfWriter.py
================================================
import shutil
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileAccessor.BabeldocPdfAccessor import BabeldocPdfAccessor
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class BabeldocPdfWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig, tmp_directory='babeldoc_cache'):
        super().__init__(output_config)
        self.tmp_directory = tmp_directory
        
        # 获取输入根路径
        root_path = output_config.input_root
        # 如果输入路径存在且是文件（即用户选择了单文件进行处理），则使用其父目录
        if root_path and root_path.is_file():
            root_path = root_path.parent
            
        self.abs_tmp_directory = root_path / self.tmp_directory
        
        self.file_accessor = BabeldocPdfAccessor(self.abs_tmp_directory, output_config)

    def __exit__(self, exc_type, exc, exc_tb):
        if self.abs_tmp_directory.exists():
            shutil.rmtree(self.abs_tmp_directory)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(
            translation_file_path, cache_file,
            pre_write_metadata, source_file_path, "mono_pdf_path"
        )

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(
            translation_file_path, cache_file,
            pre_write_metadata, source_file_path, "dual_pdf_path"
        )

    def _write_translation_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path,
        babeldoc_output_attr: str,
    ):
        result = self.file_accessor.write_content(source_file_path, cache_file.items)
        babeldoc_path_str = getattr(result, babeldoc_output_attr)
        if babeldoc_path_str and (babeldoc_path := Path(babeldoc_path_str)).exists():
            # 确保目标文件夹存在
            if not translation_file_path.parent.exists():
                translation_file_path.parent.mkdir(parents=True, exist_ok=True)
                
            if translation_file_path.exists():
                translation_file_path.unlink()
            babeldoc_path.rename(translation_file_path)

    @classmethod
    def get_project_type(self):
        return ProjectType.BABELDOC_PDF


================================================
FILE: ModuleFolders/FileOutputer/BaseWriter.py
================================================
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import TypedDict

import rich

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.FileOutputer import WriterUtil


def can_encode_text(text: str, encoding: str) -> bool:
    """检查文本是否可以用指定编码正确表示"""
    if not text:
        return True
    try:
        text.encode(encoding, errors='strict')
        return True
    except UnicodeEncodeError:
        return False


@dataclass
class TranslationOutputConfig:
    enabled: bool = False
    name_suffix: str = ""
    output_root: Path = None

# 双语排序枚举
class BilingualOrder(Enum):
    SOURCE_FIRST = "source_first"
    TRANSLATION_FIRST = "translation_first"

@dataclass
class OutputConfig:
    translated_config: TranslationOutputConfig = None
    bilingual_config: TranslationOutputConfig = None
    input_root: Path = None
    bilingual_order: BilingualOrder = field(default=BilingualOrder.TRANSLATION_FIRST)  # 双语排序配置

    def __post_init__(self):
        if self.translated_config is None:
            self.translated_config = TranslationOutputConfig(True, "_translated")
        if self.bilingual_config is None:
            self.bilingual_config = TranslationOutputConfig(False, "_bilingual")


class WriterInitParams(TypedDict):
    """writer的初始化参数，必须包含output_config，其他参数随意"""
    output_config: OutputConfig


@dataclass
class PreWriteMetadata:
    encoding: str = "utf-8"


class BaseTranslationWriter(ABC):
    """Writer基类，在其生命周期内可以输出多个文件"""
    def __init__(self, output_config: OutputConfig) -> None:
        self.output_config = output_config

    class TranslationMode(Enum):
        TRANSLATED = ('translated_config', 'write_translated_file')
        BILINGUAL = ('bilingual_config', 'write_bilingual_file')

        def __init__(self, config_attr, write_method) -> None:
            self.config_attr = config_attr
            self.write_method = write_method

    def can_write(self, mode: TranslationMode) -> bool:
        """判断writer是否支持该输出方式"""
        if mode == self.TranslationMode.TRANSLATED:
            return isinstance(self, BaseTranslatedWriter) and self.output_config.translated_config.enabled
        elif mode == self.TranslationMode.BILINGUAL:
            return isinstance(self, BaseBilingualWriter) and self.output_config.bilingual_config.enabled
        return False

    def __enter__(self):
        """申请整个Writer生命周期用到的耗时资源，单个文件的资源则在write_xxx_file方法中申请释放"""
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        """释放耗时资源"""
        pass

    @classmethod
    @abstractmethod
    def get_project_type(self) -> str:
        """获取Writer对应的项目类型标识符（用于动态实例化），如 Mtool"""
        pass

    @classmethod
    def is_environ_supported(cls) -> bool:
        """用于判断当前环境是否支持该writer"""
        return True


class BaseTranslatedWriter(BaseTranslationWriter):
    """译文输出基类"""

    def write_translated_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        """输出译文文件"""
        pre_write_metadata = self.pre_write_translated(translation_file_path, cache_file)
        self.on_write_translated(translation_file_path, cache_file, pre_write_metadata, source_file_path)
        self.post_write_translated(translation_file_path)

    def pre_write_translated(self, translation_file_path: Path, cache_file: CacheFile) -> PreWriteMetadata:
        """根据文件内容做输出前操作，如输出编码检测"""
        # 原始文件编码（默认为utf-8）
        original_encoding = cache_file.encoding or "utf-8"
        # 是否使用原始编码
        use_original_encoding = True

        if original_encoding.lower() == 'utf-8' or original_encoding.startswith("non_text"):
            pass  # UTF-8可以表示所有字符，无需检查 / 非纯文本不需要检查
        else:
            # 检查所有文本是否可以用原始编码表示
            for item in cache_file.items:
                if item.translated_text and not can_encode_text(item.translated_text, original_encoding):
                    use_original_encoding = False
                    break

        # 决定使用的编码
        # 获取配置文件是否保持原有编码
        keep_original_encoding_config = WriterUtil.get_ainiee_config().keep_original_encoding
        if keep_original_encoding_config in (None, False):
            actual_encoding = 'utf-8'
        else:
            actual_encoding = original_encoding if use_original_encoding else 'utf-8'

        # 除了直接输出的译文之外的文件统一使用utf-8
        if "_translated" not in translation_file_path.name:
            actual_encoding = "utf-8"
        else:
            rich.print(
                f"[[green]INFO[/]] 正在写入文件 {translation_file_path}, 使用编码: {original_encoding} -> {actual_encoding}"
            )

        return PreWriteMetadata(encoding=actual_encoding)

    @abstractmethod
    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        """执行实际的文件写入操作"""
        pass

    def post_write_translated(self, translation_file_path: Path):
        """输出后操作，如验证"""
        pass


class BaseBilingualWriter(BaseTranslationWriter):
    """双语输出基类"""

    def write_bilingual_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        """输出双语文件"""
        pre_write_metadata = self.pre_write_bilingual(cache_file)
        self.on_write_bilingual(translation_file_path, cache_file, pre_write_metadata, source_file_path)
        self.post_write_bilingual(translation_file_path)

    def pre_write_bilingual(self, cache_file: CacheFile) -> PreWriteMetadata:
        """根据文件内容做输出前操作，如输出编码检测"""
        return PreWriteMetadata()

    @abstractmethod
    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        """执行实际的文件写入操作"""
        pass

    def post_write_bilingual(self, translation_file_path: Path):
        """输出后操作，如验证"""
        pass



================================================
FILE: ModuleFolders/FileOutputer/DirectoryWriter.py
================================================
from pathlib import Path
from typing import Callable

import rich

from ModuleFolders.Cache.CacheProject import CacheProject
from ModuleFolders.FileOutputer import WriterUtil
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    BaseTranslationWriter,
    TranslationOutputConfig
)


class DirectoryWriter:
    def __init__(self, create_writer: Callable[[], BaseTranslationWriter]):
        self.create_writer = create_writer

    WRITER_TYPE_CONFIG = {
        BaseTranslatedWriter: ("translated_config", "write_translated_file"),
        BaseBilingualWriter: ("bilingual_config", "write_bilingual_file"),
    }

    def write_translation_directory(
        self, project: CacheProject, source_directory: Path,
        translation_directory: Path = None,
    ):
        """translation_directory 用于覆盖配置"""
        with self.create_writer() as writer:
            # 判断输入路径是目录还是文件
            is_source_a_directory = source_directory.is_dir()
            
            # 把翻译片段按文件名分组
            for storage_path, file_items in project.files.items():
                # 根据输入路径的类型决定如何构造源文件路径
                if is_source_a_directory:
                    # 如果是目录，则拼接相对路径
                    source_file_path = source_directory / storage_path
                else:
                    # 如果是文件，则输入路径本身就是源文件路径
                    source_file_path = source_directory
                for translation_mode in BaseTranslationWriter.TranslationMode:
                    if writer.can_write(translation_mode):
                        translation_config: TranslationOutputConfig = getattr(
                            writer.output_config, translation_mode.config_attr
                        )
                        # 替换文件后缀
                        new_storage_path = self.with_file_suffix(storage_path, translation_config.name_suffix)
                        output_root = translation_directory or translation_config.output_root
                        translation_file_path = output_root / new_storage_path
                        if not translation_file_path.parent.exists():
                            translation_file_path.parent.mkdir(parents=True, exist_ok=True)
                        write_translation_file = getattr(writer, translation_mode.write_method)

                        # 执行写入
                        write_translation_file(translation_file_path, file_items, source_file_path)
        # 释放Ainiee配置实例
        WriterUtil.release_ainiee_config()

    @classmethod
    def with_file_suffix(self, file_path: str, name_suffix: str) -> Path:
        parts = file_path.rsplit(".", 1)
        if len(parts) == 2:
            return f"{parts[0]}{name_suffix}.{parts[1]}"
        else:
            return f"{parts[0]}{name_suffix}"



================================================
FILE: ModuleFolders/FileOutputer/DocxWriter.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileAccessor.DocxAccessor import DocxAccessor
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class DocxWriter(BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)
        self.file_accessor = DocxAccessor()

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        content = self.file_accessor.read_content(source_file_path)
        start_index = 0
        # 根据 w:t 标签找到原文
        paragraphs = content.find_all("w:t")
        items = cache_file.items
        for match in paragraphs:
            if isinstance(match.string, str) and match.string.strip():
                # 在翻译结果中查找是否存在原文，存在则替换并右移开始下标
                for content_index in range(start_index, len(items)):
                    if match.string == items[content_index].source_text:
                        match.string = items[content_index].final_text
                        start_index = content_index + 1
                        break
        self.file_accessor.write_content(
            content, translation_file_path, source_file_path
        )

    @classmethod
    def get_project_type(self):
        return ProjectType.DOCX



================================================
FILE: ModuleFolders/FileOutputer/EpubWriter.py
================================================
import re
from itertools import groupby
from pathlib import Path
from typing import Callable

from bs4 import BeautifulSoup

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileAccessor.EpubAccessor import EpubAccessor
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata,
    BilingualOrder,
)


class EpubWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)
        self.file_accessor = EpubAccessor()

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(
            translation_file_path, cache_file,
            source_file_path, self._rebuild_bilingual_tag
        )

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(
            translation_file_path, cache_file,
            source_file_path, self._rebuild_translated_tag
        )

    def _write_translation_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path, translate_html_tag: Callable[[str, str], str]
    ):
        content = self.file_accessor.read_content(source_file_path)

        translated_item_dict = {
            k: list(v)
            for k, v in groupby(cache_file.items, key=lambda x: x.require_extra("item_id"))
        }
        translation_content = {}
        for item_id, item_filename, html_content in content:
            if item_id not in translated_item_dict:
                translation_content[item_filename] = html_content
                continue
            
            modified_html_content = html_content
            for item in translated_item_dict[item_id]:
                if item.translation_status == TranslationStatus.TRANSLATED or item.translation_status == TranslationStatus.POLISHED:
                    original_html = item.require_extra("original_html")
                    translated_text = item.final_text
                    new_html = translate_html_tag(original_html, translated_text)
                    modified_html_content = modified_html_content.replace(original_html, new_html, 1)
            translation_content[item_filename] = modified_html_content
        self.file_accessor.write_content(
            translation_content, translation_file_path, source_file_path
        )

    # 译文版本
    def _rebuild_translated_tag(self, original_html, translated_text):
        soup = BeautifulSoup(original_html, 'html.parser')
        original_tag = soup.find()
        if not original_tag:
            return translated_text

        original_text = original_tag.get_text()
        processed_translated = self._copy_leading_spaces(original_text, translated_text)

        new_tag = soup.new_tag(original_tag.name)
        new_tag.attrs = original_tag.attrs.copy()

        if original_tag.is_empty_element:
            return str(new_tag)

        new_tag.string = processed_translated
        return str(new_tag)

    # 双语版本
    def _rebuild_bilingual_tag(self, original_html, translated_text):
        ORIGINAL_STYLE = {
            'opacity': '0.8',
            'color': '#888',
            'font-size': '0.85em',
            'font-style': 'italic',
            'margin-top': '0.2em',
        }

        soup = BeautifulSoup(original_html, 'html.parser')
        original_tag = soup.find()

        # 如果原始HTML中没有标签（纯文本），则使用div进行包裹作为回退方案
        if not original_tag:
            original_text_content = soup.get_text()
            processed_trans = self._copy_leading_spaces(original_text_content, translated_text)
            style_str = '; '.join([f"{k}:{v}" for k, v in ORIGINAL_STYLE.items()])
            
            trans_div = f'<div>{processed_trans}</div>'
            orig_div = f'<div style="{style_str}">{original_html}</div>'

            if self.output_config.bilingual_order == BilingualOrder.SOURCE_FIRSTT:
                return f"{orig_div}\n  {trans_div}"
            else:  # 默认为译文在前
                return f"{trans_div}\n  {orig_div}"

        # 复制前导空格
        original_text = original_tag.get_text()
        processed_trans = self._copy_leading_spaces(original_text, translated_text)

        # 1. 创建全新的译文标签
        trans_tag = soup.new_tag(original_tag.name, attrs=original_tag.attrs.copy())
        trans_tag.string = processed_trans

        # 2. 创建一个全新的、带样式的原文标签，而不是在原始标签上就地修改。
        #    这是为了避免 BeautifulSoup 的副作用导致原始标签内容丢失。
        styled_attrs = original_tag.attrs.copy()
        styled_attrs.pop('id', None) # 移除id以避免冲突

        # 合并样式
        existing_style = styled_attrs.get('style', '')
        if existing_style and not existing_style.strip().endswith(';'):
            existing_style += '; '
        new_style = '; '.join([f"{k}:{v}" for k, v in ORIGINAL_STYLE.items()])
        styled_attrs['style'] = existing_style + new_style
        
        orig_styled_tag = soup.new_tag(original_tag.name, attrs=styled_attrs)
        
        # 3. 将原始标签的完整内容（包括文本和所有子标签）复制到新的带样式标签中。
        if original_tag.contents:
            orig_styled_tag.extend(list(original_tag.contents))
        
        # 4. 组合并返回两个新创建标签的字符串形式
        trans_html = str(trans_tag)
        orig_html_styled = str(orig_styled_tag)
        
        if self.output_config.bilingual_order == BilingualOrder.SOURCE_FIRST:
            return f"{orig_html_styled}\n  {trans_html}"
        else:  # 默认为译文在前
            return f"{trans_html}\n  {orig_html_styled}"


    def _copy_leading_spaces(self, source_text, target_text):
        leading_spaces = re.match(r'^[ \u3000]+', source_text)
        leading_spaces = leading_spaces.group(0) if leading_spaces else ''
        return leading_spaces + target_text.lstrip()

    @classmethod
    def get_project_type(self):
        return ProjectType.EPUB


================================================
FILE: ModuleFolders/FileOutputer/FileOutputer.py
================================================
from functools import partial
from pathlib import Path
from typing import Type

from ModuleFolders.Cache.CacheProject import CacheProject
from ModuleFolders.FileOutputer.AutoTypeWriter import AutoTypeWriter
from ModuleFolders.FileOutputer.BaseWriter import BaseTranslationWriter, OutputConfig, TranslationOutputConfig, WriterInitParams, BilingualOrder
from ModuleFolders.FileOutputer.DirectoryWriter import DirectoryWriter
from ModuleFolders.FileOutputer.MToolWriter import MToolWriter
from ModuleFolders.FileOutputer.OfficeConversionWriter import OfficeConversionDocWriter
from ModuleFolders.FileOutputer.ParatranzWriter import ParatranzWriter
from ModuleFolders.FileOutputer.TPPWriter import TPPWriter
from ModuleFolders.FileOutputer.VntWriter import VntWriter
from ModuleFolders.FileOutputer.SrtWriter import SrtWriter
from ModuleFolders.FileOutputer.VttWriter import VttWriter
from ModuleFolders.FileOutputer.LrcWriter import LrcWriter
from ModuleFolders.FileOutputer.TxtWriter import TxtWriter
from ModuleFolders.FileOutputer.EpubWriter import EpubWriter
from ModuleFolders.FileOutputer.DocxWriter import DocxWriter
from ModuleFolders.FileOutputer.MdWriter import MdWriter
from ModuleFolders.FileOutputer.RenpyWriter import RenpyWriter
from ModuleFolders.FileOutputer.TransWriter import TransWriter
from ModuleFolders.FileOutputer.I18nextWriter import I18nextWriter
from ModuleFolders.FileOutputer.PoWriter import PoWriter
from ModuleFolders.FileOutputer.BabeldocPdfWriter import BabeldocPdfWriter
from PluginScripts.IOPlugins.CustomRegistry import CustomWriter
from ModuleFolders.FileOutputer.AssWriter import AssWriter

# 文件输出器
class FileOutputer:

    def __init__(self):
        self.writer_factory_dict = {}
        self._register_system_writer()

    def register_writer(self, writer_class: Type[BaseTranslationWriter], **init_kwargs):
        """如果writer可注册，则根据project_type进行注册"""
        if writer_class.is_environ_supported():
            writer_factory = partial(writer_class, **init_kwargs) if init_kwargs else writer_class
            self.writer_factory_dict[writer_class.get_project_type()] = writer_factory

    def _register_system_writer(self):
        self.register_writer(MToolWriter)
        self.register_writer(SrtWriter)
        self.register_writer(VttWriter)
        self.register_writer(LrcWriter)
        self.register_writer(VntWriter)
        self.register_writer(AssWriter)
        self.register_writer(TxtWriter)
        self.register_writer(MdWriter)
        self.register_writer(EpubWriter)
        self.register_writer(DocxWriter)
        self.register_writer(RenpyWriter)
        self.register_writer(TransWriter)
        self.register_writer(I18nextWriter)
        self.register_writer(PoWriter)
        self.register_writer(ParatranzWriter)
        self.register_writer(TPPWriter)
        self.register_writer(OfficeConversionDocWriter)
        self.register_writer(BabeldocPdfWriter)

        # 注册插件式 Writer
        CustomWriter.register_writers(self)

        # 由于values是引用，最先注册和最后注册都一样
        self.register_writer(AutoTypeWriter, writer_factories=self.writer_factory_dict.values())

    # 输出已经翻译文件
    def output_translated_content(self, cache_data: CacheProject, output_path, input_path, config: dict) -> None:
        # cache_data_iter = iter(cache_data)
        # base_info = next(cache_data_iter)
        project_type = cache_data.project_type
        if project_type in self.writer_factory_dict:
            writer_iinit_params = self._get_writer_init_params(
                project_type, Path(output_path), Path(input_path), config
            )
            # 绑定配置，使工厂变成无参
            writer_factory = partial(self.writer_factory_dict[project_type], **writer_iinit_params)

            # 正确处理输入路径是文件的情况
            input_path_obj = Path(input_path)
            if input_path_obj.is_file():
                source_directory = input_path_obj.parent  # 获取文件所在目录
            else:
                source_directory = input_path_obj

            writer = DirectoryWriter(writer_factory)
            # 为防止双语输出路径被覆盖，这里不传translation_directory
            writer.write_translation_directory(cache_data, source_directory)

    def _get_writer_init_params(self, project_type, output_path: Path, input_path: Path, config: dict):
        output_config = self._get_writer_default_config(project_type, output_path, input_path, config)
        if project_type == AutoTypeWriter.get_project_type():
            writer_init_params_factory = partial(
                self._get_writer_init_params,
                output_path=output_path,
                input_path=input_path,
                config=config,
            )
            # 实际writer默认的输出目录、文件名后缀等配置会被AutoTypeWriter的覆盖
            return WriterInitParams(output_config=output_config, writer_init_params_factory=writer_init_params_factory)
        return WriterInitParams(output_config=output_config)

    def _get_writer_default_config(self, project_type, output_path: Path, input_path: Path, config: dict):
        # 从配置中读取后缀，如果未配置则使用默认值
        translated_suffix = config.get("translated_suffix", "_translated")
        bilingual_suffix = config.get("bilingual_suffix", "_bilingual")
        
        # 从配置中读取双语排序
        bilingual_order_str = config.get("bilingual_order", "source_first")
        try:
            bilingual_order = BilingualOrder(bilingual_order_str)
        except ValueError:
            # 如果配置值无效，则回退到默认值
            bilingual_order = BilingualOrder.SOURCE_FIRST

        default_translated_config = TranslationOutputConfig(True, translated_suffix, output_path)

        # 创建基础的 OutputConfig，包含新的配置项
        def create_output_config(**kwargs):
            base_args = {"bilingual_order": bilingual_order, "input_root": input_path}
            base_args.update(kwargs)
            return OutputConfig(**base_args)

        if project_type == SrtWriter.get_project_type():
            return create_output_config(
                translated_config=TranslationOutputConfig(True, config.get("translated_suffix", ".translated"), output_path),
                bilingual_config=TranslationOutputConfig(True, config.get("bilingual_suffix", '.bilingual'), output_path / "bilingual_srt"),
            )
        elif project_type in (TxtWriter.get_project_type(), EpubWriter.get_project_type(), BabeldocPdfWriter.get_project_type()):
            bilingual_dir_map = {
                TxtWriter.get_project_type(): "bilingual_txt",
                EpubWriter.get_project_type(): "bilingual_epub",
                BabeldocPdfWriter.get_project_type(): "bilingual_pdf"
            }
            return create_output_config(
                translated_config=default_translated_config,
                bilingual_config=TranslationOutputConfig(True, bilingual_suffix, output_path / bilingual_dir_map[project_type]),
            )
        elif project_type == AutoTypeWriter.get_project_type():
            return create_output_config(
                translated_config=default_translated_config,
                bilingual_config=TranslationOutputConfig(True, bilingual_suffix, output_path / "bilingual_auto"),
                input_root=None # AutoTypeWriter 的 input_root 是动态的
            )
        elif project_type in (
            RenpyWriter.get_project_type(), TransWriter.get_project_type(), TPPWriter.get_project_type()
        ):
            # 这些类型通常没有后缀
            return create_output_config(translated_config=TranslationOutputConfig(True, "", output_path))
        else:
            return create_output_config(translated_config=default_translated_config)


================================================
FILE: ModuleFolders/FileOutputer/I18nextWriter.py
================================================
import json
from pathlib import Path
from typing import Any, Dict, List

# 假定这些导入相对于项目结构是正确的
from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class I18nextWriter(BaseTranslatedWriter):
    """
    将包含翻译信息的 CacheItem 列表写回 i18next 格式的 JSON 文件。
    利用 CacheItem 中的 'i18next_path' 属性来重建原始的嵌套结构。
    """
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.I18NEXT  # 与 Reader 保持一致

    def _set_value_by_path(self, data_dict: Dict, path: List[str], value: Any):
        """
        根据路径列表在嵌套字典中设置值。如果路径不存在，则创建它。
        """
        current_level = data_dict
        # 遍历到倒数第二个键
        for i, key in enumerate(path[:-1]):
            if key not in current_level:
                current_level[key] = {} # 创建新字典层级
            elif not isinstance(current_level[key], dict):
                 # 路径冲突：期望是字典，但遇到其他类型
                 # 可以选择：覆盖、报错、或跳过
                 current_level[key] = {} # 强制覆盖为字典以继续
            current_level = current_level[key]

        # 设置最后一个键的值
        last_key = path[-1]
        current_level[last_key] = value

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        """
        将 CacheItem 列表写入 i18next JSON 文件。
        """
        output_data = {} # 用于构建最终 JSON 结构的字典

        for item in cache_file.items:
            path: List[str] = item.require_extra("i18next_path")

            # 获取翻译后的文本
            translated_text = item.final_text  # 假设这个方法返回最终要写入的字符串

            # 使用辅助函数将翻译文本按路径设置到 output_data 中
            self._set_value_by_path(output_data, path, translated_text)

        json_content = json.dumps(output_data, ensure_ascii=False, indent=4)

        # 确保目录存在
        translation_file_path.parent.mkdir(parents=True, exist_ok=True)

        # 以 UTF-8 编码写入文件
        translation_file_path.write_text(json_content, encoding="utf-8")



================================================
FILE: ModuleFolders/FileOutputer/LrcWriter.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class LrcWriter(BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        """输出文件格式示例
        [ti:1.したっぱ童貞構成員へハニートラップ【手コキ】 (Transcribed on 15-May-2023 19-10-13)]
        [00:00.00]お疲れ様です大長 ただいま機会いたしました
        [00:06.78]法案特殊情報部隊一番対処得フィルレイやセルドツナイカーです 今回例の犯罪組織への潜入が成功しましたのでご報告させていただきます
        """
        output_lines = []
        if subtitle_title := cache_file.get_extra("subtitle_title"):
            output_lines.append(f"[{subtitle_title}]\n")
        # 转换中间字典的格式为最终输出格式
        for item in cache_file.items:
            # 获取字幕时间轴
            subtitle_time = item.require_extra("subtitle_time")
            # 获取字幕文本内容
            subtitle_text = item.final_text

            output_lines.append(f"[{subtitle_time}]{subtitle_text}\n")

        # 输出已经翻译的文件
        translation_file_path.write_text("".join(output_lines), encoding=pre_write_metadata.encoding)

    @classmethod
    def get_project_type(self):
        return ProjectType.LRC



================================================
FILE: ModuleFolders/FileOutputer/MdWriter.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)
from ModuleFolders.FileOutputer.TxtWriter import TxtWriter


class MdWriter(BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)
        self.txt_writer = TxtWriter(output_config)  # 简单复用TxtWriter，如有另外实现请删除

    def __enter__(self):
        self.txt_writer.__enter__()
        return super().__enter__()

    def __exit__(self, exc_type, exc, exc_tb):
        self.txt_writer.__exit__(exc_type, exc, exc_tb)
        return super().__exit__(exc_type, exc, exc_tb)

    def write_translated_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        self.txt_writer.write_translated_file(translation_file_path, cache_file, source_file_path)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError

    @classmethod
    def get_project_type(self):
        return ProjectType.MD



================================================
FILE: ModuleFolders/FileOutputer/MToolWriter.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/FileOutputer/OfficeConversionWriter.py
================================================
import platform
import shutil
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileConverter.OfficeFileConverter import OfficeFileConverter
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)
from ModuleFolders.FileOutputer.DocxWriter import DocxWriter


class OfficeConversionWriter(BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig, tmp_directory='office_cache'):
        super().__init__(output_config)
        self.tmp_directory = tmp_directory
        self.tmp_file_suffix = '.docx'

        self.docx_writer = DocxWriter(output_config)
        self.converter = OfficeFileConverter()

    def __enter__(self):
        self.docx_writer.__enter__()
        self.converter.__enter__()
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        self.converter.__exit__(exc_type, exc, exc_tb)
        self.docx_writer.__exit__(exc_type, exc, exc_tb)
        output_temp_root = self.output_config.translated_config.output_root / self.tmp_directory
        if output_temp_root.exists():
            shutil.rmtree(output_temp_root)
        input_temp_root = self.output_config.input_root / self.tmp_directory
        if input_temp_root.exists():
            shutil.rmtree(input_temp_root)

    def write_translated_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        source_file_path: Path = None,
    ):
        rel_path = translation_file_path.relative_to(self.output_config.translated_config.output_root)
        tmp_source_docx_path = (
            self.output_config.input_root / self.tmp_directory / rel_path
        ).with_suffix(self.tmp_file_suffix)

        # 转换的原文中间格式文件不存在则创建
        if self.converter.can_convert(source_file_path, tmp_source_docx_path):
            if not tmp_source_docx_path.exists():
                self.converter.convert_file(source_file_path, tmp_source_docx_path)

        # 存在转换后原文中间格式文件时进行翻译，并转换回原格式
        if tmp_source_docx_path.exists():
            tmp_translation_docx_path = (
                self.output_config.translated_config.output_root / self.tmp_directory / rel_path
            ).with_suffix(self.tmp_file_suffix)
            if not tmp_translation_docx_path.parent.exists():
                tmp_translation_docx_path.parent.mkdir(parents=True)
            # 翻译中间格式文件
            self.docx_writer.write_translated_file(tmp_translation_docx_path, cache_file, tmp_source_docx_path)
            if self.converter.can_convert(tmp_translation_docx_path, translation_file_path):
                self.converter.convert_file(tmp_translation_docx_path, translation_file_path)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError

    @classmethod
    def is_environ_supported(cls) -> bool:
        return platform.system() == 'Windows'


class OfficeConversionPdfWriter(OfficeConversionWriter):
    @classmethod
    def get_project_type(cls) -> str:
        return ProjectType.OFFICE_CONVERSION_PDF


class OfficeConversionDocWriter(OfficeConversionWriter):
    @classmethod
    def get_project_type(cls) -> str:
        return ProjectType.OFFICE_CONVERSION_DOC



================================================
FILE: ModuleFolders/FileOutputer/ParatranzWriter.py
================================================
import json
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class ParatranzWriter(BaseTranslatedWriter):
    """
        中间存储字典格式示例
        ex_path_dict = {
            "D:\\DEBUG Folder\\Replace the original text.json": {'translation_status': 1, 'Source Text': 'しこトラ！',
                                                                    'Translated Text': 'しこトラ！'},
            "D:\\DEBUG Folder\\DEBUG Folder\\Replace the original text.json": {'translation_status': 0,
                                                                                'Source Text': 'しこトラ！',
                                                                                'Translated Text': 'しこトラ！'}
        }
    """
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        output_list = []
        for item in cache_file.items:

            line = {
                "key": item.get_extra("key", ""),  # 假设每个 item 都有 key 字段
                "original": item.source_text,
                "translation": item.final_text or "",
                "context": item.get_extra("context", "")  # 如果你有 context 字段，也包括它
            }
            # 根据翻译状态，选择存储到已翻译或未翻译的列表
            if item.translation_status == TranslationStatus.TRANSLATED or item.translation_status == TranslationStatus.POLISHED:
                output_list.append(line)
        json_content = json.dumps(output_list, ensure_ascii=False, indent=4)
        translation_file_path.write_text(json_content, encoding="utf-8")
        # 未保留未翻译输出

    @classmethod
    def get_project_type(self):
        return ProjectType.PARATRANZ



================================================
FILE: ModuleFolders/FileOutputer/PoWriter.py
================================================
import polib
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata,
)

class PoWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)
        try:
            import polib
        except ImportError:
            raise ImportError("`polib` is not installed. Please run 'pip install polib' to use PO file support.")

    @classmethod
    def get_project_type(cls):
        return ProjectType.PO

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_po_file(translation_file_path, cache_file, pre_write_metadata)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_po_file(translation_file_path, cache_file, pre_write_metadata)

    def _write_po_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata
    ):
        po_file = polib.POFile()
        po_file.metadata = cache_file.extra.get('metadata', {})
        po_file.header = cache_file.extra.get('header', '')

        for item in cache_file.items:
            extra = item.extra
            entry = polib.POEntry(
                msgid=item.source_text,
                msgstr=item.final_text,
                msgctxt=extra.get('msgctxt'),
                msgid_plural=extra.get('msgid_plural', ''),
                comment=extra.get('comment', ''),
                tcomment=extra.get('tcomment', ''),
                occurrences=extra.get('occurrences', []),
                flags=extra.get('flags', []),
                previous_msgid=extra.get('previous_msgid'),
                previous_msgctxt=extra.get('previous_msgctxt'),
                linenum=extra.get('linenum')
            )
            po_file.append(entry)

        po_file.save(str(translation_file_path))


================================================
FILE: ModuleFolders/FileOutputer/RenpyWriter.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/FileOutputer/SrtWriter.py
================================================
from functools import partial
from itertools import count
from pathlib import Path
from typing import Callable, Iterator

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class SrtWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        _yield_bilingual_block = partial(self._yield_bilingual_block, counter=count(1))
        self._write_translation_file(translation_file_path, cache_file, pre_write_metadata, _yield_bilingual_block)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(translation_file_path, cache_file, pre_write_metadata, self._yield_translated_block)

    def _write_translation_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        yield_block: Callable[[CacheItem], Iterator[list[str]]]
    ):
        output = []
        for item in cache_file.items:
            if not item.source_text or not item.final_text:
                continue
            for block in yield_block(item):
                output.append("\n".join(block).strip())
        if output:
            translation_file_path.write_text("\n\n".join(output), encoding=pre_write_metadata.encoding)

    def _map_to_translated_item(self, item: CacheItem):
        block = [
            str(item.require_extra("subtitle_number")),
            item.require_extra("subtitle_time"),
            item.final_text.strip(),
            "",
        ]
        return block

    def _yield_bilingual_block(self, item: CacheItem, counter: count):
        if self._strip_text(item.source_text):
            number = next(counter)
            original_block = [
                str(number),
                item.require_extra("subtitle_time"),
                item.source_text.strip(),
                "",
            ]
            yield original_block
        if self._strip_text(item.translated_text):
            number = next(counter)
            translated_block = self._map_to_translated_item(item)
            translated_block[0] = str(number)
            yield translated_block

    def _strip_text(self, text: str):
        return (text or "").strip()

    def _yield_translated_block(self, item: CacheItem):
        yield self._map_to_translated_item(item)

    @classmethod
    def get_project_type(self):
        return ProjectType.SRT



================================================
FILE: ModuleFolders/FileOutputer/TPPWriter.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/FileOutputer/TransWriter.py
================================================
import json
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class TransWriter(BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        trans_content = json.loads(source_file_path.read_text(encoding="utf-8"))
        for item in cache_file.items:
            file_category = item.get_extra("file_category", "")
            data_index = item.get_extra("data_index", "")
            tags = item.get_extra("tags", None)
            new_translation = item.final_text
            name = item.get_extra("name", "")

            # 导航并更新，带有检查
            if file_category not in trans_content["project"]["files"]:
                print(f"[警告] 文件类别 '{file_category}' 在目标文件中不存在，跳过该项目。")
                continue
            
            category_data = trans_content["project"]["files"][file_category]
            data_list = category_data["data"]
            tags_list = category_data.get("tags") # 如果 "tags" 不存在，返回 None

            # 检查 data_index 是否为有效整数且在 data_list 的范围内
            if not isinstance(data_index, int) or not (0 <= data_index < len(data_list)):
                print(f"[警告] 检测到无效或越界的 data_index ({data_index})，将跳过此项目。")
                print(f"       文件类别: {file_category}, 列表长度: {len(data_list)}")
                # 尝试输出上一个索引的文本
                try:
                    if data_index > 0:
                        print(f"       上一个索引的文本: {data_list[data_index - 1]}")
                except IndexError:
                    pass  
                
                continue # 跳过当前循环，处理下一个 item

            # 补充或者创建一样长度的tags列表，与文本列表长度一致
            tags_list = self.align_lists(data_list, tags_list)
            # 将更新后的 tags_list 写回 category_data，以防 align_lists 创建了新的列表
            category_data["tags"] = tags_list

            # 如果有人名信息
            if name:
                # 分割人名与文本
                name, new_translation = self.extract_strings(name, new_translation)

            # 仅当翻译实际改变时才写入，译文文本在第二个元素
            if len(data_list[data_index]) > 1:  # 检查长度是否至少为2,保证有译文位置
                if data_list[data_index][1] != new_translation:
                    data_list[data_index][1] = new_translation
            else:
                # 处理列表只有一个元素或没有元素的情况
                data_list[data_index].append(new_translation)

            # 写回颜色标签
            tags_list[data_index] = tags

        # 写回修改后的内容
        json_content = json.dumps(trans_content, ensure_ascii=False, indent=4)
        translation_file_path.write_text(json_content, encoding="utf-8")

    def extract_strings(self, name, dialogue):
        # 验证数据类型
        if not isinstance(dialogue, str) or not isinstance(name, str):
            return name, dialogue

        # 仅当对话以"["开头时才处理
        if not dialogue.startswith("["):
            return name, dialogue

        end_pos = -1  # 初始化结束位置为-1（表示未找到）

        # 优先策略：尝试匹配与原name嵌套层级一致的"]"
        # 这种策略可以正确处理 [[英雄]惊讶] 这样的情况
        count_in_name = name.count("]")
        required_closing_brackets = count_in_name + 1
        
        search_start_pos = 0
        temp_end_pos = -1
        found_brackets = 0
        for _ in range(required_closing_brackets):
            # 从上一个找到的位置之后开始搜索
            pos = dialogue.find("]", search_start_pos)
            if pos == -1:
                # 如果找不到足够数量的"]"，说明优先策略失败
                found_brackets = -1  # 标记为失败
                break
            temp_end_pos = pos
            found_brackets += 1
            search_start_pos = pos + 1
        
        # 如果优先策略成功，则使用其结果
        if found_brackets == required_closing_brackets:
            end_pos = temp_end_pos

        # 回退策略：如果优先策略失败 (end_pos 仍然是 -1)，则回退为查找第一个 "]"
        if end_pos == -1:
            end_pos = dialogue.find("]")

        # 如果最终找到了一个有效的结束位置（无论是通过优先策略还是回退策略）
        # end_pos > 0 确保了不是空名字，如 "[]text"
        if end_pos > 0:
            extracted_name = dialogue[1:end_pos]
            remaining_dialogue = dialogue[end_pos + 1:].lstrip()
            return extracted_name, remaining_dialogue

        # 如果两种策略都失败了（例如，对话是"["但没有"]"），则返回原值
        return name, dialogue


    def align_lists(self, data_list, tags_list):
        # 如果 tags_list 是 None，初始化为空列表
        if tags_list is None:
            tags_list = []
        
        # 计算需要补充的 None 的个数
        diff = len(data_list) - len(tags_list)
        if diff > 0:
            # 如果 data_list 更长，补充 None 到 tags_list
            tags_list.extend([None] * diff)
        return tags_list

    @classmethod
    def get_project_type(self):
        return ProjectType.TRANS



================================================
FILE: ModuleFolders/FileOutputer/TxtWriter.py
================================================
from pathlib import Path
from typing import Callable

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseBilingualWriter,
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata,
    BilingualOrder,
)


class TxtWriter(BaseBilingualWriter, BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_bilingual(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(translation_file_path, cache_file, pre_write_metadata, self._item_to_bilingual_line)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        self._write_translation_file(translation_file_path, cache_file, pre_write_metadata, self._item_to_translated_line)

    def _write_translation_file(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        item_to_line: Callable[[CacheItem], str],
    ):
        if not cache_file.items:
            translation_file_path.touch()
            return

        # 处理所有项目
        lines = list(map(item_to_line, cache_file.items))

        translation_file_path.write_text("".join(lines), encoding=pre_write_metadata.encoding)

    # 双语版构建
    def _item_to_bilingual_line(self, item: CacheItem):
        line_break = "\n" * max(item.require_extra("line_break") + 1, 1)
        
        # 检查配置并决定输出顺序
        if self.output_config.bilingual_order == BilingualOrder.TRANSLATION_FIRST:
            return (
                f"{item.final_text}\n"
                f"{item.source_text}{line_break}"
            )
        else: # 默认为原文在前
            return (
                f"{item.source_text}\n"
                f"{item.final_text}{line_break}"
            )
        
    # 译文版构建
    def _item_to_translated_line(self, item: CacheItem):
        line_break = "\n" * (item.require_extra("line_break") + 1)

        return f"{item.final_text}{line_break}"

    @classmethod
    def get_project_type(self):
        return ProjectType.TXT


================================================
FILE: ModuleFolders/FileOutputer/VntWriter.py
================================================
import json
from pathlib import Path

# 假定这些导入相对于项目结构是正确的
from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class VntWriter(BaseTranslatedWriter):
    """输出Vnt格式文件的写入器。
       输出文件格式示例
        [
            {
                "names": ["玲","女人"], # 可能包含 'names' 列表
                "message": "「……」"
            },
            {
                "name": "玲", # 或者可能包含 'name' 字符串
                "message": "「……おはよう」"
            },
            { # 或者两者都没有
                "message": "　心の内では、ムシャクシャした気持ちは未だに鎮まっていなかった。"
            }
        ]
    """
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        output_list = []
        # 转换中间字典的格式为最终输出格式
        for item in cache_file.items:
            # 一次性获取翻译后的文本
            translated_text_full = item.final_text
            text = None # 初始化text字典

            # --- 首先检查 'names' ---
            original_names = item.get_extra("names")
            # 确保它是一个非空列表
            if isinstance(original_names, list) and original_names:
                # 处理 'names' 字段
                updated_names, remaining_message = self.extract_multiple_names_from_text(
                    original_names, translated_text_full
                )
                text = {"names": updated_names, "message": remaining_message}

            # --- 如果 'names' 未被处理，则检查 'name' ---
            elif text is None and item.get_extra("name"):
                # 处理 'name' 字段（使用原始逻辑）
                original_name = item.require_extra("name")
                # 处理前确保 name 不为空
                if original_name:
                    updated_name, remaining_message = self.extract_strings(
                        original_name, translated_text_full
                    )
                    text = {"name": updated_name, "message": remaining_message}
                else: # 处理 'name' 属性存在但为空的情况
                    text = {"message": translated_text_full}

            # --- 后备处理：没有 'name' 或 'names' ---
            # 如果 text 仍然是 None，表示既没有找到 'names' 也没有找到 'name' 或它们未被成功处理
            if text is None:
                text = {"message": translated_text_full}

            output_list.append(text)

        # --- 写入文件 ---
        json_content = json.dumps(output_list, ensure_ascii=False, indent=4)
        translation_file_path.write_text(json_content, encoding="utf-8")


    def extract_multiple_names_from_text(self, original_names: list[str], dialogue: str) -> tuple[list[str], str]:
        """
        从对话字符串的开头提取多个方括号括起来的名称，
        基于 original_names 列表中的名称数量。

        Args:
            original_names: 原始名称列表（用于确定数量）。
            dialogue: 翻译后的文本，可能以方括号括起来的名称开头。

        Returns:
            一个元组，包含：
            - list[str]: 提取出的名称列表（如果提取失败则为原始名称列表）。
            - str: 提取名称后剩余的对话文本。
        """
        num_names_to_extract = len(original_names) # 需要提取的名称数量
        extracted_names = []
        current_pos = 0
        last_bracket_end = 0

        for i in range(num_names_to_extract):
            # 查找下一个潜在名称块的开始位置 '['，跳过前导空格
            start_bracket_pos = -1
            temp_pos = current_pos
            while temp_pos < len(dialogue):
                if dialogue[temp_pos] == '[':
                    start_bracket_pos = temp_pos
                    break
                elif not dialogue[temp_pos].isspace():
                    # 在找到 '[' 之前遇到了非空白字符，此模式的提取失败
                    return original_names, dialogue # 回退到原始值
                temp_pos += 1

            if start_bracket_pos == -1:
                 # 未找到足够的起始方括号 '['
                return original_names, dialogue # 回退到原始值

            # 查找对应的结束方括号 ']'
            end_bracket_pos = dialogue.find("]", start_bracket_pos + 1)
            if end_bracket_pos == -1:
                # 未找到结束方括号 ']'
                return original_names, dialogue # 回退到原始值

            # 提取名称内容
            name_content = dialogue[start_bracket_pos + 1 : end_bracket_pos]
            extracted_names.append(name_content)

            # 更新下一次搜索的位置
            current_pos = end_bracket_pos + 1
            last_bracket_end = current_pos # 记录最后一个方括号结束的位置

        # 提取完所有名称后，剩余的对话从最后一个方括号之后开始
        remaining_dialogue = dialogue[last_bracket_end:].lstrip()

        # 检查是否成功提取了预期数量的名称
        if len(extracted_names) == num_names_to_extract:
            return extracted_names, remaining_dialogue
        else:
            # 如果出现问题则回退（应该在前面被捕获，但作为安全措施）
            return original_names, dialogue


    # 处理 'name' 字段的情况
    def extract_strings(self, name, dialogue):
        # 验证数据类型
        if not isinstance(dialogue, str) or not isinstance(name, str):
            return name, dialogue

        # 仅当对话以"["开头时才处理
        if not dialogue.startswith("["):
            return name, dialogue

        end_pos = -1  # 初始化结束位置为-1（表示未找到）

        # 优先策略：尝试匹配与原name嵌套层级一致的"]"
        # 这种策略可以正确处理 [[英雄]惊讶] 这样的情况
        count_in_name = name.count("]")
        required_closing_brackets = count_in_name + 1
        
        search_start_pos = 0
        temp_end_pos = -1
        found_brackets = 0
        for _ in range(required_closing_brackets):
            # 从上一个找到的位置之后开始搜索
            pos = dialogue.find("]", search_start_pos)
            if pos == -1:
                # 如果找不到足够数量的"]"，说明优先策略失败
                found_brackets = -1  # 标记为失败
                break
            temp_end_pos = pos
            found_brackets += 1
            search_start_pos = pos + 1
        
        # 如果优先策略成功，则使用其结果
        if found_brackets == required_closing_brackets:
            end_pos = temp_end_pos

        # 回退策略：如果优先策略失败 (end_pos 仍然是 -1)，则回退为查找第一个 "]"
        if end_pos == -1:
            end_pos = dialogue.find("]")

        # 如果最终找到了一个有效的结束位置（无论是通过优先策略还是回退策略）
        # end_pos > 0 确保了不是空名字，如 "[]text"
        if end_pos > 0:
            extracted_name = dialogue[1:end_pos]
            remaining_dialogue = dialogue[end_pos + 1:].lstrip()
            return extracted_name, remaining_dialogue

        # 如果两种策略都失败了（例如，对话是"["但没有"]"），则返回原值
        return name, dialogue

    @classmethod
    def get_project_type(self):
        return ProjectType.VNT



================================================
FILE: ModuleFolders/FileOutputer/VttWriter.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileOutputer.BaseWriter import (
    BaseTranslatedWriter,
    OutputConfig,
    PreWriteMetadata
)


class VttWriter(BaseTranslatedWriter):
    def __init__(self, output_config: OutputConfig):
        super().__init__(output_config)

    def on_write_translated(
        self, translation_file_path: Path, cache_file: CacheFile,
        pre_write_metadata: PreWriteMetadata,
        source_file_path: Path = None,
    ):
        # 头信息
        header = f"{cache_file.require_extra("top_text")}\n\n"
        output_lines = []
        for item in cache_file.items:
            block = []
            if "subtitle_number" in item.extra:
                block.append(str(item.require_extra("subtitle_number")))
            block.append(item.require_extra("subtitle_time"))
            block.append(item.final_text)
            output_lines.append("\n".join(block))
        translation_file_path.write_text(header + "\n\n\n".join(output_lines), encoding=pre_write_metadata.encoding)

    @classmethod
    def get_project_type(self):
        return ProjectType.VTT



================================================
FILE: ModuleFolders/FileOutputer/WriterUtil.py
================================================
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig

_AINIEE_CONFIG_INSTANCE: TaskConfig | None = None
"""Ainiee配置类单例实现"""


def get_ainiee_config():
    """获取Ainiee配置的全局单例实例"""
    global _AINIEE_CONFIG_INSTANCE
    if _AINIEE_CONFIG_INSTANCE is None:
        _AINIEE_CONFIG_INSTANCE = TaskConfig()
        # 加载配置文件
        _AINIEE_CONFIG_INSTANCE.initialize()
    return _AINIEE_CONFIG_INSTANCE


def release_ainiee_config():
    """释放Ainiee配置"""
    global _AINIEE_CONFIG_INSTANCE
    if _AINIEE_CONFIG_INSTANCE is not None:
        _AINIEE_CONFIG_INSTANCE = None
    return True



================================================
FILE: ModuleFolders/FileReader/AssReader.py
================================================
### AssReader.py

import re
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)

class AssReader(BaseSourceReader):
    """
    ASS (Advanced SubStation Alpha) 字幕文件读取器。
    能够解析 [Events] 部分，并智能分离行首的样式标签和待翻译的文本。
    行首的样式标签 (如 {\an8\fs20}) 会被移除并暂存，
    而文本内部的格式标签 (如用于变色的 {\c&...&}) 会被保留。
    """
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.ASS

    @property
    def support_file(self):
        return "ass"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        lines = [line.lstrip("\ufeff") for line in file_path.read_text(encoding=pre_read_metadata.encoding).splitlines()]

        items = []
        header_lines = []
        in_events_section = False
        
        num_dialogue_fields = 10
        
        dialogue_pattern = re.compile(r"^\s*Dialogue:", re.IGNORECASE)
        format_pattern = re.compile(r"^\s*Format:", re.IGNORECASE)
        
        # 修改点 1: 定义一个只匹配行首 ASS 标签的正则表达式
        # ^      - 匹配字符串的开始
        # (\{.*?\})+ - 匹配一个或多个连续的 {...} 块
        leading_ass_tags_pattern = re.compile(r'^(\{.*?\})+')

        for line in lines:
            stripped_line = line.strip()

            if stripped_line.lower() == '[events]':
                in_events_section = True
                header_lines.append(line)
                continue

            if in_events_section:
                if format_pattern.match(stripped_line):
                    try:
                        fields_str = stripped_line.split(':', 1)[1]
                        fields = [field.strip() for field in fields_str.split(',')]
                        num_dialogue_fields = len(fields)
                    except IndexError:
                        pass
                    header_lines.append(line)
                    continue
                
                if dialogue_pattern.match(line):
                    try:
                        parts = line.split(',', num_dialogue_fields - 1)
                        
                        if len(parts) == num_dialogue_fields:
                            prefix = ",".join(parts[:-1])
                            raw_text_with_tags = parts[-1]
                            
                            # --- 修改点 2: 智能分离行首标签和文本 ---
                            leading_tags = ""
                            text_for_translation = raw_text_with_tags
                            
                            match = leading_ass_tags_pattern.match(raw_text_with_tags)
                            if match:
                                # 如果匹配成功，提取行首标签
                                leading_tags = match.group(0)
                                # 剩余部分作为待翻译文本
                                text_for_translation = raw_text_with_tags[len(leading_tags):]

                            item = CacheItem(
                                source_text=text_for_translation,
                                extra={
                                    "dialogue_prefix": prefix,
                                    "leading_tags": leading_tags  # 存储行首标签
                                }
                            )
                            items.append(item)
                        else:
                            header_lines.append(line)
                    except (ValueError, IndexError):
                        header_lines.append(line)
                else:
                    header_lines.append(line)
            else:
                header_lines.append(line)
        
        cache_file = CacheFile(items=items)
        cache_file.extra['ass_header_footer'] = header_lines
        
        return cache_file


================================================
FILE: ModuleFolders/FileReader/AutoTypeReader.py
================================================
from collections import Counter, defaultdict
from functools import lru_cache, partial
from pathlib import Path
from typing import Callable, Iterable, Type

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata,
    ReaderInitParams
)


class AutoTypeReader(BaseSourceReader):
    def __init__(
        self, input_config: InputConfig,
        reader_factories: Iterable[Callable[..., BaseSourceReader]],
        reader_init_params_factory: Callable[[str], ReaderInitParams]
    ):
        super().__init__(input_config)
        self.reader_factories = list(reader_factories)
        self.reader_init_params_factory = reader_init_params_factory
        self._readers: dict[str, BaseSourceReader] = {}
        self._active_readers = set()

        self._initialize_readers()

        # 在这里重载是为了避免lru_cache内存泄漏
        self.get_file_project_type = lru_cache(maxsize=1)(self.__get_file_project_type)

    @classmethod
    def get_infer_method_id(cls, reader_class: Type[BaseSourceReader]):
        # 这里未实例化所以用support_file的字节码判断
        # 重载以下任意方法都能避免歧义，但推荐重载support_file和can_read_by_content
        return (
            id(reader_class.can_read),
            reader_class.support_file.fget.__code__.co_code,
            # 常量字符串不包含在co_code中，这里增加常量的判断
            reader_class.support_file.fget.__code__.co_consts,
            id(reader_class.can_read_by_extension),
            id(reader_class.can_read_by_content),
        )

    @classmethod
    def verify_reader_factories(cls, reader_factories: Iterable[Callable[..., BaseSourceReader]]):
        """检验对于同一种后缀的文件的reader是否存在歧义"""
        # 根据
        infer_method_cnts = Counter(
            cls.get_infer_method_id(cls._get_reader_class(reader_factory))
            for reader_factory in reader_factories
        )
        ambiguous_readers = defaultdict(list)
        for reader_factory in reader_factories:
            reader_class = cls._get_reader_class(reader_factory)
            infer_method_id = cls.get_infer_method_id(reader_class)

            if infer_method_cnts[infer_method_id] > 1:
                ambiguous_readers[infer_method_id].append(reader_class)

        if ambiguous_readers:
            ambiguous_readers_msg = '\n'.join(str(reader_class_list) for reader_class_list in ambiguous_readers.values())
            raise ValueError(f"以下reader在识别文件方面存在歧义，请检查是否重载support_file或can_read_by_content方法：\n{ambiguous_readers_msg}")

    @classmethod
    def _get_reader_class(cls, reader_factory) -> Type[BaseSourceReader]:
        if isinstance(reader_factory, partial):
            return reader_factory.func
        elif issubclass(reader_factory, BaseSourceReader):
            return reader_factory
        else:
            raise ValueError(f"不支持的reader工厂`{reader_factory}`")

    def _initialize_readers(self):
        for reader_factory in self.reader_factories:
            reader_class = self._get_reader_class(reader_factory)
            if reader_class is AutoTypeReader:
                continue
            reader_init_params = self.reader_init_params_factory(reader_class.get_project_type())
            reader = reader_factory(**reader_init_params)
            self._readers[reader_class.get_project_type()] = reader
        self._support_files = set(reader.support_file for reader in self._readers.values())

    def __exit__(self, exc_type, exc, exc_tb):
        errors = []
        for project_type in list(self._active_readers):
            try:
                reader = self._readers[project_type]
                reader.__exit__(exc_type, exc, exc_tb)
            except Exception as e:
                errors.append(f"释放{reader}失败: {str(e)}")
            finally:
                self._active_readers.discard(project_type)  # 确保移除
        if errors:
            raise RuntimeError("释放时发生异常:\n" + "\n".join(errors))

    @classmethod
    def get_project_type(cls):
        return ProjectType.AUTO_TYPE

    @property
    def support_file(self):
        return '*'

    def _get_extension(self, file_path: Path):
        return file_path.suffix.lstrip(".")

    def can_read_by_extension(self, file_path: Path) -> bool:
        return self._get_extension(file_path) in self._support_files

    def can_read_by_content(self, file_path: Path) -> bool:
        return self.get_file_project_type(file_path) is not None

    def read_source_file(self, file_path: Path) -> CacheFile:
        project_type = self.get_file_project_type(file_path)
        if not project_type or project_type not in self._readers:
            return CacheFile()
        reader = self._readers[project_type]
        if reader not in self._active_readers:
            reader.__enter__()  # 实际使用时才申请资源
            self._active_readers.add(reader.get_project_type())
        return reader.read_source_file(file_path)

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError()

    def __get_file_project_type(self, file_path: Path):
        extension = self._get_extension(file_path)
        # reader数量较少，不增加support_file为key的字典，减少代码复杂度
        for reader in self._readers.values():
            if reader.support_file == extension and reader.can_read(file_path, fast=False):
                return reader.get_file_project_type(file_path)
        return None

    @property
    def exclude_rules(self) -> list[str]:
        rules = []
        for reader in self._readers.values():
            rules.extend(reader.exclude_rules)
        return rules



================================================
FILE: ModuleFolders/FileReader/BabeldocPdfReader.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileAccessor.BabeldocPdfAccessor import BabeldocPdfAccessor
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class BabeldocPdfReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig, tmp_directory='babeldoc_cache'):
        super().__init__(input_config)
        self.tmp_directory = tmp_directory
        
        # 获取输入路径
        root_path = input_config.input_root
        # 如果输入路径是文件（例如用户直接选择了 .pdf 文件），则使用该文件所在的文件夹作为缓存根目录
        if root_path.is_file():
            root_path = root_path.parent
            
        abs_tmp_directory = root_path / self.tmp_directory

        self.file_accessor = BabeldocPdfAccessor(abs_tmp_directory, None)

    @classmethod
    def get_project_type(self):
        return ProjectType.BABELDOC_PDF

    @property
    def support_file(self):
        return 'pdf'

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        source_texts = self.file_accessor.read_content(file_path)
        return CacheFile(items=[
            CacheItem(source_text=line) for line in source_texts
        ])

    @property
    def exclude_rules(self):
        return [f"{self.tmp_directory}/*"]


================================================
FILE: ModuleFolders/FileReader/BaseReader.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/FileReader/DirectoryReader.py
================================================
import fnmatch
from collections import defaultdict
from pathlib import Path
from typing import Callable
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import CacheProject
from ModuleFolders.FileReader import ReaderUtil
from ModuleFolders.FileReader.BaseReader import BaseSourceReader
from ModuleFolders.FileReader.ReaderUtil import make_final_detect_text


class DirectoryReader:
    def __init__(self, create_reader: Callable[[], BaseSourceReader], exclude_rules: list[str]):
        self.create_reader = create_reader  # 工厂函数
        self.exclude_files = set()
        self.exclude_paths = set()
        self._update_exclude_rules(exclude_rules)

    def _update_exclude_rules(self, exclude_rules):
        self.exclude_files.update({rule for rule in exclude_rules if "/" not in rule})
        self.exclude_paths.update({rule for rule in exclude_rules if "/" in rule})

    def is_exclude(self, file_path: Path, source_directory: Path):
        if any(fnmatch.fnmatch(file_path.name, rule) for rule in self.exclude_files):
            return True

        # 只有在 source_directory 有效时才计算相对路径
        if source_directory and source_directory.is_dir():
            try:
                rel_path_str = str(file_path.relative_to(source_directory))
                if any(fnmatch.fnmatch(rel_path_str, pattern) for pattern in self.exclude_paths):
                    return True
            except ValueError:
                # 如果不在同一驱动器或路径下，会引发ValueError，此时认为不排除
                pass
        return False

    # 2025年9月8日增加单文件输入支持
    # 树状读取文件夹内同类型文件
    def read_source_directory(self, input_path: Path) -> CacheProject:
        """
        读取文件夹或单个文件，检测每个文件的编码，并在最后设置项目的默认编码。
        此函数现在支持单个文件路径和目录路径。
        Args:
            input_path: 源文件或目录的路径
        Returns:
            CacheProject: 包含项目信息和文件内容
        """
        cache_project = CacheProject()  # 项目头信息
        text_index = 1  # 文本索引
        # 语言统计：{file_path: {lang_code: (count, total_confidence)}}
        language_stats = defaultdict(lambda: defaultdict(lambda: [0, 0.0]))
        file_valid_items_count = defaultdict(int)
        source_texts = defaultdict(list[str])

        # 根据路径类型确定要处理的文件列表和基础目录
        files_to_process = []
        base_directory = None

        # 如果是目录，递归获取所有文件
        if input_path.is_dir():
            base_directory = input_path
            for root, _, files in base_directory.walk():
                for file in files:
                    files_to_process.append(root / file)
        # 如果是单个文件，直接处理该文件
        elif input_path.is_file():
            base_directory = input_path.parent
            files_to_process.append(input_path)
        # 如果路径不存在或不是文件/目录，则返回空项目
        else:
            print(f"Warning: Input path '{input_path}' does not exist or is not a file/directory.")
            return cache_project

        # 创建reader实例
        with self.create_reader() as reader:
            self._update_exclude_rules(reader.exclude_rules)
            cache_project.project_type = reader.get_project_type()

            # 遍历预先生成的文件列表
            for file_path in files_to_process:
                # 检查是否被排除，以及是否是目标类型文件
                if not self.is_exclude(file_path, base_directory) and reader.can_read(file_path):

                    # 读取单个文件的文本信息，并添加其他信息
                    cache_file = reader.read_source_file(file_path)
                    # 空文件跳过
                    if not cache_file:
                        continue

                    # 使用 base_directory 计算相对路径
                    cache_file.storage_path = str(file_path.relative_to(base_directory))
                    cache_file.file_project_type = reader.get_file_project_type(file_path)

                    for item in cache_file.items:
                        item.text_index = text_index
                        item.model = 'none'
                        text_index += 1

                        # 统计每行的语言信息
                        lang_code = item.lang_code
                        # 只统计检测到有效语言代码的item行
                        if lang_code:
                            lang_confidence = lang_code[1]
                            # 更新语言统计：[计数, 累计置信度]
                            stats = language_stats[cache_file.storage_path][lang_code[0]]
                            stats[0] += 1  # 增加计数
                            stats[1] += lang_confidence  # 累加置信度
                            # 累计有效项目总数
                            file_valid_items_count[cache_file.storage_path] += 1
                            # 添加行至后续使用
                            final_detect_text = make_final_detect_text(item)
                            if final_detect_text:
                                source_texts[cache_file.storage_path].append(final_detect_text)

                    # 只有当文件有有效内容时才添加到项目中
                    if cache_file.items:
                        cache_project.add_file(cache_file)
                        # 补充缺失的字典项（仅对已添加到项目的文件）
                        if not language_stats[cache_file.storage_path]:
                            language_stats[cache_file.storage_path] = defaultdict(lambda: [0, 0.0])

        # 处理语言统计结果
        language_counter = defaultdict(list)
        low_confidence_language_counter = defaultdict(list)

        for file_path, lang_stats in language_stats.items():
            # 只有存在有效项目的文件才进行处理
            current_file_items_count = file_valid_items_count[file_path]
            if current_file_items_count > 0:
                high_threshold = max(current_file_items_count * 0.1, min(current_file_items_count, 3))  # 有效项目总数的10%
                mid_threshold = max(current_file_items_count * 0.05, min(current_file_items_count, 2))  # 有效项目总数的5%
                low_threshold = max(current_file_items_count * 0.01, 1)  # 有效项目总数的1%

                # 先计算所有语言的平均置信度
                all_langs = []
                for lang, (count, total_confidence) in lang_stats.items():
                    avg_confidence = total_confidence / count
                    all_langs.append((lang, count, avg_confidence))

                # 按出现次数降序排序，相同次数按置信度降序排序
                sorted_langs = sorted(all_langs, key=lambda x: (-x[1], -x[2]))

                # 筛选高置信度语言
                high_confidence_langs = []
                for lang, count, avg_confidence in sorted_langs:
                    # 应用筛选条件：次数超过阈值且平均置信度大于等于0.82
                    if count >= high_threshold and avg_confidence >= 0.82 or \
                            count >= mid_threshold and avg_confidence >= 0.92 or \
                            count >= low_threshold and avg_confidence >= 0.96:
                        high_confidence_langs.append((lang, count, avg_confidence))

                # 获取有效语言列表
                hc_langs_set = {lang for lang, count, avg_confidence in high_confidence_langs}

                # 如果到这里了还没有high_confidence_langs的结果，使用mp对所有有效文字进行检测
                if not high_confidence_langs:
                    if len(source_texts[file_path]) > 0:
                        mp_langs, mp_score, _ = ReaderUtil.detect_language_with_mediapipe(
                            [CacheItem(source_text='\n'.join(source_texts[file_path]))], 0, None
                        )[0]
                        if mp_score >= 0.82:
                            # 添加到language_counter
                            language_counter[file_path] = [(mp_langs[0], len(source_texts[file_path]), mp_score)]
                            # 添加到 hc_langs_set
                            hc_langs_set.add(mp_langs[0])
                    else:
                        language_counter[file_path] = [('un', len(source_texts[file_path]), -1.0)]
                else:
                    language_counter[file_path] = high_confidence_langs

                # 筛选低置信度语言
                low_confidence_langs = []
                for lang, count, avg_confidence in sorted_langs:
                    # 应用筛选条件：出现次数小于高置信度或者平均置信度小于0.82
                    # (count < high_threshold or avg_confidence < 0.82) and
                    if lang not in hc_langs_set:
                        low_confidence_langs.append((lang, count, avg_confidence))

                if low_confidence_langs:
                    low_confidence_language_counter[file_path] = low_confidence_langs
            else:
                language_counter[file_path] = [('un', 0, -1.0)]

        # 处理未出现在language_counter中的文件
        valid_file_paths = set(file_valid_items_count.keys())
        files_in_counter = set(language_counter.keys())
        missing_files = valid_file_paths - files_in_counter

        # 为未统计到有效语言的文件添加默认值
        for file_path in missing_files:
            # un表示未知语言
            language_counter[file_path] = [('un', 0, -1.0)]

        # 为对应的CacheFile添加语言统计属性（添加安全检查）
        for file_path, langs in language_counter.items():
            cache_file = cache_project.get_file(file_path)
            if cache_file:
                cache_file.language_stats = langs
            else:
                print(f"Warning: File '{file_path}' not found in cache_project when setting language_stats")

        # 添加低置信度语言统计（添加安全检查）
        for file_path, langs in low_confidence_language_counter.items():
            cache_file = cache_project.get_file(file_path)
            if cache_file:
                cache_file.lc_language_stats = langs
            else:
                print(f"Warning: File '{file_path}' not found in cache_project when setting lc_language_stats")

        # 释放语言检测器
        ReaderUtil.close_lang_detector()

        # 自动生成工程名字
        self._generate_project_name(cache_project)

        return cache_project

    # 自动生成工程名字方法
    def _generate_project_name(self, cache_project: CacheProject):
        """
        根据读取的文件列表，自动生成工程名字。
        """
        # 配置的参数
        CHARS_PER_FILENAME = 5
        SEPARATOR = '&&'
        MAX_FILES_FOR_NAME = 4

        # 从字典中获取所有 CacheFile 对象，并转换为列表
        files_list = list(cache_project.files.values())

        if not files_list:
            cache_project.project_name = "EmptyProject"
            return

        if len(files_list) == 1:
            # 单个文件：直接使用文件名（不含扩展名）
            # 使用列表索引 [0] 来访问第一个元素
            # 当输入是单个文件时, storage_path 就是文件名
            file_path = Path(files_list[0].storage_path)
            cache_project.project_name = file_path.stem
        else:
            # 多个文件：组合文件名
            name_parts = []
            # 对列表进行切片
            for cache_file in files_list[:MAX_FILES_FOR_NAME]:
                # storage_path 是相对路径，需要从中获取文件名
                file_stem = Path(cache_file.storage_path).stem
                name_parts.append(file_stem[:CHARS_PER_FILENAME])

            cache_project.project_name = SEPARATOR.join(name_parts)



================================================
FILE: ModuleFolders/FileReader/DocxReader.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileAccessor.DocxAccessor import DocxAccessor
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class DocxReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)
        self.file_accessor = DocxAccessor()

    @classmethod
    def get_project_type(cls):
        return ProjectType.DOCX

    @property
    def support_file(self):
        return 'docx'

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        xml_soup = self.file_accessor.read_content(file_path)
        paragraphs = xml_soup.find_all('w:t')
        # 过滤掉空的内容
        filtered_matches = (match.string for match in paragraphs if isinstance(match.string, str) and match.string.strip())
        items = [
            CacheItem(source_text=str(text)) for text in filtered_matches
            if not (text == "" or text == "\n" or text == " " or text == '\xa0')
        ]
        return CacheFile(items=items)



================================================
FILE: ModuleFolders/FileReader/EpubReader.py
================================================
import re
from pathlib import Path

from bs4 import BeautifulSoup, Tag, NavigableString


from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileAccessor.EpubAccessor import EpubAccessor
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class EpubReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)
        self.file_accessor = EpubAccessor()

    @classmethod
    def get_project_type(cls):
        return ProjectType.EPUB

    @property
    def support_file(self):
        return 'epub'

    # 正则字典，只包含成对标签，暂不考虑自闭合标签
    TAG_PATTERNS_LIST = [
        ("heading", r"<h[1-7]\b[^>]*>(.*?)</h[1-7]>", []),
        ("li", r"<li\b[^>]*>(.*?)</li>", ['p']), # 有些p标签内容嵌套在li标签里
        ("p", r"<p\b[^>]*>(.*?)</p>", []),

        ("blockquote", r"<blockquote\b[^>]*>(.*?)</blockquote>", []),
        ("text", r"<text\b[^>]*>(.*?)</text>", []),
        ("td", r"<td\b[^>]*>(.*?)</td>", []),

        # div标签要放在最后面，这是提取不到前面任何文本内容再考虑的标签
        ("div", r"<div\b[^>]*>(.*?)</div>", ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'h7', 'li', 'text', 'blockquote', 'td']),
    ]

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:

        items = []
        for item_id, _, html_content in self.file_accessor.read_content(file_path):
            for tag_type, pattern, forbidden_tags in self.TAG_PATTERNS_LIST:
                # 使用 finditer 查找所有匹配项，可以迭代处理
                for match in re.finditer(pattern, html_content, re.DOTALL):
                    html_text_A = match.group(0)  # 完整匹配到的HTML标签

                    # 针对同名嵌套标签内容的处理。正则提取时标签提前闭合，而造成的提取错误。只提取同名子标签的内容，放弃父级标签的内容
                    html_text_B = self.extract_inner_html_from_incomplete_tag(html_text_A)

                    # 处理多层嵌套标签的情况，找到存储文本内容的标签
                    tag_type, html_text_C = self.extract_epub_content_refined(html_text_B)
                    if not html_text_C: 
                        continue

                    # 提取纯文本，并处理嵌套标签
                    soup = BeautifulSoup(html_text_C, 'html.parser')
                    text_content = soup.get_text(strip=True)

                    if not text_content:  # 检查一下是否提取到空文本内容
                        continue

                    if forbidden_tags:
                        # 检查是否包含禁止的子标签
                        forbidden_soup_elemnt = soup.find(forbidden_tags)
                        if forbidden_soup_elemnt is not None:
                            continue
                        
                    extra = {
                        "original_html": html_text_C,
                        "tag_type": tag_type,
                        "item_id": item_id,
                    }
                    items.append(CacheItem(source_text=text_content, extra=extra))
        return CacheFile(items=items)

    # 提取最内层包含文本的标签及其内容（改进点：可以考虑保留部分标签的内容，比如span）
    def extract_epub_content_refined(self,html_string: str) :
        """
        从HTML字符串中提取最内层包含实际内容的标签及其原始字符串
        
        参数:
            html_string: 待解析的HTML片段字符串
            
        返回:
            元组(标签名, 标签原始完整字符串) 或 (None, None)
            保持原始字符串中的属性顺序和格式
        """
        if not html_string or not html_string.strip():
            return None, None

        # 首先用BeautifulSoup分析结构
        soup = BeautifulSoup(html_string.strip(), 'html.parser')
        
        # 查找第一个实际标签
        top_tag = None
        for element in soup.contents:
            if isinstance(element, Tag):
                top_tag = element
                break

        if not top_tag:
            return None, None

        # 迭代查找最具体的标签
        current_tag = top_tag
        while True:
            text_containing_children = []
            for child in current_tag.children:
                has_meaningful_text = False
                if isinstance(child, NavigableString):
                    if child.strip():
                        has_meaningful_text = True
                elif isinstance(child, Tag):
                    if child.get_text(strip=True):
                        has_meaningful_text = True

                if has_meaningful_text:
                    text_containing_children.append(child)

            num_text_children = len(text_containing_children)

            if num_text_children == 1:
                the_child = text_containing_children[0]
                if isinstance(the_child, Tag):
                    current_tag = the_child
                    continue
                else:
                    break
            else:
                break

        # 获取标签在原始字符串中的位置
        original_html = html_string.strip()
        tag_name = current_tag.name
        
        # 构建正则表达式匹配原始标签
        # 匹配开始标签（包括所有属性）
        start_tag_pattern = re.compile(
            r'<{0}[^>]*>'.format(tag_name), 
            re.IGNORECASE
        )
        
        # 匹配整个标签（包括内容）
        full_tag_pattern = re.compile(
            r'<{0}[^>]*>.*?</{0}>'.format(tag_name), 
            re.IGNORECASE | re.DOTALL
        )
        
        # 在原始HTML中查找匹配
        start_tag_match = start_tag_pattern.search(original_html)
        if not start_tag_match:
            return current_tag.name, str(current_tag)  # 回退到BeautifulSoup生成
        
        # 从匹配位置开始查找完整标签
        remaining_html = original_html[start_tag_match.start():]
        full_tag_match = full_tag_pattern.search(remaining_html)
        
        if full_tag_match:
            original_tag = full_tag_match.group(0)
            return tag_name, original_tag
        else:
            # 如果正则匹配失败，回退到BeautifulSoup生成
            return current_tag.name, str(current_tag)
        
    # 提取同名嵌套标签的完整子标签内容
    def extract_inner_html_from_incomplete_tag(self,html_string: str) -> str:
        """
        识别残缺的非闭合标签内容，并自动提取第一个符合条件的同名子标签的原始内容。
        如果不是残缺标签，或者没有找到合适的子标签，则返回原内容。
        提取子标签时，使用正则表达式以获取原始字符串内容。

        Args:
            html_string: HTML内容字符串

        Returns:
            处理后的HTML内容 (可能是原始子标签的字符串，或原输入内容)
        """
        # 确定第一个标签的名称
        first_tag_name_match = re.match(rf'<([a-zA-Z][a-zA-Z0-9]*)(?![a-zA-Z0-9\-_])', html_string)
        if not first_tag_name_match:
            # 如果字符串不是以一个可识别的标签开头，则返回原内容
            return html_string

        tag_name = first_tag_name_match.group(1)

        # 构建用于查找开标签和闭标签的正则表达式 (忽略大小写)
        open_tag_pattern = rf'<{tag_name}(?![a-zA-Z0-9\-_])[^>]*>'
        close_tag_pattern = rf'</{tag_name}>'

        # 统计开标签和闭标签的数量
        open_tags_found = re.findall(open_tag_pattern, html_string, re.IGNORECASE)
        close_tags_found = re.findall(close_tag_pattern, html_string, re.IGNORECASE)

        # 如果开标签数量大于闭标签数量，则认为可能是残缺标签
        if len(open_tags_found) > len(close_tags_found):
            # 找到第一个主开标签的结束位置，以便从其后开始搜索子标签
            first_actual_open_tag_match = re.search(open_tag_pattern, html_string, re.IGNORECASE)
            
            if not first_actual_open_tag_match:
                return html_string 
                
            # 从第一个主开标签之后的内容中搜索子标签
            search_start_offset = first_actual_open_tag_match.end()
            remaining_html = html_string[search_start_offset:]

            # 构建正则表达式以查找第一个完整的、同名的子标签
            inner_complete_tag_pattern = rf'(<{tag_name}(?![a-zA-Z0-9\-_])[^>]*>.*?</{tag_name}>)'
            
            match_inner_complete_tag = re.search(
                inner_complete_tag_pattern,
                remaining_html,
                re.DOTALL | re.IGNORECASE  
            )

            if match_inner_complete_tag:
                # 如果找到，返回该子标签的完整原始内容
                return match_inner_complete_tag.group(1)
        
        # 如果标签不是残缺的，或者没有找到符合条件的子标签，则返回原内容
        return html_string



================================================
FILE: ModuleFolders/FileReader/FileReader.py
================================================
import os
from pathlib import Path
from functools import partial
from typing import Type

from ModuleFolders.Cache.CacheManager import CacheManager
from ModuleFolders.FileReader.AutoTypeReader import AutoTypeReader
from ModuleFolders.FileReader.BaseReader import BaseSourceReader, InputConfig, ReaderInitParams
from ModuleFolders.FileReader.DirectoryReader import DirectoryReader
from ModuleFolders.FileReader.MToolReader import MToolReader
from ModuleFolders.FileReader.OfficeConversionReader import OfficeConversionDocReader
from ModuleFolders.FileReader.ParatranzReader import ParatranzReader
from ModuleFolders.FileReader.TPPReader import TPPReader
from ModuleFolders.FileReader.VntReader import VntReader
from ModuleFolders.FileReader.SrtReader import SrtReader
from ModuleFolders.FileReader.VttReader import VttReader
from ModuleFolders.FileReader.LrcReader import LrcReader
from ModuleFolders.FileReader.AssReader import AssReader
from ModuleFolders.FileReader.TxtReader import TxtReader
from ModuleFolders.FileReader.EpubReader import EpubReader
from ModuleFolders.FileReader.DocxReader import DocxReader
from ModuleFolders.FileReader.MdReader import MdReader
from ModuleFolders.FileReader.RenpyReader import RenpyReader
from ModuleFolders.FileReader.TransReader import TransReader
from ModuleFolders.FileReader.I18nextReader import I18nextReader
from ModuleFolders.FileReader.PoReader import PoReader
from ModuleFolders.FileReader.BabeldocPdfReader import BabeldocPdfReader
from PluginScripts.IOPlugins.CustomRegistry import CustomReader


# 文件读取器(分发入口)
class FileReader():
    def __init__(self):
        self.reader_factory_dict = {}  # 工厂地图
        self._register_system_reader()

    # 初始化时，注册所有内置支持的文件/项目类型。
    def _register_system_reader(self):
        self.register_reader(TxtReader)
        self.register_reader(EpubReader)
        self.register_reader(DocxReader)
        self.register_reader(SrtReader)
        self.register_reader(VttReader)
        self.register_reader(LrcReader)
        self.register_reader(AssReader)
        self.register_reader(MdReader)
        self.register_reader(TPPReader)
        self.register_reader(TransReader)
        self.register_reader(MToolReader)
        self.register_reader(RenpyReader)
        self.register_reader(VntReader)
        self.register_reader(I18nextReader)
        self.register_reader(PoReader)
        self.register_reader(ParatranzReader)
        self.register_reader(OfficeConversionDocReader)
        self.register_reader(BabeldocPdfReader)

        # 注册插件式 Reader
        CustomReader.register_readers(self)

        # 检验是否有歧义
        AutoTypeReader.verify_reader_factories(self.reader_factory_dict.values())
        # 由于values是引用，最先注册和最后注册都一样
        self.register_reader(AutoTypeReader, reader_factories=self.reader_factory_dict.values())

    def register_reader(self, reader_class: Type[BaseSourceReader], **init_kwargs):
        """如果reader可注册，则根据project_type进行注册"""
        if reader_class.is_environ_supported():
            reader_factory = partial(reader_class, **init_kwargs) if init_kwargs else reader_class
            self.reader_factory_dict[reader_class.get_project_type()] = reader_factory

    def _get_reader_init_params(self, project_type, label_input_path):
        input_config = InputConfig(Path(label_input_path))
        if project_type == AutoTypeReader.get_project_type():
            reader_init_params_factory = partial(self._get_reader_init_params, label_input_path=label_input_path)
            return ReaderInitParams(input_config=input_config, reader_init_params_factory=reader_init_params_factory)
        return ReaderInitParams(input_config=input_config)

    # 根据文件类型读取文件，并返回缓存对象
    def read_files (self,translation_project,label_input_path, exclude_rule_str):
        # 检查传入的项目类型是否已经被注册。
        if translation_project in self.reader_factory_dict:
            # 获取初始化参数
            reader_init_params = self._get_reader_init_params(translation_project, label_input_path)
            # 绑定配置，使工厂变成无参
            reader_factory = partial(self.reader_factory_dict[translation_project], **reader_init_params)
            # 创建对象，接收配置好、无参数的 reader_factory
            reader = DirectoryReader(reader_factory, exclude_rule_str.split(','))
            # 再次获取路径对象
            source_directory = Path(label_input_path)
            # 读取整个输入目录,生成缓存对象
            cache_list = reader.read_source_directory(source_directory)
        elif translation_project == "Ainiee_cache":
            cache_list = self.read_cache_files(folder_path=label_input_path)
        return cache_list


    #读取缓存文件
    def read_cache_files(self,folder_path):
        # 获取文件夹中的所有文件
        files = os.listdir(folder_path)

        # 查找以 "CacheData" 开头且以 ".json" 结尾的文件
        json_files = [file for file in files if file.startswith("AinieeCacheData") and file.endswith(".json")]

        if not json_files:
            print(f"Error: No 'CacheData' JSON files found in folder '{folder_path}'.")
            return None

        # 选择第一个符合条件的 JSON 文件
        json_file_path = os.path.join(folder_path, json_files[0])

        # 读取 JSON 文件内容
        return CacheManager.read_from_file(json_file_path)

    def get_support_project_types(self) -> list[str]:
        # 把自动检测类型放到第一个
        return [
            AutoTypeReader.get_project_type(),
            *(project_type for project_type in self.reader_factory_dict.keys() if project_type != AutoTypeReader.get_project_type())
        ]



================================================
FILE: ModuleFolders/FileReader/I18nextReader.py
================================================
import json
from pathlib import Path
from typing import Any, Dict, List, Tuple

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class I18nextReader(BaseSourceReader):
    """
    读取 i18next JSON 文件 (支持嵌套结构)，
    并将原始路径信息存储在 CacheItem 的 'i18next_path' 属性中。
    """
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.I18NEXT

    @property
    def support_file(self):
        return "json"

    @staticmethod
    def _is_i18next_like_structure(data: Any) -> bool:
        """递归检查数据结构是否类似 i18next JSON (字典或字符串叶子)。"""
        if isinstance(data, str):
            return True
        if isinstance(data, dict):
            if not data: return True
            return all(isinstance(k, str) and I18nextReader._is_i18next_like_structure(v)
                       for k, v in data.items())
        # i18next 不应包含列表、数字等作为非叶子节点的值
        # 特殊情况：有时复数形式会用数组，但这里简化，只允许 string/dict
        return False

    def can_read_by_content(self, file_path: Path) -> bool:
        """检查文件内容是否符合 i18next JSON 的典型结构。"""
        content_str = file_path.read_text(encoding="utf-8", errors='ignore')
        if not content_str.strip(): return False
        content = json.loads(content_str)
        if not isinstance(content, dict): return False
        return I18nextReader._is_i18next_like_structure(content)


    def _flatten_json(self, data: Dict[str, Any], current_path: List[str] = []) -> List[Tuple[List[str], str]]:
        """
        递归地将嵌套字典扁平化为 (路径列表, 值) 的元组列表。
        """
        items = []
        for k, v in data.items():
            new_path = current_path + [k] # 构建新的路径列表
            if isinstance(v, dict):
                items.extend(self._flatten_json(v, new_path))
            elif isinstance(v, str):
                # 到达叶子节点（字符串），存储路径列表和值
                items.append((new_path, v))
                pass
        return items

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        """
        读取 i18next JSON 文件，提取所有嵌套的键值对，并存储路径信息。
        """
        items = []

        content = file_path.read_text(encoding=pre_read_metadata.encoding)
        json_data = json.loads(content)

        # 扁平化 JSON 获取 (路径列表, 值)
        flat_items_with_path = self._flatten_json(json_data)

        for path_list, value in flat_items_with_path:

            items.append(
                CacheItem(source_text=value, extra={"i18next_path": path_list})
            )

        return CacheFile(items=items)



================================================
FILE: ModuleFolders/FileReader/LrcReader.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/FileReader/MdReader.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)
from ModuleFolders.FileReader.TxtReader import TxtReader


class MdReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)
        self.txt_reader = TxtReader(input_config, None)  # 简单复用TxtReader，如有另外实现请删除

    def __enter__(self):
        self.txt_reader.__enter__()
        return super().__enter__()

    def __exit__(self, exc_type, exc, exc_tb):
        self.txt_reader.__exit__(exc_type, exc, exc_tb)
        return super().__exit__(exc_type, exc, exc_tb)

    @classmethod
    def get_project_type(cls):
        return ProjectType.MD

    @property
    def support_file(self):
        return "md"

    def read_source_file(self, file_path: Path) -> CacheFile:
        cache_file = self.txt_reader.read_source_file(file_path)
        for item in cache_file.items:
            item.set_extra("original_line", item.source_text)
        return cache_file

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError



================================================
FILE: ModuleFolders/FileReader/MToolReader.py
================================================
import json
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class MToolReader(BaseSourceReader):
    """读取Mtool json文件"""
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.MTOOL

    @property
    def support_file(self):
        return "json"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        items = []
        json_data = json.loads(file_path.read_text(encoding=pre_read_metadata.encoding))

        # 提取键值对
        for key, value in json_data.items():
            # 根据 JSON 文件内容的数据结构，获取相应字段值
            item = CacheItem(source_text=key, translated_text=value)
            items.append(item)
        return CacheFile(items=items)

    def can_read_by_content(self, file_path: Path) -> bool:
        # {"source_text1": "source_text1?", "source_text2": "source_text2?"}
        # 即使不是对应编码也不影key value的形式
        content = json.loads(file_path.read_text(encoding="utf-8", errors='ignore'))
        if not isinstance(content, dict):
            return False
        return all(isinstance(k, str) and isinstance(v, str) for k, v in content.items())



================================================
FILE: ModuleFolders/FileReader/OfficeConversionReader.py
================================================
import platform
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileConverter.OfficeFileConverter import OfficeFileConverter
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)
from ModuleFolders.FileReader.DocxReader import DocxReader


class OfficeConversionReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig, tmp_directory='office_cache') -> None:
        super().__init__(input_config)
        self.tmp_directory = tmp_directory
        self.tmp_file_type = '.docx'

        self.docx_reader = DocxReader(input_config)
        self.converter = OfficeFileConverter()

    def __enter__(self):
        self.docx_reader.__enter__()
        self.converter.__enter__()
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        self.converter.__exit__(exc_type, exc, exc_tb)
        self.docx_reader.__exit__(exc_type, exc, exc_tb)

    def read_source_file(self, file_path: Path) -> CacheFile:
        rel_path = file_path.relative_to(self.input_config.input_root)
        tmp_docx_path = (
            self.input_config.input_root / self.tmp_directory / rel_path
        ).with_suffix(self.tmp_file_type)
        if self.converter.can_convert(file_path, tmp_docx_path):
            if not tmp_docx_path.exists():
                self.converter.convert_file(file_path, tmp_docx_path)
            return self.docx_reader.read_source_file(tmp_docx_path)
        return CacheFile()

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        # 重载抽象方法，实际不需要使用
        raise NotImplementedError

    @classmethod
    def is_environ_supported(cls) -> bool:
        return platform.system() == 'Windows'

    @property
    def exclude_rules(self) -> list[str]:
        return [f'{self.tmp_directory}/*']


class OfficeConversionPdfReader(OfficeConversionReader):
    @property
    def support_file(self) -> str:
        return 'pdf'

    @classmethod
    def get_project_type(cls) -> str:
        return ProjectType.OFFICE_CONVERSION_PDF


class OfficeConversionDocReader(OfficeConversionReader):
    @property
    def support_file(self) -> str:
        return 'doc'

    @classmethod
    def get_project_type(cls) -> str:
        return ProjectType.OFFICE_CONVERSION_DOC



================================================
FILE: ModuleFolders/FileReader/ParatranzReader.py
================================================
import json
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class ParatranzReader(BaseSourceReader):
    """读取文件夹中树形结构Paratranz json 文件
        待处理的json接口例
        [
            {
                "key": "Activate",
                "original": "カードをプレイ",
                "translation": "出牌",
                "context": null,
                "stage": 1
            }
        ]
        缓存数据结构示例
        [
            {'project_type': 'Paratranz'},
            {'text_index': 1, 'text_classification': 0, 'translation_status': 0, 'source_text': 'しこトラ！',
                'translated_text': '无', 'storage_path': 'TrsData.json', 'file_name': 'TrsData.json', 'key': 'txtKey',
                'context': ''},
            {'text_index': 2, 'text_classification': 0, 'translation_status': 0, 'source_text': '室内カメラ',
                'translated_text': '无', 'storage_path': 'TrsData.json', 'file_name': 'TrsData.json', 'key': 'txtKey',
                'context': ''},
            {'text_index': 3, 'text_classification': 0, 'translation_status': 0, 'source_text': '室内カメラ',
                'translated_text': '无', 'storage_path': 'DEBUG Folder\\Replace the original text.json',
                'file_name': 'Replace the original text.json', 'key': 'txtKey', 'context': ''},
        ]
    """
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.PARATRANZ

    @property
    def support_file(self):
        return "json"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:

        json_list = json.loads(file_path.read_text(encoding=pre_read_metadata.encoding))

        items = []
        # 提取键值对
        for json_item in json_list:
            # 根据 JSON 文件内容的数据结构，获取相应字段值
            stage = json_item.get('stage', 0)
            if stage == 0:  # stage 0为未翻译，详见https://paratranz.cn/docs
                translation_status = TranslationStatus.UNTRANSLATED
            else:
                translation_status = TranslationStatus.TRANSLATED
            source_text = json_item.get('original', '')  # 获取原文，如果没有则默认为空字符串
            translated_text = json_item.get('translation', '')  # 获取翻译，如果没有则默认为空字符串
            extra = {
                "key": json_item.get('key', ''),  # 获取键值，如果没有则默认为空字符串
                "context": json_item.get('context', ''),  # 获取上下文信息，如果没有则默认为空字符串
            }
            item = CacheItem(
                source_text=source_text, translated_text=translated_text,
                translation_status=translation_status,  # 更新翻译状态
                extra=extra
            )
            items.append(item)
        return CacheFile(items=items)

    def can_read_by_content(self, file_path: Path) -> bool:
        # 即使不是对应编码也不影响英文的key
        content = json.loads(file_path.read_text(encoding='utf-8', errors='ignore'))
        if not isinstance(content, list):
            return False
        return all(isinstance(line, dict) and "original" in line for line in content)



================================================
FILE: ModuleFolders/FileReader/PoReader.py
================================================
import polib
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)

class PoReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)


    @classmethod
    def get_project_type(cls):
        return ProjectType.PO 

    @property
    def support_file(self):
        return "po"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        """
        读取并解析 .po 文件。
        """
        # polib 能够很好地处理编码，我们使用它来加载文件
        po_file = polib.pofile(str(file_path), encoding=pre_read_metadata.encoding)

        items = []
        for entry in po_file:
            # 跳过过时(obsolete)的条目和头部条目
            if entry.obsolete or not entry.msgid:
                continue

            # 将所有元数据存储在 extra 字典中，以便写回
            extra = {
                'msgctxt': entry.msgctxt,
                'msgid_plural': entry.msgid_plural,
                'comment': entry.comment,
                'tcomment': entry.tcomment,
                'occurrences': entry.occurrences,
                'flags': entry.flags,
                'previous_msgid': entry.previous_msgid,
                'previous_msgctxt': entry.previous_msgctxt,
                'linenum': entry.linenum
            }
            
            # source_text 就是 msgid
            # 对于复数形式，只翻译单数形式的 msgid。
            # 更复杂的复数处理需要修改 CacheItem 和翻译流程。
            item = CacheItem(source_text=entry.msgid, extra=extra)
            items.append(item)

        # 将文件级别的元数据（如文件头）保存在 CacheFile 的 extra 中
        file_extra = {
            'metadata': po_file.metadata,
            'header': po_file.header
        }
        
        return CacheFile(items=items, extra=file_extra)


================================================
FILE: ModuleFolders/FileReader/ReaderUtil.py
================================================
import os
import pathlib
import re
import sys
import time
from typing import Union

import chardet
import charset_normalizer
import rich
from bs4 import BeautifulSoup
from mediapipe.tasks.python import text, BaseOptions
from mediapipe.tasks.python.text import LanguageDetector

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem

_LANG_DETECTOR_INSTANCE: LanguageDetector | None = None
"""语言检测器单例实现"""

VARIOUS_LETTERS_RANGE = r'a-zA-Z\uFF21-\uFF3A\uFF41-\uFF5A'
"""标准字母与全角字母的范围"""
HAS_UNUSUAL_ENG_REGEX = re.compile(
    "^(?:"
    fr"(?=.*[_$])(?=.*[{VARIOUS_LETTERS_RANGE}\d])[{VARIOUS_LETTERS_RANGE}\d_$]+|"
    fr"\[[{VARIOUS_LETTERS_RANGE}\d_$]+]|"
    fr"\{{[{VARIOUS_LETTERS_RANGE}\d_$]+}}|"
    fr"(?=.*[{VARIOUS_LETTERS_RANGE}])(?=.*\d)[{VARIOUS_LETTERS_RANGE}\d]*|"
    "dummy"
    ")$"
)
"""20250723: fix #712"""
"""预编译正则 匹配包含 至少一个下划线和至少一个字母与数字且没有空白字符 或者 只由字母和数字组成且必须同时包含至少一个字母与数字 的字符串"""
CLEAN_TEXT_PATTERN = re.compile(
    fr'\\{{1,2}}[{VARIOUS_LETTERS_RANGE}]{{1,2}}\[\d+]|'
    r'if\(.{0,16}[vs]\[\d+].{0,16}\)|'
    r'\\n|'
    fr'[{VARIOUS_LETTERS_RANGE}]+\d+(?!\d*[{VARIOUS_LETTERS_RANGE}])'
)
"""修改后的预编译正则，移除了标签模式"""

JS_VAR_PATTERN = re.compile(
    r'\b[a-zA-Z_$][a-zA-Z0-9_$]*\.[a-zA-Z_$][a-zA-Z0-9_$]*'
)
"""预编译正则 匹配js变量模式"""
TAG_STYLE_PATTERN = re.compile(
    r'\[([a-zA-Z]\w*)\s*(\s+\w+\s*=\s*(?:"(?:[^"\\]|\\.)*"|\'(?:[^\'\\]|\\.)*\'|[^\s\]]+))*\s*]'
)
"""预编译正则 匹配tag样式的文本内容 比如 [div] [div class="container"] [button onclick=handleClick] 等"""
EXTRACT_TAG_ATTR_VALUE_PATTERN = re.compile(
    r'\w+\s*=\s*(["\'])((?:\\.|(?!\1).)*)\1'
)
"""预编译正则 提取tag样式的属性值（带引号才提取） 比如 [div class="container"] 提取出container 等"""
NON_LATIN_ISO_CODES = [
    'zh',  # 中文
    'ja',  # 日语
    'ko',  # 韩语
    'ar',  # 阿拉伯语
    'ru',  # 俄语
    'he',  # 希伯来语
    'hi',  # 印地语
    'th',  # 泰语
    'bn',  # 孟加拉语
    'el',  # 希腊语
    'hy',  # 亚美尼亚语
    'ka',  # 格鲁吉亚语
    'ta',  # 泰米尔语
    'ml',  # 马拉雅拉姆语
    'ur',  # 乌尔都语
    'fa'  # 波斯语
]
"""ISO 639-1非西文语言代码列表"""


# 加载语言检测器(全局)
def get_lang_detector():
    """获取语言检测器的全局单例实例"""
    global _LANG_DETECTOR_INSTANCE
    if _LANG_DETECTOR_INSTANCE is None:
        rich.print("[[green]INFO[/]] 加载 MediaPipe 文本语言检测器中...")
        # Record start time
        start_time = time.time()

        # 设置模型目录
        script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        model_path = os.path.join(script_dir, "Resource", "Models", "mediapipe", "language_detector.tflite")

        if not os.path.exists(model_path):
            rich.print(f"[[red]ERROR[/]] 模型文件不存在于: {model_path}")
            # 您可能希望在此处抛出错误或更优雅地处理
            raise FileNotFoundError(f"在预期位置未找到模型文件: {model_path}")

        try:
            # 使用 Python 的 open 函数读取模型文件到缓冲区后加载模型，兼容路径有中文的情况
            with open(model_path, "rb") as f:  # "rb" 表示二进制读取模式
                model_buffer = f.read()

            # 使用 model_asset_buffer 而不是 model_asset_path
            base_options = BaseOptions(model_asset_buffer=model_buffer)
            # 20250504改动：获取最多四个结果用于重新计算置信度
            # 20250609改动：在识别结果中过滤苗语(hmn)
            options = text.LanguageDetectorOptions(base_options=base_options,
                                                   max_results=4, score_threshold=0.0001,
                                                   category_denylist=["hmn"])
            _LANG_DETECTOR_INSTANCE = text.LanguageDetector.create_from_options(options)

            # 计算加载时间（毫秒）
            load_time_ms = (time.time() - start_time) * 1000
            rich.print(f"[[green]INFO[/]] MediaPipe 文本语言检测器已加载! ({load_time_ms:.2f} ms)")

        except Exception as e:
            rich.print(f"[[red]ERROR[/]] 加载 MediaPipe 语言检测器失败: {e}")
            # 重新抛出异常，以便调用者知道出了问题
            # 或者根据您的应用程序进行适当处理。
            raise

    return _LANG_DETECTOR_INSTANCE


# 释放语言检测器
def close_lang_detector():
    """关闭并释放语言检测器的全局单例实例"""
    global _LANG_DETECTOR_INSTANCE
    if _LANG_DETECTOR_INSTANCE is not None:
        # MediaPipe任务通常有close方法用于释放资源
        try:
            _LANG_DETECTOR_INSTANCE.close()
            rich.print("[[green]INFO[/]] MediaPipe 文本语言检测器已释放!")
        except AttributeError:
            # 如果没有close方法，尝试其他可能的清理方法
            if hasattr(_LANG_DETECTOR_INSTANCE, 'release'):
                _LANG_DETECTOR_INSTANCE.release()
        finally:
            # 无论如何都将实例设置为None，允许垃圾回收
            _LANG_DETECTOR_INSTANCE = None
    return True


# 检测文件编码
def detect_file_encoding(file_path: Union[str, pathlib.Path], min_confidence: float = 0.75) -> str:
    """
    使用`charset_normalizer`与`chardet`检测文件编码

    Args:
        file_path: 要检测的文件路径
        min_confidence: chardet检测编码的最低置信度阈值，低于此值将返回默认编码'utf-8'

    Returns:
        str: 默认/检测失败时返回`utf-8`，否则返回检测到的编码
    """
    # 确保file_path是Path对象
    if isinstance(file_path, str):
        file_path = pathlib.Path(file_path)

    try:
        cn_result = charset_normalizer.from_path(file_path).best()

        # 如果`charset_normalizer`有检测到结果，直接使用结果
        if cn_result:
            detected_encoding = cn_result.encoding
            confidence = 1.0
        else:
            # 如果没有检测到结果，回退到使用`chardet`
            # 读取文件内容
            with open(file_path, 'rb') as f:
                content_bytes = f.read()

            # 文件是文本类型，使用chardet检测编码
            detection_result = chardet.detect(content_bytes)
            detected_encoding = detection_result['encoding']
            confidence = detection_result['confidence']

            rich.print(
                f"[[red]WARNING[/]] 文件 {file_path} 编码检测失败，回退到使用`chardet`检测: {detected_encoding} - {confidence}"
            )

        # 如果没有检测到编码或置信度低于阈值，返回默认编码'utf-8'
        if not detected_encoding or confidence < min_confidence:
            rich.print(f"[[red]WARNING[/]] 文件 {file_path} 编码检测失败，默认使用`utf-8`编码")
            return 'utf-8'

        return detected_encoding

    except Exception as e:
        rich.print(f"[[red]ERROR[/]] 文件 {file_path} 检测过程出错: {str(e)}")
        return 'utf-8'  # 出错时返回默认编码


# 检测文本语言
def detect_language_with_mediapipe(items: list[CacheItem], _start_index: int, _file_data: CacheFile | None) -> \
        list[tuple[list[str], float, float]]:
    """批量检测语言（Mediapipe版本）

    Args:
        items: 当前处理的缓存项列表
        _start_index: 批次中第一项在items列表中的起始索引
        _file_data: 包含所有项的文件数据

    Returns:
        list[tuple]: 每项对应的(语言代码, 置信度)列表
    """
    # 初始化结果列表
    results = []

    # 获取语言检测器（只获取一次以提高效率）
    detector = get_lang_detector()

    for item in items:
        # 获取原文并清理
        source_text = item.source_text
        # 20250518 fix: 修复行不为字符串时的异常
        if source_text is None or not isinstance(source_text, str) or not source_text.strip():
            results.append((['no_text'], -1.0, -1.0))
            continue

        # 检测是否匹配目标正则
        if HAS_UNUSUAL_ENG_REGEX.match(source_text.strip()):
            results.append((['un'], -1.0, -1.0))
            continue

        cleaned_text = clean_text(source_text)

        # 检查是否只包含符号
        if is_symbols_only(cleaned_text):
            results.append((['symbols_only'], -1.0, -1.0))
            continue

        # 使用mediapipe的语言检测任务
        no_symbols_text = remove_symbols(cleaned_text)
        if not no_symbols_text:
            results.append((['no_text'], -1.0, -1.0))
            continue

        # 再次检查是否仅包含符号
        if is_symbols_only(no_symbols_text):
            results.append((['symbols_only_again'], -1.0, -1.0))
            continue

        # 再次检测是否匹配目标正则
        if HAS_UNUSUAL_ENG_REGEX.match(no_symbols_text):
            results.append((['un_again'], -1.0, -1.0))
            continue

        lang_result = detector.detect(no_symbols_text).detections
        if not lang_result:
            results.append((['un'], -1.0, -1.0))
        else:
            raw_prob = lang_result[0].probability
            first_prob = raw_prob
            mediapipe_langs = [detection.language_code for detection in lang_result]

            # 判断识别后的语言是否有非西文语言
            has_non_latin = bool(set(mediapipe_langs) & set(NON_LATIN_ISO_CODES))
            if has_non_latin:
                # 如果有非西文语言出现，去掉所有的英文字母与一些符号后再识别
                non_latin_text = re.sub(fr"[{VARIOUS_LETTERS_RANGE}'-]+", ' ', no_symbols_text)
                # 去除多余空格
                non_latin_text = re.sub(r'\s+', ' ', non_latin_text).strip()
                # 判断是否为空字符串，非空串才重新识别
                if non_latin_text:
                    # 进行重新识别
                    non_latin_lang_result = detector.detect(non_latin_text).detections
                    # 如果有识别结果才重置结果
                    if non_latin_lang_result:
                        # 重置lang_result
                        lang_result = non_latin_lang_result
                        # 重置三个变量
                        raw_prob = lang_result[0].probability
                        first_prob = raw_prob
                        mediapipe_langs = [detection.language_code for detection in lang_result]

            # 如果有至少两个识别结果，则使用最高置信度减去第二个
            if len(lang_result) >= 2:
                # 最终的mediapipe置信度
                first_prob -= lang_result[1].probability

            results.append((mediapipe_langs, first_prob, raw_prob))

    return results


# def detect_language_with_onnx(items: list[CacheItem], _start_index: int, _file_data: CacheFile) -> \
#         list[tuple[list[str], float, float]]:
#     """批量检测语言（ONNX版本）
#
#     Args:
#         items: 当前处理的缓存项列表
#         _start_index: 批次中第一项在items列表中的起始索引
#         _file_data: 包含所有项的文件数据
#
#     Returns:
#         list[tuple]: 每项对应的(语言代码, 置信度)列表
#     """
#     # 初始化结果列表
#     results = []
#
#     # 准备有效文本的列表和对应的清理后文本
#     valid_texts = []
#     valid_indices = []
#     cleaned_texts = []
#
#     for i, item in enumerate(items):
#         # 获取原文并清理
#         source_text = item.source_text
#         if source_text is None or not source_text.strip():
#             results.append((['no_text'], -1.0, -1.0))
#             continue
#
#         cleaned_text = clean_text(source_text)
#
#         # 检查是否只包含符号
#         if is_symbols_only(cleaned_text):
#             results.append((['symbols_only'], -1.0, -1.0))
#             continue
#
#         no_symbols_text = remove_symbols(cleaned_text)
#         if not no_symbols_text:
#             results.append((['no_text'], -1.0, -1.0))
#             continue
#
#         valid_texts.append(no_symbols_text)
#         valid_indices.append(len(results))
#         cleaned_texts.append(cleaned_text)
#         results.append(None)  # 添加占位符
#
#     if valid_texts:
#         # 使用批量预测方法
#         batch_results = LanguageDetectorONNX().predict_batch(valid_texts)
#
#         if batch_results:
#             # 处理预测结果
#             for i, result in enumerate(batch_results):
#                 if result is None or i >= len(valid_indices):
#                     continue
#
#                 _, lang_code, raw_prob, top_scores = result
#                 result_idx = valid_indices[i]
#                 cleaned_text = cleaned_texts[i]
#                 onnx_langs = [top_3_score[0] for top_3_score in top_scores]
#
#                 final_prob = raw_prob
#                 if HAS_UNUSUAL_ENG_REGEX.match(cleaned_text):
#                     # 如果匹配到目标字符，则最高置信度降低0.15
#                     final_prob -= 0.15
#
#                 # 如果有至少两个识别结果，则使用最高置信度减去第二个
#                 if len(top_scores) >= 2:
#                     # 最终的置信度
#                     final_prob -= top_scores[1][1]  # 第二高分数
#
#                 results[result_idx] = (onnx_langs, final_prob, raw_prob)
#
#     # 处理未成功预测的项
#     for i in range(len(results)):
#         if results[i] is None:
#             results[i] = (['un'], -1.0, -1.0)
#
#     return results


# def detect_language_with_pycld2(items: list[CacheItem], _start_index: int, _file_data: CacheFile) -> \
#         list[tuple[list[str], float, float]]:
#     """批量检测语言（pycld2版本）
#
#     Args:
#         items: 当前处理的缓存项列表
#         _start_index: 批次中第一项在items列表中的起始索引
#         _file_data: 包含所有项的文件数据
#
#     Returns:
#         list[tuple]: 每项对应的(语言代码列表, 调整后置信度, 原始置信度)列表
#     """
#     # 初始化结果列表
#     results = []
#
#     for item in items:
#         # 获取原文并清理
#         source_text = item.source_text
#         if source_text is None or not source_text.strip():
#             results.append((['no_text'], -1.0, -1.0))
#             continue
#
#         cleaned_text = clean_text(source_text)
#
#         # 检查是否只包含符号
#         if is_symbols_only(cleaned_text):
#             results.append((['symbols_only'], -1.0, -1.0))
#             continue
#
#         try:
#             # 使用pycld2进行语言检测
#             no_symbols_text = remove_symbols(cleaned_text)
#             if not no_symbols_text:
#                 results.append((['no_text'], -1.0, -1.0))
#                 continue
#
#             is_reliable, _, details = pycld2.detect(no_symbols_text, bestEffort=True, isPlainText=True)
#
#             if not is_reliable or not details:
#                 results.append((['un'], -1.0, -1.0))
#                 continue
#
#             # 提取语言代码和置信度（使用langcode标准化）
#             language_codes = [Language.get(lang[1]).language for lang in details]
#
#             # 计算置信度 - 从percent转换为0-1范围的概率
#             probabilities = [lang[2] / 100.0 for lang in details]
#
#             raw_prob = probabilities[0] if probabilities else 0.0
#             first_prob = raw_prob
#
#             if HAS_UNUSUAL_ENG_REGEX.match(cleaned_text):
#                 # 如果匹配到目标字符，则最高置信度降低0.15
#                 first_prob -= 0.15
#
#             # 如果有至少两个识别结果，则使用最高置信度减去第二个
#             if len(probabilities) >= 2:
#                 first_prob -= probabilities[1]
#
#             results.append((language_codes, first_prob, raw_prob))
#
#         except pycld2.error as _e:
#             # 处理文本太短或无法处理的情况
#             results.append((['detection_error'], -1.0, -1.0))
#         except Exception as _e:
#             # 处理其他异常情况
#             results.append((['error'], -1.0, -1.0))
#
#     return results


def replace_tags_with_values(text):
    """简洁但功能完整的版本"""

    def replacer(match):
        # 提取所有属性值（支持单双引号和转义）
        values = EXTRACT_TAG_ATTR_VALUE_PATTERN.findall(match.group(0))
        return f" {' '.join(value[1] for value in values)} "

    return TAG_STYLE_PATTERN.sub(replacer, text)


# 处理标签，有条件地保留内容
def tag_handler(match):
    content: str = match.group(1).strip()
    # 如果内容是纯数字，不保留
    if content.isdigit():
        return ' '
    # 如果内容匹配特殊正则，不保留
    if HAS_UNUSUAL_ENG_REGEX.match(content):
        return ' '
    # 其他情况保留内容
    return content + ' '


# 辅助函数，用于清理文本
# 20250504改动：取消清理文本中的空白字符
# 20250518改动：获取特殊标签中的内容
def clean_text(source_text):
    # 先将所有换行符替换为一个特殊标记
    text_with_marker = re.sub(r'\r\n|\r|\n', '__NEWLINE__', source_text)
    # 将标记替换回空字符串
    cleaned_text = text_with_marker.replace('__NEWLINE__', ' ')
    # 去除js变量
    cleaned_text = JS_VAR_PATTERN.sub('', cleaned_text)
    # 提取、拼接tag属性值
    cleaned_text = replace_tags_with_values(cleaned_text)
    # 提取xml标签带冒号格式的具体内容
    # 20250825fix: 修复XML标签名正则不支持非ASCII字符的问题
    cleaned_text = re.sub(r'<[^:]+:(.*?)>', tag_handler, cleaned_text)
    # 去除html标签
    cleaned_text = remove_html_tags(cleaned_text).strip()
    # 去除文本前后的转义换行符(\n)
    cleaned_text = re.sub(r'^(\\n)+', '', cleaned_text)  # 去除开头的\n
    cleaned_text = re.sub(r'(\\n)+$', '', cleaned_text)  # 去除结尾的\n

    # 处理其他需要替换的模式
    cleaned_text = CLEAN_TEXT_PATTERN.sub(' ', cleaned_text)
    # 返回去除可能的多个连续空格后的字符串
    return re.sub(r'\s+', ' ', cleaned_text).strip()


# 辅助函数，用于检查文本是否只包含符号
def is_symbols_only(source_text: str):
    cleaned_text = source_text.strip()
    if not cleaned_text:  # 检查是否为空字符串
        return False
    # 检查每个字符是否都不是字母数字
    return all(not c.isalnum() for c in cleaned_text)


# 辅助函数，用于去除文字中的html标签
def remove_html_tags(source_text):
    if not source_text:
        return ""

    # 清理无效的 surrogate 字符（U+D800-U+DFFF）
    # 这些字符在 UTF-8 中不能单独存在
    cleaned_text = source_text.encode('utf-8', errors='ignore').decode('utf-8')

    soup = BeautifulSoup(cleaned_text, 'html.parser')
    return soup.get_text()


def remove_symbols(source_text):
    # 去除标点和特殊字符(根据需要保留部分符号)
    source_text = re.sub(r"[^\w\s「」『』，。、〜？,.'-]", '', source_text)

    # 去除所有数字
    source_text = re.sub(r'\d+', '', source_text)

    # 先处理连续的标点符号，保留一个（没有处理`'`符号）
    source_text = re.sub(r"([\s「」『』，。、〜？,.-]+)", lambda m: m.group(1)[0] + ' ', source_text)

    # 再处理连续的空格
    source_text = re.sub(r'\s+', ' ', source_text.strip())

    # 再次去掉所有符号
    no_symbols_and_num_text = ''.join(char for char in source_text if char.isalnum())
    # 判断字符串长度，如果小于等于5则直接返回，使用这个字符串作为语言判断依据
    if len(no_symbols_and_num_text) <= 5:
        # 保留空格的字符串
        keep_space_text = ''.join(char for char in source_text if char.isalnum() or char.isspace())
        return keep_space_text.strip()

    return source_text.strip()


def make_final_detect_text(item: CacheItem):
    no_symbols_text = remove_symbols(clean_text(item.source_text))

    langs = set([item.lang_code[0]] + item.lang_code[2])
    has_non_latin = bool(langs & set(NON_LATIN_ISO_CODES))
    if has_non_latin:
        # 如果有非西文语言出现，去掉所有的英文字母与一些符号后再识别
        non_latin_text = re.sub(fr"[{VARIOUS_LETTERS_RANGE}'-]+", ' ', no_symbols_text)
        # 去除多余空格
        return re.sub(r'\s+', ' ', non_latin_text).strip()
    return no_symbols_text


# 检测换行符类型
def detect_newlines(content: str) -> str:
    """
    检测文本内容中使用的换行符类型

    Args:
        content: 文本内容（字符串类型）

    Returns:
        str: 检测到的换行符（'\r\n', '\n', 或 '\r'）
    """
    crlf_count = content.count('\r\n')  # Windows: \r\n
    lf_count = content.count('\n') - crlf_count  # Unix/Linux/macOS: \n (减去CRLF中的\n)
    cr_count = content.count('\r') - crlf_count  # 旧Mac: \r (减去CRLF中的\r)

    # 判断主要使用的换行符
    if crlf_count > lf_count and crlf_count > cr_count:
        # Windows 系统的换行符
        return "\r\n"
    elif lf_count > crlf_count and lf_count > cr_count:
        # Unix/Linux 系统的换行符
        return "\n"
    elif cr_count > crlf_count and cr_count > lf_count:
        # 早期 Mac OS 的换行符
        return "\r"
    else:
        # 默认使用系统对应的换行符
        return os.linesep


def decode_content_bytes(content_bytes):
    detected_encoding = None
    content = ""

    encodings = ['utf-8', 'utf-16-le', 'utf-16-be', 'gbk', 'gb2312', 'big5', 'shift-jis']
    decode_errors = []
    for encoding in encodings:
        try:
            content = content_bytes.decode(encoding)
            detected_encoding = encoding
            break
        except UnicodeDecodeError as e:
            decode_errors.append((encoding, str(e)))
    # 如果所有尝试都失败，抛出详细的异常
    if not detected_encoding:
        error_details = '\n'.join([f"{enc}: {err}" for enc, err in decode_errors])
        raise UnicodeDecodeError(
            "unknown",
            content_bytes,
            0,
            len(content_bytes),
            f"无法使用任何可靠的编码读取文件。尝试了chardet和以下编码:\n{error_details}"
        )
    return content, detected_encoding



================================================
FILE: ModuleFolders/FileReader/RenpyReader.py
================================================
import re
from pathlib import Path
from typing import List, Optional, Tuple

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)

class RenpyReader(BaseSourceReader):
    """
    读取 rpy 文件并提取翻译条目，支持下面格式:
    1. old "..." / new "..."
    2. # tag "..." / tag "..."
    3. # "..." / "..."
    4. # Character("xxx") "..." / Character("xxx") "..."
    5. # bri.c "..." / bri.c "..."
    """
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.RENPY

    @property
    def support_file(self):
        return "rpy"

    # 用于检查行是否以翻译注释行格式开头的正则表达式
    COMMENT_TRANSLATION_START_PATTERN = re.compile(r"^\s*#\s*")

    # 检查指定位置的引号是否被转义。
    def _is_escaped_quote(self, text: str, pos: int) -> bool:
        """
        检查指定位置的引号是否被转义。
        通过计算引号前面连续反斜杠的数量来判断：
        - 偶数个反斜杠（包括0）：引号未被转义
        - 奇数个反斜杠：引号被转义
        
        """
        if pos == 0:
            return False
        
        backslash_count = 0
        check_pos = pos - 1
        
        # 向前计算连续的反斜杠数量
        while check_pos >= 0 and text[check_pos] == '\\':
            backslash_count += 1
            check_pos -= 1
        
        # 奇数个反斜杠表示引号被转义
        return backslash_count % 2 == 1

    # 从后往前查找最后一个未转义的双引号。
    def _find_last_unescaped_quote(self, text: str, end: int = -1) -> int:
        """
        从后往前查找最后一个未转义的双引号。
        
        """
        if end == -1:
            end = len(text)
        
        pos = end - 1
        while pos >= 0:
            if text[pos] == '"' and not self._is_escaped_quote(text, pos):
                return pos
            pos -= 1
        
        return -1

    # 从前往后查找第一个未转义的双引号。
    def _find_first_unescaped_quote(self, text: str, start: int = 0) -> int:
        """
        从前往后查找第一个未转义的双引号。
        """
        pos = start
        while pos < len(text):
            if text[pos] == '"' and not self._is_escaped_quote(text, pos):
                return pos
            pos += 1
        
        return -1

    # 从一行中分离出标签（前缀）和引用的文本。
    def _get_dialogue_parts(self, line: str) -> Optional[Tuple[str, str]]:
        """
        从一行中分离出标签（前缀）和引用的文本。
        通过从后往前查找未转义的引号，可以准确处理含有转义引号的文本。
        
        """
        # 1. 找到最后一个未转义的引号，这是对话的结束引号
        last_quote_index = self._find_last_unescaped_quote(line)
        if last_quote_index == -1:
            return None

        # 2. 在最后一个引号之前的部分中，反向查找第一个未转义的引号，这是对话的开始引号
        first_quote_index = self._find_last_unescaped_quote(line, last_quote_index)
        
        # 如果找不到开始的引号，或者引号对无效
        if first_quote_index == -1:
            # 处理只有引号没有标签的情况，例如 '"...'
            if line.strip().startswith('"'):
                first_quote_index = self._find_first_unescaped_quote(line)
                if first_quote_index >= last_quote_index:
                    return None
            else:
                return None

        # 标签是对话开始引号之前的所有内容
        tag = line[:first_quote_index].strip()
        # 文本是两个对话引号之间的内容
        text = line[first_quote_index + 1:last_quote_index]
        
        return tag, text

    def _find_next_relevant_line(self, lines: List[str], start_index: int) -> Optional[Tuple[int, str]]:
        """
        从指定索引开始，查找下一个有效的 Ren'Py 代码对话行。
        一个有效的代码行是任何可以通过 `_get_dialogue_parts` 成功解析的行。
        它会主动跳过空行、非对话注释、以及不符合翻译格式的指令。
        """
        for i in range(start_index, len(lines)):
            line = lines[i]
            stripped = line.strip()

            # 如果遇到下一个翻译块的定义，停止搜索
            if stripped.startswith("translate "):
                return None

            # 尝试将该行解析为对话部分，如果成功，则为相关行
            if self._get_dialogue_parts(stripped) is not None:
                return i, line

        return None # 如果直到文件末尾都没找到，返回 None

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        lines = file_path.read_text(encoding=pre_read_metadata.encoding).splitlines()
        entries = []
        i = 0
        while i < len(lines):
            line = lines[i]
            stripped = line.strip()

            # --- 格式 1: old / new ---
            if stripped.startswith("old "):
                parts = self._get_dialogue_parts(stripped)
                if parts:
                    source = parts[1]
                    found_new = False
                    for j in range(i + 1, len(lines)):
                        next_line = lines[j]
                        next_stripped = next_line.strip()
                        if next_stripped.startswith("new "):
                            new_parts = self._get_dialogue_parts(next_stripped)
                            if new_parts:
                                translated = new_parts[1]
                                entries.append({
                                    "source": source,
                                    "translated": translated,
                                    "new_line_num": j,
                                    "format_type": "old_new",
                                    "tag": None
                                })
                                i = j
                                found_new = True
                                break
                        elif next_stripped.startswith("old ") or self.COMMENT_TRANSLATION_START_PATTERN.match(next_stripped) or self._get_dialogue_parts(next_stripped):
                            break
                    if not found_new:
                        pass
                i += 1

            # --- 格式 2, 3, 4, 5: 注释行后跟代码行 ---
            elif self.COMMENT_TRANSLATION_START_PATTERN.match(stripped):
                comment_line = line
                
                # 从 '#' 后提取潜在的源对话行
                potential_source_line = comment_line.split('#', 1)[-1].lstrip()
                comment_parts = self._get_dialogue_parts(potential_source_line)

                # 确保它不是元数据注释（如 # game/script.rpy:123）
                is_meta_comment = potential_source_line.startswith("game/") or potential_source_line.startswith("renpy/")
                
                if comment_parts and not is_meta_comment:
                    comment_tag, comment_source = comment_parts
                    
                    # 查找下一个相关的代码行
                    next_line_info = self._find_next_relevant_line(lines, i + 1)
                    
                    if next_line_info:
                        code_line_num, code_line = next_line_info
                        code_parts = self._get_dialogue_parts(code_line.strip())
                        
                        if code_parts:
                            code_tag, code_text = code_parts
                            
                            # 【核心验证】确保注释行和代码行的标签完全一致
                            if comment_tag == code_tag:
                                entries.append({
                                    "source": comment_source,
                                    "translated": code_text,
                                    "new_line_num": code_line_num,
                                    "format_type": "comment_dialogue", # 统一格式类型
                                    "tag": code_tag # 存储标签以供写入器使用
                                })
                                i = code_line_num + 1
                                continue

                # 如果不是有效的翻译对，则正常递增
                i += 1
            else:
                # 如果没有模式匹配或处理，则默认增加
                i += 1

        # 转换为 CacheItem 对象
        items = []
        for entry in entries:
            extra = {
                "new_line_num": entry["new_line_num"],
                "format_type": entry["format_type"],
                "tag": entry.get("tag"),
            }
            item = CacheItem(source_text=entry["source"], translated_text=entry["translated"], extra=extra)
            items.append(item)
        return CacheFile(items=items)


================================================
FILE: ModuleFolders/FileReader/SrtReader.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class SrtReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.SRT

    @property
    def support_file(self):
        return "srt"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        # 读取文件内容并去除 BOM，即.lstrip("\ufeff")
        lines = [line.strip().lstrip("\ufeff") for line in file_path.read_text(encoding=pre_read_metadata.encoding).splitlines()]

        current_block = None
        items = []
        for line in lines:

            # 新字幕块开始
            if current_block is None:
                if line.isdigit():
                    current_block = {
                        "number": line,
                        "time": None,
                        "text": []
                    }
                continue

            # 处理时间轴
            if current_block["time"] is None:
                if "-->" in line:
                    current_block["time"] = line
                else:
                    # 时间轴格式错误，丢弃当前块
                    current_block = None
                continue

            # 处理文本内容
            if not line:
                # 遇到空行，保存当前块
                items.append(self._block_to_item(current_block))
                current_block = None
            else:
                current_block["text"].append(line)

        # 处理文件末尾未以空行结束的情况
        if current_block is not None:
            items.append(self._block_to_item(current_block))
        return CacheFile(items=items)

    def _block_to_item(self, block):
        source_text = "\n".join(block["text"])
        extra = {"subtitle_number": block["number"], "subtitle_time": block["time"]}
        item = CacheItem(source_text=source_text, extra=extra)
        return item



================================================
FILE: ModuleFolders/FileReader/TPPReader.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/FileReader/TransReader.py
================================================
import json
from pathlib import Path
import re

import rich

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class TransReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.TRANS

    @property
    def support_file(self):
        return "trans"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:

        # 以json格式读取工程文件
        trans_content = json.loads(file_path.read_text(encoding="utf-8"))

        # 获取具体文本路径
        files_data = trans_content["project"]["files"]
        items = []
        
        # 遍历每个文件类别（例如："data/Actors.json"）
        for file_category, category_data in files_data.items():

            data_list = category_data.get("data", [])
            tags_list = category_data.get("tags", [])  # 如果缺失，默认为空列表
            context_list = category_data.get("context", [])  # 如果缺失，默认为空列表
            parameters_list = category_data.get("parameters", [])  # 如果缺失，默认为空列表

            # 遍历每对文本 [原文，翻译]
            for idx, text_pair in enumerate(data_list):

                # 类型检查
                if not isinstance(text_pair, (list, tuple)):
                    rich.print(
                        f"[[red]WARNING[/]] 在文件 '{file_path}' 的类别 '{file_category}' 索引 {idx} 处发现非列表/元组项：{text_pair}，已跳过。")
                    continue  # 跳过这个无效项

                if len(text_pair) == 0:
                    rich.print(
                        f"[[red]WARNING[/]] 在文件 '{file_path}' 的类别 '{file_category}' 索引 {idx} 处发现空项：{text_pair}，已跳过。")
                    continue  # 跳过这个空项

                # 初始翻译状态
                translation_status = TranslationStatus.UNTRANSLATED



                # 检查翻译状态，过滤已翻译内容
                translated_text = ""
                if len(text_pair) >= 2: # 获取译文内容，并且防止列表越界，有些trans文件没有译文位置
                    translated_text = text_pair[1]

                    if translated_text:
                        translation_status = TranslationStatus.TRANSLATED


                # 获取原文内容
                source_text = text_pair[0]

                # 获取该原文的对应标签
                tags = None
                if idx < len(tags_list):
                    tags = tags_list[idx]  # 可能为 null 或类似 "red" 的列表

                # 获取文本的地址来源
                contexts = None
                if idx < len(context_list):
                    contexts = context_list[idx]  # 可能为null或者是列表

                # 获取该原文的对应人名
                parameters = None
                rowInfoText = None
                if idx < len(parameters_list):
                    parameters = parameters_list[idx]
                    if parameters and len(parameters) > 0 and isinstance(parameters[0], dict):  # 有些人名信息并没有以字典存储
                        rowInfoText = parameters[0].get("rowInfoText", "")  # 可能为 具体人名 或类似 "\\v[263]" 的字符串

                # 过滤不需要翻译的文本，放在这里进行处理是因为contexts太大了，后面解决性能消耗后，转移到其他地方
                if isinstance(source_text, str) and self.filter_trans_text( source_text, tags, contexts) :
                    translation_status = TranslationStatus.EXCLUDED  # 改变为不需要翻译

                    # 添加处理过的标签注释
                    if tags is None:
                        tags = ["indigo"]
                    else:
                        tags.append("indigo")

                # 额外属性
                extra = {
                    "tags": tags,
                    "file_category": file_category,
                    "data_index": idx,
                }
                # 基本属性
                item = CacheItem(
                    source_text=source_text,
                    translated_text=translated_text,
                    translation_status=translation_status,
                    extra=extra
                )

                # 如果有人名，则对原文本进行二次处理
                if rowInfoText:
                    item.source_text = self.combine_srt(rowInfoText, source_text)
                    item.set_extra("name", rowInfoText)

                # 添加进缓存条目
                items.append(item)

        return CacheFile(items=items)

    # 人名信息添加
    def combine_srt(self, name, text):
        return f"[{name}]{text}"


    # 特殊文本过滤器-trans项目
    def filter_trans_text(self, source_text: str, tags, contexts):

        # 保留绿色安全标签
        if tags and ("green" in tags):
            return False

        # 保留常见插件文本
        if self.isTagText(source_text):
            return False


        # 过滤全部蓝色标签
        if tags and ("blue" in tags):
            return True

        # 过滤特定文本以外的红色标签
        if tags and ("red" in tags):
            # 如果是插件文本，而非命令文本
            if self.check_list_conditions(contexts=contexts, middle_list = ["StringLiteral"]) :
                # 如果检查出纯日志文本
                if self.check_english_letters_after_tags(source_text):
                    pass
    
                else:
                    return True
            else:
                return True

        # 过滤全部note文本
        if self.check_list_conditions(contexts=contexts, end_str="note"):
            # 如果检查出纯日志文本
            if self.check_english_letters_after_tags(source_text):
                pass
            else:
                return True

        # 过滤Animations文件
        if self.check_list_conditions(contexts=contexts, start_str="Animations") :
            return True

        # 过滤MapInfos文件
        if self.check_list_conditions(contexts=contexts, start_str="MapInfos") :
            return True
        
        # 过滤Tilesets文件
        if self.check_list_conditions(contexts=contexts, start_str="Tilesets") :
            return True

        # 过滤CommonEvents 调用事件名
        if self.check_list_conditions(contexts=contexts, start_str="CommonEvents", end_str="name") :
            return True

        # 过滤Troops 调用事件名
        if self.check_list_conditions(contexts=contexts, start_str="Troops", end_str="name") :
            return True

        # 过滤Actors的profile字段
        if self.check_list_conditions(contexts=contexts, start_str="Actors", end_str="profile") :
            return True

        # 过滤所有事件名
        if self.check_list_conditions(contexts=contexts, end_str="name", middle_list = ["events"]) :
            return True

        # 过滤图片调用代码
        if source_text.strip().startswith("<PLM"):
            return True

        return False

    # 识别出部分战斗日志文本
    def check_english_letters_after_tags(self,text: str) -> bool:
        r"""
        提取文本中所有RPG Maker代码标签后，检查剩余文本是否还有英文字母。

        RPG Maker 代码标签格式: \ + 任意字母 + [ + 任意内容 + ]
        例如: \C[27], \N[HeroName], \V[10=5]
        """
        # 1. 定义代码标签的正则表达式
        tag_pattern = r"\\([a-zA-Z]+)\[.*?\]" 

        # 2. 移除所有匹配到的代码标签
        text_without_tags = re.sub(tag_pattern, "", text)
        text_cleaned = re.sub(r'\s+', '', text_without_tags)  # 移除所有空白字符
        # 比如文本为\C[7]\I[2456]，提取完标签文本后为空
        if not text_cleaned:
            return False

        # 3. 检查剩余文本中是否包含任何英文字母,比如b_0001或者单个字母，但会误伤3p这样的文本
        if re.search(r"[a-zA-Z]", text_cleaned):
            return False
        else:
            return True

    # 识别插件文本
    def isTagText(self, text: str):
        # 检查是否信息提示插件
        if text.startswith("<infowindow") and text.endswith(">"):
            return True
        # 检查是否是地图名字显示插件
        if text.startswith("<namePop:") and text.endswith(">"):
            return True
        return False
    
    # 检查字段路径内容
    def check_list_conditions(self, contexts: list[str],start_str: str = None,end_str: str = None,middle_list: list[str] = None) -> bool:

        # 检查空列表
        if not contexts:
            return False

        # 1. 检查 str_a (开头字符串)
        if start_str is not None:
            # 检查 list_a 中的每个元素
            for item_in_a in contexts:
                if not item_in_a.startswith(start_str):
                    return False  

        # 2. 检查 str_b (结尾字符串)
        if end_str is not None:
            for item_in_a in contexts:
                if not item_in_a.endswith(end_str):
                    return False

        # 3. 检查 list_b (包含所有子字符串)
        if middle_list is not None and middle_list: 
            for item_in_a in contexts:
                # 对于 list_a 中的每一个元素，检查它是否包含 list_b 中的所有子字符串
                for sub_item_in_b in middle_list:
                    if sub_item_in_b not in item_in_a:
                        return False # item_in_a 没有包含 list_b 中的某个元素

        # 如果所有检查都通过了
        return True


================================================
FILE: ModuleFolders/FileReader/TxtReader.py
================================================
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class TxtReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig, max_empty_line_check=None):
        super().__init__(input_config)
        self.max_empty_line_check = max_empty_line_check

    @classmethod
    def get_project_type(cls):
        return ProjectType.TXT

    @property
    def support_file(self):
        return "txt"

    # 读取单个txt的文本及其他信息
    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        items = []
        # 切行
        # 使用传入的 `detected_encoding` 参数正确读取未知编码的纯文本文件，并使用`splitlines()`正确切分行
        lines = file_path.read_text(encoding=pre_read_metadata.encoding).splitlines()

        for i, line in enumerate(lines):
            # 如果当前行是空行
            # 并且位置不是文本开头，则跳过当前行
            if not line.strip() and i != 0:
                continue

            # 去掉文本开头的BOM
            line_lstrip = line.lstrip("\ufeff")
            extra = {
                "line_break": self._count_next_empty_line(lines, i)
            }
            item = CacheItem(source_text=line_lstrip, extra=extra)

            items.append(item)
        return CacheFile(items=items)

    def _count_next_empty_line(self, lines, line_index):
        """检查后续行是否连续空行，最多检查 max_empty_line_check 行"""
        max_empty_line_check = self.max_empty_line_check if self.max_empty_line_check is not None else len(lines)
        empty_line_index = line_index
        for empty_line_index in range(line_index + 1, min(len(lines), line_index + 1 + max_empty_line_check)):
            if lines[empty_line_index].strip() != '':
                empty_line_index -= 1
                break
        return empty_line_index - line_index



================================================
FILE: ModuleFolders/FileReader/VntReader.py
================================================
import json
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class VntReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.VNT

    @property
    def support_file(self):
        return "json"

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        json_data = json.loads(file_path.read_text(encoding="utf-8"))
        items = []
        for entry in json_data:
            source_text = entry["message"]
            names = entry.get("names", [])  # 默认获取空列表
            name = entry.get("name", "")    # 默认获取空字符串

            extra = {}
            if names:
                # 处理names列表，拼接每个名字
                name_tags = ''.join([f'[{n}]' for n in names])
                source_text = f"{name_tags}{source_text}"
                extra["names"] = names
            elif name:
                # 处理单个name字段
                source_text = self.combine_srt(name, source_text)
                extra["name"] = name
            # 无name或names字段时不处理
            item = CacheItem(source_text=source_text, extra=extra)
            items.append(item)
        return CacheFile(items=items)

    def combine_srt(self, name, text):
        return f"[{name}]{text}"

    def can_read_by_content(self, file_path: Path) -> bool:
        # [{"mesage": "text1"}, {"message": "text2"}]
        # 即使不是对应编码也不影响英文的key
        content = json.loads(file_path.read_text(encoding="utf-8", errors='ignore'))
        if not isinstance(content, list):
            return False
        return all(isinstance(line, dict) and 'message' in line for line in content)



================================================
FILE: ModuleFolders/FileReader/VttReader.py
================================================
import re
from pathlib import Path

from ModuleFolders.Cache.CacheFile import CacheFile
from ModuleFolders.Cache.CacheItem import CacheItem
from ModuleFolders.Cache.CacheProject import ProjectType
from ModuleFolders.FileReader.BaseReader import (
    BaseSourceReader,
    InputConfig,
    PreReadMetadata
)


class VttReader(BaseSourceReader):
    def __init__(self, input_config: InputConfig):
        super().__init__(input_config)

    @classmethod
    def get_project_type(cls):
        return ProjectType.VTT

    @property
    def support_file(self):
        return "vtt"

    TIME_CODE_PATTERN = re.compile(r"(\d{2}:\d{2}:\d{2}\.\d{3}) --> (\d{2}:\d{2}:\d{2}\.\d{3})")

    def on_read_source(self, file_path: Path, pre_read_metadata: PreReadMetadata) -> CacheFile:
        content = file_path.read_text(encoding=pre_read_metadata.encoding).strip()

        header, body = self._split_header_body(content)
        blocks = self._split_blocks(body)

        items = []
        for block in blocks:
            item = self._parse_block(block)
            if item is not None:
                items.append(item)
        return CacheFile(items=items, extra={"top_text": header})

    def _split_header_body(self, content):
        parts = content.split('\n\n', 1)
        return parts[0], parts[1] if len(parts) > 1 else ''

    def _split_blocks(self, body):
        return [b.strip() for b in re.split(r'\n{2,}', body) if b.strip()]

    def _parse_block(self, block):

        lines = [line.strip() for line in block.split('\n') if line.strip()]
        if not lines:
            return None

        # 解析时间轴
        time_match = self.TIME_CODE_PATTERN.search(lines[0])
        if not time_match:
            return None

        full_timecode = lines[0]
        text_lines = []
        current_line = 1

        # 处理可能的序号
        if lines[0].isdigit() and len(lines) > 1:
            if self.TIME_CODE_PATTERN.search(lines[1]):
                full_timecode = lines[1]
                current_line += 1

        # 收集文本内容
        while current_line < len(lines):
            line = lines[current_line]
            if self.TIME_CODE_PATTERN.search(line):  # 防止异常时间轴
                break
            text_lines.append(line)
            current_line += 1

        source_text = '\n'.join(text_lines).strip()
        if not source_text:
            return None

        return CacheItem(
            source_text=source_text,
            extra={"subtitle_time": full_timecode},
        )



================================================
FILE: ModuleFolders/FileReader/unused/LanguageDetectorONNX.py
================================================
# # 辅助函数：Softmax
# import os
# import sys
# import time
#
# import numpy as np
# import onnxruntime
# import rich
# from langcodes import Language
# from transformers import AutoTokenizer, AutoConfig
#
#
# def softmax(x, axis=-1):
#     """计算 softmax"""
#     x_max = np.max(x, axis=axis, keepdims=True)
#     exp_x = np.exp(x - x_max)
#     return exp_x / np.sum(exp_x, axis=axis, keepdims=True)
#
#
# class LanguageDetectorONNX:
#     _instance = None
#     _initialized = False
#
#     def __new__(cls, *args, **kwargs):
#         if cls._instance is None:
#             # rich.print("[[green]INFO[/]] 准备 ONNX 文本语言检测器实例中...")
#             cls._instance = super().__new__(cls)
#         return cls._instance
#
#     def __init__(self):
#         if self._initialized:
#             return
#
#         rich.print("[[green]INFO[/]] 正在初始化 ONNX 文本语言检测器实例...")
#         # Record start time
#         start_time = time.time()
#         # 设置模型目录
#         script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
#         model_path = os.path.join(script_dir, "Resource", "Models", "language_detection-ONNX")
#
#         self.onnx_model_path = os.path.join(model_path, "onnx", "model_int8.onnx")
#         self.tokenizer_path = model_path
#         self.ort_session = None
#         self.tokenizer = None
#         self.id2label = None
#
#         # 使用 GPU加速 (如果可用)
#         available_providers = onnxruntime.get_available_providers()
#         providers_to_use = ['CPUExecutionProvider']  # 默认
#         if 'DmlExecutionProvider' in available_providers:
#             rich.print("[[green]INFO[/]] 检测到有效加速环境，优先使用GPU进行 ONNX 文本语言检测推理!")
#             providers_to_use.insert(0, 'DmlExecutionProvider')
#         else:
#             rich.print("[[green]INFO[/]] 未检测到有效加速环境，默认使用CPU进行 ONNX 文本语言检测推理!")
#
#         try:
#             self.ort_session = onnxruntime.InferenceSession(self.onnx_model_path, providers=providers_to_use)
#             # rich.print(f"[[green]INFO[/]] ONNX session loaded from {self.onnx_model_path}")
#
#             self.tokenizer = AutoTokenizer.from_pretrained(self.tokenizer_path)
#             # rich.print(f"[[green]INFO[/]] Tokenizer loaded from {self.tokenizer_path}")
#
#             try:
#                 config = AutoConfig.from_pretrained(model_path)
#                 self.id2label = {int(k): v for k, v in config.id2label.items()}
#                 # rich.print(f"[[green]INFO[/]] Loaded id2label map from config: {model_path}")
#             except Exception as e:
#                 raise ValueError(
#                     f"Could not load id2label from config '{model_path}': {e}. Please provide id2label_map directly."
#                 )
#
#             if not self.id2label or not isinstance(self.id2label, dict):
#                 raise TypeError("Failed to obtain a valid id2label dictionary.")
#
#             self._initialized = True
#             # 计算加载时间（毫秒）
#             load_time_ms = (time.time() - start_time) * 1000
#             rich.print(f"[[green]INFO[/]] ONNX 文本语言检测器已加载! ({load_time_ms:.2f} ms)")
#
#         except Exception as e:
#             rich.print(f"[[red]ERROR[/]] 加载 ONNX 语言检测器失败: {e}")
#             # 清理，防止处于部分初始化状态
#             self._instance = None  # 确保 instance 也被重置
#             self._initialized = False
#             raise
#
#     @classmethod
#     def release(cls):
#         """
#         释放单例持有的资源并重置其状态。
#         允许后续调用重新初始化单例。
#         """
#         if cls._instance:
#             # rich.print("[[green]INFO[/]] 正在释放 ONNX 文本语言检测器...")
#             if cls._instance.ort_session:
#                 # ONNX Runtime sessions don't have an explicit close/del method in Python API
#                 # that guarantees immediate resource release beyond what GC does.
#                 # Setting to None removes our reference, allowing GC to collect it.
#                 cls._instance.ort_session = None
#                 rich.print("[[green]INFO[/]] ONNX 文本语言检测器已释放!")
#             cls._instance.tokenizer = None
#             cls._instance.id2label = None
#             # 其他需要清理的实例变量也可以在这里设置为 None
#
#             # 最重要的是重置类级别的状态变量
#             cls._instance = None
#             cls._initialized = False
#             # rich.print("[[green]INFO[/]] ONNX 文本语言检测器实例已释放并重置!")
#         else:
#             rich.print("[[green]INFO[/]] No LanguageDetectorONNX singleton instance to release.")
#
#     def predict(self, text):
#         """单文本预测方法"""
#         if not self._initialized or not self.ort_session or not self.tokenizer:
#             if not LanguageDetectorONNX._instance or not LanguageDetectorONNX._initialized:
#                 raise RuntimeError("LanguageDetectorONNX singleton is not properly initialized or has been released.")
#             if not self.ort_session or not self.tokenizer:
#                 raise RuntimeError("LanguageDetectorONNX resources (session/tokenizer) are missing. Was it released?")
#         try:
#             # 调用批处理版本，批大小为1
#             results = self.predict_batch([text])
#             return results[0] if results else None  # predict_batch返回列表，取第一个
#         except Exception as e:
#             print(f"Error during single prediction for text '{text[:50]}...': {e}")
#             return None
#
#     def predict_batch(self, texts: list):  # 新增的批处理预测方法
#         """
#         使用加载的 ONNX 模型批量预测输入文本列表的语言。
#
#         Args:
#             texts (list of str): 需要检测语言的文本列表。
#
#         Returns:
#             list of dict: 每个字典包含对应文本的预测结果:
#                           {'label': str, 'confidence': float, 'top_3_scores': list}
#                           如果某一项预测失败，则对应位置可能为 None 或错误信息字典。
#             None: 如果在批处理过程中发生严重错误。
#         """
#         if not self._initialized or not self.ort_session or not self.tokenizer:
#             # 检查 _instance 是否还存在，如果 release 后实例被设为 None，直接访问 self 上的属性会出错
#             # 但由于 __new__ 会返回已存在的 _instance，这里的 self 应该是有效的，只是其内部状态可能被清空
#             if not LanguageDetectorONNX._instance or not LanguageDetectorONNX._initialized:
#                 raise RuntimeError("LanguageDetectorONNX singleton is not properly initialized or has been released.")
#             # 如果 self.ort_session 是 None 但 _initialized 仍然是 True，说明可能是在 release 过程中
#             # 这里更严格的检查是基于 _initialized
#             if not self.ort_session or not self.tokenizer:
#                 raise RuntimeError("LanguageDetectorONNX resources (session/tokenizer) are missing. Was it released?")
#
#         if not texts:
#             return []
#
#         try:
#             # 1. 预处理输入文本 (批处理)
#             # Tokenizer 会自动处理列表输入，并进行填充 (padding) 以使批次内所有序列长度一致
#             inputs = self.tokenizer(texts, return_tensors="np",
#                                     padding=True,  # 关键：开启填充
#                                     truncation=True,
#                                     max_length=512)  # 根据模型调整 max_length
#
#             # 2. 准备 ONNX Runtime 输入 (确保 int64 类型)
#             ort_inputs = {
#                 'input_ids': inputs['input_ids'].astype(np.int64),
#                 'attention_mask': inputs['attention_mask'].astype(np.int64)
#             }
#             if 'token_type_ids' in inputs:  # 确保 token_type_ids (如果模型需要)
#                 ort_inputs['token_type_ids'] = inputs['token_type_ids'].astype(np.int64)
#
#             # 3. 运行推理 (批处理)
#             # ort_outputs[0] 的形状现在是 [batch_size, num_classes]
#             ort_outputs = self.ort_session.run(None, ort_inputs)
#             batch_logits = ort_outputs[0]  # [batch_size, num_classes]
#
#             results_list = []
#             for i in range(batch_logits.shape[0]):  # 遍历批次中的每个结果
#                 logits = batch_logits[i]  # 当前文本的 logits [num_classes]
#
#                 # 4. 后处理 - 计算概率 (置信度)
#                 probabilities = softmax(logits)  # softmax 在最后一个维度上操作
#                 # 先计算argmax获取最高预测结果
#                 predicted_class_id = np.argmax(probabilities)
#                 predicted_label = self.id2label.get(predicted_class_id, "Unknown")
#                 confidence_score = float(probabilities[predicted_class_id])
#
#                 # 创建临时字典，合并yue和zh
#                 temp_scores = {}
#                 for j, prob in enumerate(probabilities):
#                     lang_code = self.id2label.get(j, f"ID_{j}")
#                     lang_name = Language.get(lang_code).language
#
#                     # 将yue统一标记为zh
#                     if lang_name == 'yue':
#                         lang_name = 'zh'
#
#                     # 如果zh或yue已存在，保留概率较高的值
#                     if lang_name in temp_scores:
#                         temp_scores[lang_name] = max(temp_scores[lang_name], float(prob))
#                     else:
#                         temp_scores[lang_name] = float(prob)
#
#                 # 排序并过滤
#                 sorted_scores = sorted(temp_scores.items(), key=lambda item: item[1], reverse=True)
#                 top_scores = [item for item in sorted_scores if item[1] > 0.0002][:5]
#
#                 # 如果预测标签是yue，也转换为zh
#                 if Language.get(predicted_label).language == 'yue':
#                     predicted_label = 'zh'
#                 else:
#                     predicted_label = Language.get(predicted_label).language
#
#                 results_list.append((i, predicted_label, confidence_score, top_scores))
#
#             # 如果你修改了 predict 方法返回元组，这里也需要对应修改
#             # return [(res['label'], res['confidence'], res['top_3_scores']) for res in results_list]
#             return results_list
#
#         except Exception as e:
#             print(f"Error during batch prediction for {len(texts)} texts. First text: '{texts[0][:50]}...': {e}")
#             import traceback
#             traceback.print_exc()
#             # 对于批处理错误，你可能想返回一个列表，其中每个失败的项都是 None 或错误标记
#             return [None] * len(texts)  # 或者更复杂的错误处理



================================================
FILE: ModuleFolders/LLMRequester/AmazonbedrockRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.AnthropicRequester import is_claude3_model
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 接口请求器
class AmazonbedrockRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_amazonbedrock(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        model_name = platform_config.get("model_name")
        if "anthropic" in model_name:
            return self.request_amazonbedrock_anthropic(messages, system_prompt, platform_config)
        else:
            return self.request_amazonbedrock_boto3(messages, system_prompt, platform_config)

    # 发起请求
    def request_amazonbedrock_anthropic(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name:str = platform_config.get("model_name")
            request_timeout = platform_config.get("request_timeout", 60)
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)

            # 从工厂获取客户端
            client = LLMClientFactory().get_anthropic_bedrock(platform_config)

            response = client.messages.create(
                model=model_name,
                system=system_prompt,
                messages=messages,
                temperature=temperature,
                top_p=top_p,
                timeout=request_timeout,
                max_tokens=4096 if is_claude3_model(model_name) else 8192,
            )

            # 提取回复的文本内容
            response_content = response.content[0].text
        except Exception as e:
            self.error(f"翻译任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.prompt_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.completion_tokens)
        except Exception:
            completion_tokens = 0

        return False, "", response_content, prompt_tokens, completion_tokens

    # 发起请求
    def request_amazonbedrock_boto3(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name = platform_config.get("model_name")
            _request_timeout = platform_config.get("request_timeout")
            temperature = platform_config.get("temperature")
            top_p = platform_config.get("top_p")

            # 从工厂获取客户端
            client = LLMClientFactory().get_boto3_bedrock(platform_config)

            # 使用boto3 converse api 调用,
            # 需要把"context":{"text":"message"} 转换为 "content":["text":"message"]
            # 如果messages最后一个元素是assistant，则需要添加{"role":"user","content":[{"text":"continue"}]}
            new_messages = []
            for message in messages:
                new_messages.append({"role": message["role"], "content": [{"text": message["content"]}]})
            if messages[-1]["role"] == "assistant":
                new_messages.append({"role": "user", "content": [{"text": "continue"}]})
            response = client.converse(
                modelId=model_name,
                system=[{"text": system_prompt}],
                messages=new_messages,
                inferenceConfig={"maxTokens": 4096, "temperature": temperature, "topP": top_p},
            )

            # 提取回复的文本内容
            response_content = response["output"]["message"]["content"][0]["text"]
        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response["usage"]["inputTokens"])
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response["usage"]["outputTokens"])
        except Exception:
            completion_tokens = 0

        return False, "", response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/AnthropicRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


def is_claude3_model(model_name):
    """判断是否为Claude 3系列模型"""
    return any(variant in model_name for variant in ["3-haiku", "3-opus", "3-sonnet"])


# 接口请求器
class AnthropicRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_anthropic(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name = platform_config.get("model_name")
            request_timeout = platform_config.get("request_timeout", 60)
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)
            think_switch = platform_config.get("think_switch")
            think_depth = platform_config.get("think_depth")



            # 参数基础配置
            base_params = {
                "model": model_name,
                "system": system_prompt,
                "messages": messages,
                "temperature": temperature,
                "top_p": top_p,
                "timeout": request_timeout,
                "max_tokens": 4096 if is_claude3_model(model_name) else 20000
            }


            # 从工厂获取客户端
            client = LLMClientFactory().get_anthropic_client(platform_config)

            # 发送请求
            response = client.messages.create(**base_params)


            # 提取回复的文本内容
            response_think = ""
            response_content = response.content[0].text

        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.prompt_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.completion_tokens)
        except Exception:
            completion_tokens = 0

        return False, response_think, response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/CohereRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 接口请求器
class CohereRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_cohere(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name = platform_config.get("model_name")
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)
            presence_penalty = platform_config.get("presence_penalty", 0)
            frequency_penalty = platform_config.get("frequency_penalty", 0)

            # 插入系统消息，与openai格式一样
            if system_prompt:
                messages.insert(
                    0,
                    {
                        "role": "system",
                        "content": system_prompt
                    })

            # Cohere SDK 文档 - https://docs.cohere.com/reference/chat
            # 从工厂获取客户端
            client = LLMClientFactory().get_cohere_client(platform_config)

            response = client.chat(
                model=model_name,
                messages=messages,
                temperature=temperature,
                p=top_p,
                presence_penalty=presence_penalty,
                frequency_penalty=frequency_penalty,
                max_tokens=4096,
                safety_mode="NONE",
            )

            # 提取回复的文本内容
            response_content = response.message.content[0].text
        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.tokens.input_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.tokens.output_tokens)
        except Exception:
            completion_tokens = 0

        return False, "", response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/DashscopeRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 因为各家思考模式的开关设置不同.............................
class DashscopeRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_openai(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            # 获取具体配置
            model_name = platform_config.get("model_name")
            request_timeout = platform_config.get("request_timeout", 60)
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)
            presence_penalty = platform_config.get("presence_penalty", 0)
            frequency_penalty = platform_config.get("frequency_penalty", 0)
            extra_body = platform_config.get("extra_body", "{}")
            think_switch = platform_config.get("think_switch")

            # 插入系统消息
            if system_prompt:
                messages.insert(
                    0,
                    {
                        "role": "system",
                        "content": system_prompt
                    })

            # 参数基础配置
            base_params = {
                "model": model_name,
                "messages": messages,
                "timeout": request_timeout,
                "stream": False
            }

            # 按需添加参数
            if temperature != 1:
                base_params.update({
                    "temperature": temperature,
                })

            if top_p != 1:
                base_params.update({
                    "top_p": top_p,
                })

            if presence_penalty != 0:
                base_params.update({
                    "presence_penalty": presence_penalty,
                })

            if frequency_penalty != 0:
                base_params.update({
                    "frequency_penalty": frequency_penalty
                })

            # 开启思考开关时添加参数，阿里云官方要求必须工作在流模式下，有点蠢
            if think_switch:
                base_params.update({
                    "extra_body": {"enable_thinking": "true"}
                })

            # 从工厂获取客户端
            client = LLMClientFactory().get_openai_client(platform_config)

            # 发起请求
            response = client.chat.completions.create(**base_params)

            # 提取回复内容
            message = response.choices[0].message

            # 自适应提取推理过程
            if "</think>" in message.content:
                splited = message.content.split("</think>")
                response_think = splited[0].removeprefix("<think>").replace("\n\n", "\n")
                response_content = splited[-1]
            else:
                try:
                    response_think = message.reasoning_content
                    if not response_think:
                        response_think = ""
                except Exception:
                    response_think = ""
                response_content = message.content

        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.prompt_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.completion_tokens)
        except Exception:
            completion_tokens = 0

        return False, response_think, response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/GoogleRequester.py
================================================
from google.genai import types
from google.genai.types import Content, HarmCategory, Part

from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 接口请求器
class GoogleRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_google(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name = platform_config.get("model_name")
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)
            presence_penalty = platform_config.get("presence_penalty", 0.0)
            frequency_penalty = platform_config.get("frequency_penalty", 0.0)
            think_switch = platform_config.get("think_switch")
            thinking_budget = platform_config.get("thinking_budget")

            # 重新处理openai格式的消息为google格式
            processed_messages = [
                Content(
                    role="model" if m["role"] == "assistant" else m["role"],
                    parts=[Part.from_text(text=m["content"])]
                )
                for m in messages if m["role"] != "system"
            ]

            # 创建 Gemini Developer API 客户端（非 Vertex AI API）
            client = LLMClientFactory().get_google_client(platform_config)

            # 定义适用于文本模型的安全类别
            TEXT_HARM_CATEGORIES = [
                HarmCategory.HARM_CATEGORY_HARASSMENT,
                HarmCategory.HARM_CATEGORY_HATE_SPEECH,
                HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
                HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
            ]
            
            # 构建基础配置
            gen_config = types.GenerateContentConfig(
                system_instruction=system_prompt,
                max_output_tokens=65536 if model_name.startswith("gemini-2.5") else 8192,
                temperature=temperature,
                top_p=top_p,
                safety_settings=[
                    types.SafetySetting(category=category, threshold='BLOCK_NONE')
                    for category in TEXT_HARM_CATEGORIES
                ]
            )

            # 如果开启了思考模式，则添加思考配置
            if think_switch:
                gen_config.thinking_config = types.ThinkingConfig(
                    include_thoughts=True,
                    thinking_budget=thinking_budget
                )

            # 生成文本内容
            response = client.models.generate_content(
                model=model_name,
                contents=processed_messages,
                config=gen_config,
            )

            # 初始化思考内容和回复内容
            response_think = ""
            response_content = ""

            # 根据Google API文档，思考内容和回复内容在不同的 "parts" 中
            # 遍历这些 parts 来分别提取它们
            if response.candidates and response.candidates[0].content.parts:
                for part in response.candidates[0].content.parts:
                    if not part.text:
                        continue
                    # 检查 part 是否包含思考内容 (part.thought is True)
                    # 使用 hasattr 增加代码健壮性
                    if hasattr(part, 'thought') and part.thought:
                        response_think += part.text
                    else:
                        # 否则，这是常规的回复内容
                        response_content += part.text
            else:
                # 作为后备方案，如果 response.candidates[0].content.parts 不存在或为空
                # 尝试直接获取 .text 属性，这通常只包含最终回复
                response_content = response.text

        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None
        
        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage_metadata.prompt_token_count)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage_metadata.candidates_token_count)
        except Exception:
            completion_tokens = 0

        return False, response_think, response_content, prompt_tokens, completion_tokens


================================================
FILE: ModuleFolders/LLMRequester/LLMClientFactory.py
================================================
# LLMClientFactory.py
import threading
from typing import Dict, Any
import httpx
from openai import OpenAI
import anthropic
import boto3
import cohere
from google import genai
import json


def create_httpx_client(
        http2=True,
        max_connections=256,
        max_keepalive_connections=128,
        keepalive_expiry=30,
        **kwargs
):
    """
    创建配置好的HTTP客户端

    参数:
        http2: 是否启用HTTP/2
        max_connections: 最大并发连接数
        max_keepalive_connections: 最大保持活跃的连接数
        keepalive_expiry: 连接保持活跃的秒数
        **kwargs: 传递给httpx.Client的其他参数

    返回:
        配置好的httpx.Client实例
    """
    return httpx.Client(
        http2=http2,
        limits=httpx.Limits(
            max_connections=max_connections,
            max_keepalive_connections=max_keepalive_connections,
            keepalive_expiry=keepalive_expiry
        ),
        **kwargs
    )


class LLMClientFactory:
    """LLM客户端工厂 - 集中管理和缓存不同类型的LLM客户端"""

    _instance = None
    _lock = threading.RLock()

    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super(LLMClientFactory, cls).__new__(cls)
                cls._instance._clients = {}
            return cls._instance

    def get_openai_client(self, config: Dict[str, Any]) -> OpenAI:
        """获取OpenAI客户端"""
        # 展示需要到的配置项
        api_key = config.get("api_key")
        api_url = config.get("api_url")
        key = ("openai", api_url, api_key)
        return self._get_cached_client(key, lambda: self._create_openai_client(config, api_key))

    def get_openai_client_local(self, config: Dict[str, Any]) -> OpenAI:
        """获取OpenAI客户端"""
        api_key = config.get("api_key")
        if not api_key:
            api_key = "none_api_key"
        api_url = config.get("api_url")
        key = ("openai_local", api_url, api_key)
        return self._get_cached_client(key, lambda: self._create_openai_client(config, api_key))

    def get_openai_client_sakura(self, config: Dict[str, Any]) -> OpenAI:
        """获取OpenAI客户端"""
        api_key = config.get("api_key")
        if not api_key:
            api_key = "none_api_key"
        api_url = config.get("api_url")
        key = ("openai_sakura", api_url, api_key)
        return self._get_cached_client(key, lambda: self._create_openai_client(config, api_key))

    def get_anthropic_client(self, config: Dict[str, Any]) -> anthropic.Anthropic:
        """获取Anthropic客户端"""
        api_key = config.get("api_key")
        api_url = config.get("api_url")
        key = ("anthropic", api_url, api_key)
        return self._get_cached_client(key, lambda: self._create_anthropic_client(config))

    def get_anthropic_bedrock(self, config: Dict[str, Any]) -> anthropic.AnthropicBedrock:
        """获取AnthropicBedrock客户端"""
        region = config.get("region")
        access_key = config.get("access_key")
        secret_key = config.get("secret_key")
        key = ("anthropic_bedrock", region, access_key, secret_key)
        return self._get_cached_client(key, lambda: self._create_anthropic_bedrock(config))

    def get_boto3_bedrock(self, config: Dict[str, Any]) -> Any:
        """获取boto3 bedrock客户端"""
        region = config.get("region")
        access_key = config.get("access_key")
        secret_key = config.get("secret_key")
        key = ("boto3_bedrock", region, access_key, secret_key)
        return self._get_cached_client(key, lambda: self._create_boto3_bedrock(config))

    def get_cohere_client(self, config: Dict[str, Any]) -> cohere.ClientV2:
        """获取Cohere客户端"""
        api_key = config.get("api_key")
        api_url = config.get("api_url")
        key = ("cohere", api_url, api_key)
        return self._get_cached_client(key, lambda: self._create_cohere_client(config))

    def get_google_client(self, config: Dict[str, Any]) -> genai.Client:
        """获取Google AI客户端"""
        api_key = config.get("api_key")
        api_url = config.get("api_url")
        extra_body = config.get("extra_body", {})
        extra_body_serialized = json.dumps(extra_body, sort_keys=True) if extra_body else None
        key = ("google", api_key, api_url, extra_body_serialized)
        return self._get_cached_client(key, lambda: self._create_google_client(config))

    def _get_cached_client(self, key, factory_func):
        """线程安全地获取或创建客户端"""
        if key not in self._clients:
            with self._lock:
                if key not in self._clients:
                    self._clients[key] = factory_func()
        return self._clients[key]

    # 各种客户端创建函数
    def _create_openai_client(self, config, api_key):
        return OpenAI(
            base_url=config.get("api_url"),
            api_key=api_key,
            http_client=create_httpx_client()
        )

    def _create_anthropic_client(self, config):
        return anthropic.Anthropic(
            base_url=config.get("api_url"),
            api_key=config.get("api_key"),
            http_client=create_httpx_client()
        )

    def _create_anthropic_bedrock(self, config):
        return anthropic.AnthropicBedrock(
            aws_region=config.get("region"),
            aws_access_key=config.get("access_key"),
            aws_secret_key=config.get("secret_key"),
            http_client=create_httpx_client()
        )

    def _create_boto3_bedrock(self, config):
        return boto3.client(
            "bedrock-runtime",
            region_name=config.get("region"),
            aws_access_key_id=config.get("access_key"),
            aws_secret_access_key=config.get("secret_key")
        )

    def _create_cohere_client(self, config):
        return cohere.ClientV2(
            base_url=config.get("api_url"),
            api_key=config.get("api_key"),
            timeout=config.get("request_timeout", 60),
            httpx_client=create_httpx_client()
        )

    def _create_google_client(self, config):
        api_key = config.get("api_key")
        api_url = config.get("api_url")
        extra_body = config.get("extra_body")

        http_options = {}
        if api_url:
            http_options["base_url"] = api_url
        if extra_body:
            http_options["extra_body"] = extra_body

        if http_options:
            return genai.Client(api_key=api_key, http_options=http_options)
        else:
            return genai.Client(api_key=api_key)



================================================
FILE: ModuleFolders/LLMRequester/LLMRequester.py
================================================
from ModuleFolders.LLMRequester.SakuraRequester import SakuraRequester
from ModuleFolders.LLMRequester.LocalLLMRequester import LocalLLMRequester
from ModuleFolders.LLMRequester.CohereRequester import CohereRequester
from ModuleFolders.LLMRequester.GoogleRequester import GoogleRequester
from ModuleFolders.LLMRequester.AnthropicRequester import AnthropicRequester
from ModuleFolders.LLMRequester.AmazonbedrockRequester import AmazonbedrockRequester
from ModuleFolders.LLMRequester.OpenaiRequester import OpenaiRequester
from ModuleFolders.LLMRequester.DashscopeRequester import DashscopeRequester

# 接口请求器
class LLMRequester():
    def __init__(self) -> None:
        pass

    # 分发请求
    def sent_request(self, messages: list[dict], system_prompt: str, platform_config: dict) -> tuple[bool, str, str, int, int]:
        # 获取平台参数
        target_platform = platform_config.get("target_platform")
        api_format = platform_config.get("api_format")

        # 发起请求
        if target_platform == "sakura":
            sakura_requester = SakuraRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = sakura_requester.request_sakura(
                messages,
                system_prompt,
                platform_config,
            )
        elif target_platform == "LocalLLM":
            local_llm_requester = LocalLLMRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = local_llm_requester.request_LocalLLM(
                messages,
                system_prompt,
                platform_config,
            )
        elif target_platform == "cohere":
            cohere_requester = CohereRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = cohere_requester.request_cohere(
                messages,
                system_prompt,
                platform_config,
            )
        elif target_platform == "google" or (target_platform.startswith("custom_platform_") and api_format == "Google"):
            google_requester = GoogleRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = google_requester.request_google(
                messages,
                system_prompt,
                platform_config,
            )
        elif target_platform == "anthropic" or (target_platform.startswith("custom_platform_") and api_format == "Anthropic"):
            anthropic_requester = AnthropicRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = anthropic_requester.request_anthropic(
                messages,
                system_prompt,
                platform_config,
            )
        elif target_platform == "amazonbedrock":
            amazonbedrock_requester = AmazonbedrockRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = amazonbedrock_requester.request_amazonbedrock(
                messages,
                system_prompt,
                platform_config,
            )
        elif target_platform == "dashscope":
            dashscope_requester = DashscopeRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = dashscope_requester.request_openai(
                messages,
                system_prompt,
                platform_config,
            )
        else:
            openai_requester = OpenaiRequester()
            skip, response_think, response_content, prompt_tokens, completion_tokens = openai_requester.request_openai(
                messages,
                system_prompt,
                platform_config,
            )

        return skip, response_think, response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/LocalLLMRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 接口请求器
class LocalLLMRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_LocalLLM(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name = platform_config.get("model_name")
            request_timeout = platform_config.get("request_timeout", 60)
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)
            frequency_penalty = platform_config.get("frequency_penalty", 0)
            think_switch = platform_config.get("think_switch")

            # 参数基础配置
            base_params = {
                "model": model_name,
                "messages": messages,
                "timeout": request_timeout
            }

            # 按需添加参数
            if temperature != 1:
                base_params.update({
                    "temperature": temperature,
                })

            if top_p != 1:
                base_params.update({
                    "top_p": top_p,
                })

            if frequency_penalty != 0:
                base_params.update({
                    "frequency_penalty": frequency_penalty
                })

            # 假如打开了思考开关
            if think_switch:
                base_params.update({
                    "extra_body": {"enable_thinking": "true"}
                })


            # 插入系统消息
            if system_prompt:
                messages.insert(
                    0,
                    {
                        "role": "system",
                        "content": system_prompt
                    })

            # 从工厂获取客户端
            client = LLMClientFactory().get_openai_client_local(platform_config)

            response = client.chat.completions.create(**base_params)

            # 提取回复内容
            message = response.choices[0].message

            # 自适应提取推理过程
            if "</think>" in message.content:
                splited = message.content.split("</think>")
                response_think = splited[0].removeprefix("<think>").replace("\n\n", "\n")
                response_content = splited[-1]
            else:
                try:
                    response_think = message.reasoning_content
                    if not response_think:
                        response_think = ""
                except Exception:
                    response_think = ""
                response_content = message.content

        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.prompt_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.completion_tokens)
        except Exception:
            completion_tokens = 0

        return False, response_think, response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/OpenaiRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 接口请求器
class OpenaiRequester(Base):
    def __init__(self) -> None:
        pass

    # 发起请求
    def request_openai(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            # 获取具体配置
            model_name = platform_config.get("model_name")
            request_timeout = platform_config.get("request_timeout", 60)
            temperature = platform_config.get("temperature", 1.0)
            top_p = platform_config.get("top_p", 1.0)
            presence_penalty = platform_config.get("presence_penalty", 0)
            frequency_penalty = platform_config.get("frequency_penalty", 0)
            extra_body = platform_config.get("extra_body", "{}")
            think_switch = platform_config.get("think_switch")
            think_depth = platform_config.get("think_depth")

            # 插入系统消息
            if system_prompt:
                messages.insert(
                    0,
                    {
                        "role": "system",
                        "content": system_prompt
                    })

            # 从工厂获取客户端
            client = LLMClientFactory().get_openai_client(platform_config)

            # 针对ds模型的特殊处理，因为该模型不支持模型预输入回复
            if 'deepseek' in model_name.lower():
                # 检查一下最后的消息是否用户消息，以免误删。(用户使用了推理模型卻不切换为推理模型提示词的情况)
                if messages and isinstance(messages[-1], dict) and messages[-1].get('role') != 'user':
                    messages = messages[:-1]  # 移除最后一个元素


            # 参数基础配置
            base_params = {
                "extra_body": extra_body,
                "model": model_name,
                "messages": messages,
                "timeout": request_timeout,
                "stream": False
            }

            # 按需添加参数
            if temperature != 1:
                base_params.update({
                    "temperature": temperature,
                })

            if top_p != 1:
                base_params.update({
                    "top_p": top_p,
                })

            if presence_penalty != 0:
                base_params.update({
                    "presence_penalty": presence_penalty,
                })

            if frequency_penalty != 0:
                base_params.update({
                    "frequency_penalty": frequency_penalty
                })


            # 开启思考开关时添加参数
            if think_switch:
                base_params.update({
                    "reasoning_effort": think_depth
                })


            # 发起请求
            response = client.chat.completions.create(**base_params)


            # 提取回复内容
            message = response.choices[0].message

            # 自适应提取推理过程
            if "</think>" in message.content:
                splited = message.content.split("</think>")
                response_think = splited[0].removeprefix("<think>").replace("\n\n", "\n")
                response_content = splited[-1]
            else:
                try:
                    response_think = message.reasoning_content
                    if not response_think:
                        response_think = ""
                except Exception:
                    response_think = ""
                response_content = message.content

        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.prompt_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.completion_tokens)
        except Exception:
            completion_tokens = 0

        return False, response_think, response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/LLMRequester/SakuraRequester.py
================================================
from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory


# 接口请求器
class SakuraRequester(Base):
    def __init__(self):
        pass

    # 发起请求
    def request_sakura(self, messages, system_prompt, platform_config) -> tuple[bool, str, str, int, int]:
        try:
            model_name = platform_config.get("model_name")
            request_timeout = platform_config.get("request_timeout", 60)
            temperature = platform_config.get("temperature", 0.1)
            top_p = platform_config.get("top_p", 0.3)
            frequency_penalty = platform_config.get("frequency_penalty", 0)

            # 插入系统消息
            if system_prompt:
                messages.insert(
                    0,
                    {
                        "role": "system",
                        "content": system_prompt
                    })

            # 从工厂获取客户端
            client = LLMClientFactory().get_openai_client_sakura(platform_config)

            response = client.chat.completions.create(
                model=model_name,
                messages=messages,
                top_p=top_p,
                temperature=temperature,
                frequency_penalty=frequency_penalty,
                timeout=request_timeout,
                max_tokens=512,
                extra_query={
                    "do_sample": True,
                    "num_beams": 1,
                    "repetition_penalty": 1.0
                },
            )

            # 提取回复的文本内容
            response_content = response.choices[0].message.content
        except Exception as e:
            self.error(f"请求任务错误 ... {e}", e if self.is_debug() else None)
            return True, None, None, None, None

        # 获取指令消耗
        try:
            prompt_tokens = int(response.usage.prompt_tokens)
        except Exception:
            prompt_tokens = 0

        # 获取回复消耗
        try:
            completion_tokens = int(response.usage.completion_tokens)
        except Exception:
            completion_tokens = 0

        # Sakura 返回的内容多行文本，将其转换为 textarea标签包裹，方便提取
        response_content = "<textarea>\n" + response_content + "\n</textarea>"

        return False, "", response_content, prompt_tokens, completion_tokens



================================================
FILE: ModuleFolders/NERProcessor/NERProcessor.py
================================================
import os
import spacy
import sudachipy
import sudachidict_core
import threading
from Base.Base import Base

class NERProcessor(Base):
    # 将过滤器关键字提升为类常量，方便管理

    FILTER_KEYWORDS = ('-', '…', '一','―','？', '©', '章　', 'ー', 'http', '！', '=', '"', '＋', '：', '『', 'ぃ', '～', '♦', '〇',
                    '└', "'", "/", "｢", "）", "（", "♥", "●", "!", "】", "【", "<", ">", "*", "〜", "EV", "♪", "^", "★", "※", ".",
                        "|","ｰ","%","if","Lv","(","\\","]","[","◆",":","_","ｗｗｗ","、","ぁぁ","んえ","んんん",
                    )

    def __init__(self):
        super().__init__()
        self.nlp_models = {}
        # 锁用于确保在多线程环境中模型只被加载一次
        self.nlp_lock = threading.Lock()

    def _load_model(self, model_name: str):
        """
        按需加载 spaCy 模型，确保线程安全。
        这是一个内部方法。
        """
        if not model_name:
            self.error(f"未提供模型名称。")
            return None

        # 使用锁来安全地检查和加载模型
        with self.nlp_lock:
            if model_name in self.nlp_models:
                return self.nlp_models[model_name]

            model_path = os.path.join('.', 'Resource', 'Models', 'ner', model_name)

            if not os.path.exists(model_path):
                self.error(f"模型路径不存在: {model_path}")
                return None

            self.info(f"正在加载 spaCy 模型: {model_name}...")

            # 只加载ner组件，禁用其他所有组件
            nlp = spacy.load(
                model_path,
                exclude=["parser", "tagger", "lemmatizer", "attribute_ruler", "tok2vec"]
            )
            self.nlp_models[model_name] = nlp
            self.info(f"模型 {model_name} 加载成功。")
            return nlp

    def _deduplicate_results(self, results: list) -> list:
        """
        对提取的术语列表进行去重。
        去重逻辑: 基于小写的术语文本和实体类型。
        """
        self.info(f"初步提取到 {len(results)} 个实体。正在去重...")

        unique_items = {}
        for res in results:
            # 使用小写术语和类型作为唯一标识符
            identifier = (res["term"].lower(), res["type"])
            if identifier not in unique_items:
            # 首次遇到，存入完整结果并初始化次数为1
                unique_items[identifier] = res.copy() # 使用copy避免修改原始列表
                unique_items[identifier]['count'] = 1
            else:
            # 已存在，次数加1
                unique_items[identifier]['count'] += 1

    # 从字典的值中构建最终列表
        unique_results = list(unique_items.values())

        self.info(f"去重后得到 {len(unique_results)} 个独立术语。")
        return unique_results

    def _filter_results(self, results: list) -> list:
        """
        根据一系列规则过滤术语列表。
        """
        self.info("正在根据规则过滤术语...")

        # 规则 1: 过滤包含特定禁用关键字的术语
        results_after_keywords = [
            res for res in results
            if not any(keyword in res["term"] for keyword in self.FILTER_KEYWORDS)
        ]
        self.info(f"过滤关键字后剩余 {len(results_after_keywords)} 个术语。")

        # 规则 2 & 3: 过滤纯数字和英文数字组合
        final_filtered_results = []
        for res in results_after_keywords:
            term = res["term"]
            # 创建一个用于检查的临时版本，移除所有半角和全角空格
            term_for_check = term.replace(" ", "").replace("\u3000", "")

            # 规则 2: 如果移除空格后是纯数字，则过滤
            if term_for_check.isdigit():
                continue

            # 规则 3: 如果移除空格后是字母和数字的组合，则过滤
            # 条件: (只包含字母和数字) 并且 (不全是字母)
            if term_for_check.isalnum() and not term_for_check.isalpha():
                continue

            # 如果通过所有检查，则保留该术语
            final_filtered_results.append(res)

        self.info(f"过滤数字与字母数字组合后剩余 {len(final_filtered_results)} 个术语。")
        return final_filtered_results

    def _sort_results(self, results: list) -> list:
        """
        按实体类型对结果列表进行排序。
        """
        self.info("正在按类型对术语进行排序...")
        return sorted(results, key=lambda item: item['type'])

    def extract_terms(self, items_data: list, model_name: str, entity_types: list) -> list:
        """
        从提供的原文数据列表中提取、去重、过滤和排序命名实体。

        Args:
            items_data (list): 包含待处理数据的列表。
            model_name (str): 要使用的模型名称 (文件夹名)。
            entity_types (list): 需要提取的实体类型标签列表。

        Returns:
            list: 包含最终处理结果的字典列表。
        """
        nlp = self._load_model(model_name)
        if not nlp:
            return []

        total_items = len(items_data)
        self.info(f"开始对 {total_items} 条原文进行实体识别...")

        raw_results = []
        processed_count = 0

        # 步骤 1: 从文本中提取原始实体
        for item_data in items_data:
            source_text = item_data.get("source_text")
            file_path = item_data.get("file_path")

            if not source_text or not source_text.strip():
                continue

            doc = nlp(source_text)
            for ent in doc.ents:
                if ent.label_ in entity_types:
                    raw_results.append({
                        "term": ent.text,
                        "type": ent.label_,
                        "context": source_text,
                        "file_path": file_path,
                    })

            processed_count += 1
            if processed_count % 50 == 0 or processed_count == total_items:
                self.info(f"实体识别进度: {processed_count}/{total_items}...")

        # 步骤 2: 对提取结果进行去重
        unique_results = self._deduplicate_results(raw_results)

        # 步骤 3: 对去重后的结果进行过滤
        filtered_results = self._filter_results(unique_results)

        # 步骤 4: 对过滤后的结果进行排序
        sorted_results = self._sort_results(filtered_results)

        self.info(f"处理完成，最终返回 {len(sorted_results)} 个术语。")
        return sorted_results


================================================
FILE: ModuleFolders/PromptBuilder/PromptBuilder.py
================================================
import re
from types import SimpleNamespace

from Base.Base import Base
from ModuleFolders.TaskExecutor import TranslatorUtil
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig
from ModuleFolders.PromptBuilder.PromptBuilderEnum import PromptBuilderEnum
class PromptBuilder(Base):
    def __init__(self) -> None:
        super().__init__()

    # 获取默认系统提示词(未处理的)，优先从内存中读取，如果没有，则从文件中读取
    def get_system_default(config: TaskConfig, prompt_preset) -> str:
        if getattr(PromptBuilder, "common_system_zh", None) == None:
            with open("./Resource/Prompt/Translate/common_system_zh.txt", "r", encoding = "utf-8") as reader:
                PromptBuilder.common_system_zh = reader.read().strip()
        if getattr(PromptBuilder, "common_system_en", None) == None:
            with open("./Resource/Prompt/Translate/common_system_en.txt", "r", encoding = "utf-8") as reader:
                PromptBuilder.common_system_en = reader.read().strip()
        if getattr(PromptBuilder, "cot_system_zh", None) == None:
            with open("./Resource/Prompt/Translate/cot_system_zh.txt", "r", encoding = "utf-8") as reader:
                PromptBuilder.cot_system_zh = reader.read().strip()
        if getattr(PromptBuilder, "cot_system_en", None) == None:
            with open("./Resource/Prompt/Translate/cot_system_en.txt", "r", encoding = "utf-8") as reader:
                PromptBuilder.cot_system_en = reader.read().strip()
        if getattr(PromptBuilder, "think_system_zh", None) == None:
            with open("./Resource/Prompt/Translate/think_system_zh.txt", "r", encoding = "utf-8") as reader:
                PromptBuilder.think_system_zh = reader.read().strip()
        if getattr(PromptBuilder, "think_system_en", None) == None:
            with open("./Resource/Prompt/Translate/think_system_en.txt", "r", encoding = "utf-8") as reader:
                PromptBuilder.think_system_en = reader.read().strip()


        # 如果输入的是字典，则转换为命名空间
        if isinstance(config, dict):
            namespace = SimpleNamespace()
            for key, value in config.items():
                setattr(namespace, key, value)
            config = namespace

        # 构造结果
        if prompt_preset == PromptBuilderEnum.COMMON and config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.common_system_zh
        elif prompt_preset == PromptBuilderEnum.COMMON and config.target_language not in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.common_system_en
        elif prompt_preset == PromptBuilderEnum.COT and config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.cot_system_zh
        elif prompt_preset == PromptBuilderEnum.COT and config.target_language not in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.cot_system_en
        elif prompt_preset == PromptBuilderEnum.THINK and config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.think_system_zh
        elif prompt_preset == PromptBuilderEnum.THINK and config.target_language not in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.think_system_en
        else:
            result = PromptBuilder.common_system_zh

        return result

    # 获取系统提示词(处理好的)
    def build_system(config: TaskConfig, source_lang: str) -> str:
        # 获取默认系统提示词
        PromptBuilder.get_system_default(config, "")

        # 语言信息转换
        en_sl, source_language, en_tl, target_language = TranslatorUtil.get_language_display_names(source_lang, config.target_language)

        # 构造结果
        if config == None:
            result = PromptBuilder.common_system_zh
        elif config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.COMMON and config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.common_system_zh
        elif config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.COMMON and config.target_language not in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.common_system_en
            source_language = en_sl
            target_language = en_tl
        elif config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.COT and config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.cot_system_zh
        elif config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.COT and config.target_language not in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.cot_system_en
            source_language = en_sl
            target_language = en_tl
        elif config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.THINK and config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.think_system_zh
        elif config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.THINK and config.target_language not in ("chinese_simplified", "chinese_traditional"):
            result = PromptBuilder.think_system_en
            source_language = en_sl
            target_language = en_tl


        return result.replace("{source_language}", source_language).replace("{target_language}", target_language).strip()

    # 替换提示词文本中的源语言和目标语言占位符
    def _replace_language_placeholders(prompt_text: str, config: TaskConfig, source_lang: str) -> str:
        """
        替换提示词文本中的源语言和目标语言占位符。
        """
        # 获取语言的显示名称（本地化和英文）
        en_sl, source_language, en_tl, target_language = TranslatorUtil.get_language_display_names(source_lang, config.target_language)

        # 如果目标语言不是中文，则统一使用英文名称以获得更好的LLM兼容性
        if config.target_language not in ("chinese_simplified", "chinese_traditional"):
            source_language = en_sl
            target_language = en_tl
        
        # 执行替换并返回
        return prompt_text.replace("{source_language}", source_language).replace("{target_language}", target_language)

    # 构建翻译示例
    def build_translation_sample(config: TaskConfig, input_dict: dict, source_lang) -> tuple[str, str]:
        list1 = []
        list3 = []
        list2 = []
        list4 = []

        conv_source_lang = TranslatorUtil.map_language_code_to_name(source_lang)
        if conv_source_lang == 'un':
            return "", ""
            #conv_source_lang = TranslatorUtil.map_language_code_to_name(source_lang.most_common)

        # 检测原文语言是否能够构建动态示例
        if conv_source_lang not in ["japanese", "korean", "russian", "chinese_simplified", "chinese_traditional", "french",
                                "german", "spanish", "english", "indonesian"]:
            return "", ""

        # 获取自适应示例（无法构建english的）
        if conv_source_lang in ["japanese", "korean", "russian", "chinese_simplified", "chinese_traditional", "french",
                                "german", "spanish", "indonesian"]:
            list2, list4 = PromptBuilder.build_adaptive_translation_sample(config, input_dict, conv_source_lang)

        # 将两个列表合并
        combined_list = list1 + list2
        combined_list2 = list3 + list4

        # 如果前面都没能构成动态示例，则根据语言添加基础示例
        if not combined_list:
            base_example = {
                "base": {
                    "japanese": "例示テキスト",
                    "korean": "예시 텍스트",
                    "russian": "Пример текста",
                    "chinese_simplified": "示例文本",
                    "chinese_traditional": "翻譯示例文本",
                    "english": "Sample Text",
                    "spanish": "Texto de ejemplo",
                    "french": "Exemple de texte",
                    "german": "Beispieltext",
                    "indonesian": "Contoh Teks",
                }
            }

            # 如果没有对应的示例语言，默认使用英文
            source_base_example = base_example["base"].get(conv_source_lang, "Sample Text")
            combined_list.append(source_base_example)
            combined_list2.append(base_example["base"][config.target_language])

        # 限制示例总数量为3个，如果多了，则从最后往前开始削减
        if len(combined_list) > 3:
            combined_list = combined_list[:3]
            combined_list2 = combined_list2[:3]

        # 创建空字典
        source_dict = {}
        target_dict = {}
        source_str = ""
        target_str = ""

        # 遍历合并后的列表，并创建键值对
        for index, value in enumerate(combined_list):
            source_dict[str(index)] = value
        for index, value in enumerate(combined_list2):
            target_dict[str(index)] = value

        # 将原文本字典转换成行文本，并加上数字序号
        if source_dict:

            # 构建原文示例
            numbered_lines = []
            for index, line in enumerate(source_dict.values()):
                # 检查是否为多行文本
                if "\n" in line:
                    lines = line.split("\n")
                    numbered_text = f"{index + 1}.[\n"
                    total_lines = len(lines)
                    for sub_index, sub_line in enumerate(lines):
                        numbered_text += f'"{index + 1}.{total_lines - sub_index}.,{sub_line}",\n'
                    numbered_text = numbered_text.rstrip('\n')
                    numbered_text = numbered_text.rstrip(',')
                    numbered_text += f"\n]"  # 用json.dumps会影响到原文的转义字符
                    numbered_lines.append(numbered_text)
                else:
                    # 单行文本直接添加序号
                    numbered_lines.append(f"{index + 1}.{line}")

            source_str = "\n".join(numbered_lines)


            # 构建译文示例
            target_numbered_lines = []
            for index, line in enumerate(target_dict.values()):
                # 检查是否为多行文本
                if "\n" in line:
                    lines = line.split("\n")
                    numbered_text = f"{index + 1}.[\n"
                    total_lines = len(lines)
                    for sub_index, sub_line in enumerate(lines):
                        numbered_text += f'"{index + 1}.{total_lines - sub_index}.,{sub_line}",\n'
                    numbered_text = numbered_text.rstrip('\n')
                    numbered_text = numbered_text.rstrip(',')
                    numbered_text += f"\n]"  # 用json.dumps会影响到原文的转义字符
                    target_numbered_lines.append(numbered_text)
                else:
                    # 单行文本直接添加序号
                    target_numbered_lines.append(f"{index + 1}.{line}")


            target_str = "\n".join(target_numbered_lines)



        return source_str, target_str

    # 辅助函数，清除列表过多相似的元素
    def clean_list(lst) -> list[str]:
        # 函数用于删除集合中的数字
        def remove_digits(s) -> set:
            return set(filter(lambda x: not x.isdigit(), s))

        # 函数用于计算两个集合之间的差距
        def set_difference(s1, s2) -> int:
            return len(s1.symmetric_difference(s2))

        # 删除每个元素中的数字，并得到一个由集合组成的列表
        sets_list = [remove_digits(s) for s in lst]

        # 初始化聚类列表
        clusters = []

        # 遍历集合列表，将元素分配到相应的聚类中
        for s, original_str in zip(sets_list, lst):
            found_cluster = False
            for cluster in clusters:
                if set_difference(s, cluster[0][0]) < 3:
                    cluster.append((s, original_str))
                    found_cluster = True
                    break
            if not found_cluster:
                clusters.append([(s, original_str)])

        # 从每个聚类中提取一个元素，组成新的列表
        result = [cluster[0][1] for cluster in clusters]

        return result

    # 辅助函数，重新调整列表中翻译示例的后缀数字
    def replace_and_increment(items, prefix) -> list[str]:
        pattern = re.compile(r"{}(\d{{1,2}})".format(re.escape(prefix)))  # 使用双括号来避免KeyError
        result = []  # 用于存储结果的列表
        n = 0
        p = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

        for item in items:
            if pattern.search(item):  # 如果在元素中找到匹配的模式
                new_item = item
                j = 1  # 初始化 j
                while True:

                    # 正则匹配
                    match = pattern.search(new_item)

                    # 如果没有匹配到，退出
                    if not match:
                        break

                    # 防止列表循环越界
                    if n >= 24:
                        #print("bug")
                        n = 0

                    # 替换示例文本后缀
                    new_item = new_item[:match.start()] + f"{prefix}{p[n]}-{j}" + new_item[match.end():]

                    # 在每次替换后递增 j
                    j += 1

                # 替换完之后添加进结果列表
                result.append(new_item)

                # 变量n递增
                n += 1
            else:
                result.append(item)  # 如果没有匹配，将原始元素添加到结果列表

        return result  # 返回修改后的列表

    # 构建相似格式翻译示例
    def build_adaptive_translation_sample(config: TaskConfig, input_dict: dict, conv_source_lang: str) -> tuple[list[str], list[str]]:
        # 输入字典示例
        # ex_dict = {
        #     "0": "こんにちは，こんにちは。こんにちは#include <iostream>",
        #     "1": "55345こんにちは",
        #     "2": "こんにちはxxxx！",
        #     "3": "こんにちは",
        # }

        # 输出列表1示例
        # ex_dict = [
        #     "原文テキストA-1，原文テキストA-2。原文テキストA-3#include <iostream>",
        #     "55345原文テキストB-1",
        #     "原文テキストC-1xxxx！",
        # ]

        # 输出列表2示例
        # ex_dict = [
        #     "译文文本A-1，译文文本A-2。译文文本A-3#include <iostream>",
        #     "55345译文文本B-1",
        #     "译文文本C-1xxxx！",
        # ]

        # 定义不同语言的正则表达式
        patterns_all = {
            "japanese": re.compile(
                r"["
                r"\u3041-\u3096"  # 平假名
                r"\u30A0-\u30FF"  # 片假名
                r"\u4E00-\u9FAF"  # 汉字
                "]+",
                re.UNICODE,
            ),
            "korean": re.compile(r"[\uAC00-\uD7AF]+", re.UNICODE),  # 韩文字母
            "russian": re.compile(r"[\u0400-\u04FF]+", re.UNICODE),  # russian字母
            "chinese_simplified": re.compile(r"[\u4E00-\u9FA5]+", re.UNICODE),  # 简体中文
            "chinese_traditional": re.compile(r"[\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]+", re.UNICODE),
            "spanish": re.compile(
                r"[a-zA-ZÁÉÍÓÚÑáéíóúñÜü]+",  # 覆盖spanish特殊字符
                re.UNICODE
            ),
            "french": re.compile(
                r"[a-zA-ZÀ-ÿ]+",  # 覆盖所有法语重音字符
                re.UNICODE
            ),
            "german": re.compile(
                r"[a-zA-ZÄÖÜäöüß]+",  # 德语特殊字符
                re.UNICODE
            ),
            "indonesian": re.compile( # 印尼语的正则表达式
                r"[a-zA-ZÀ-ÿ]+",      # 使用一个通用的拉丁字母匹配模式
                re.UNICODE
            ),
        }

        # 定义不同语言的翻译示例
        text_all = {
            "japanese": "例示テキスト",
            "korean": "예시 텍스트",
            "russian": "Пример текста",
            "chinese_simplified": "示例文本",
            "chinese_traditional": "翻譯示例文本",
            "english": "Sample Text",
            "spanish": "Texto de ejemplo",
            "french": "Exemple de texte",
            "german": "Beispieltext",
            "indonesian": "Contoh Teks",
        }

        # 根据输入选择正则表达式与翻译文本
        pattern = patterns_all[conv_source_lang]
        source_text = text_all[conv_source_lang]
        translated_text = text_all[config.target_language]

        source_list, translated_list = [], []
        counter = 1  # 统一计数器保证编号同步

        for value in input_dict.values():
            if pattern.search(value):
                # 使用相同计数器生成编号
                src = pattern.sub(lambda _: f"{source_text}{counter}", value)
                trans = pattern.sub(lambda _: f"{translated_text}{counter}", value)
                source_list.append(src)
                translated_list.append(trans)
                counter += 1

        # 优化过滤逻辑
        def filter_func(items, text):
            return [item for item in items 
                    if (not item.startswith(text)  # 排除纯示例开头的项
                        or not any(c.isdigit() for c in item[-3:]))  # 排除末尾3字符含数字的项
                    and len(item) <= 80]  #过滤不超过设定长度的项

        # 清理和重新编号
        source_cleaned = PromptBuilder.clean_list(filter_func(source_list, source_text))
        trans_cleaned = PromptBuilder.clean_list(filter_func(translated_list, translated_text))

        # 最终编号处理
        return (
            PromptBuilder.replace_and_increment(source_cleaned, source_text),
            PromptBuilder.replace_and_increment(trans_cleaned, translated_text)
        )

    # 构建原文
    def build_source_text(config: TaskConfig, source_text_dict: dict) -> str:
        numbered_lines = []
        for index, line in enumerate(source_text_dict.values()):
            # 检查是否为多行文本
            if "\n" in line:
                lines = line.split("\n")  # 需要与回复提取的行分割方法一致
                numbered_text = f"{index + 1}.[\n"
                total_lines = len(lines)
                for sub_index, sub_line in enumerate(lines):
                    # 不去除空白内容，保留\r其他平台的换行符，虽然AI回复不一定保留...
                    # 仅当 **只有一个** 尾随空格时才去除
                    sub_line = sub_line[:-1] if re.match(r'.*[^ ] $', sub_line) else sub_line
                    numbered_text += f'"{index + 1}.{total_lines - sub_index}.,{sub_line}",\n'
                numbered_text = numbered_text.rstrip('\n')
                numbered_text = numbered_text.rstrip(',')
                numbered_text += f"\n]"  # 用json.dumps会影响到原文的转义字符
                numbered_lines.append(numbered_text)
            else:
                # 单行文本直接添加序号
                numbered_lines.append(f"{index + 1}.{line}")

        source_text_str = "\n".join(numbered_lines)
        
        return source_text_str

    # 构造术语表
    def build_glossary_prompt(config: TaskConfig, input_dict: dict) -> str:
        # 将输入字典中的所有值转换为集合
        lines = set(line for line in input_dict.values())

        # 筛选在输入词典中出现过的条目
        result = []
        for v in config.prompt_dictionary_data:
            src_lower = v.get("src").lower() # 将术语表中的 src 转换为小写
            if any(src_lower in line.lower() for line in lines): # 将原文行也转换为小写进行比较
                result.append(v)

        # 数据校验
        if len(result) == 0:
            return ""

        # 避免空的默认内容
        if len(result) == 1 and (result[0]["src"] == ""):
            return ""

        # 初始化变量，以免出错
        glossary_prompt_lines = []

        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            # 添加开头
            glossary_prompt_lines.append(
                "\n###术语表"
                + "\n" + "原文|译文|备注"
            )

            # 添加数据
            for v in result:
                glossary_prompt_lines.append(f"{v.get("src")}|{v.get("dst")}|{v.get("info") if v.get("info") != "" else " "}")

        else:
            # 添加开头
            glossary_prompt_lines.append(
                "\n###Glossary"
                + "\n" + "Original Text|Translation|Remarks"
            )

            # 添加数据
            for v in result:
                glossary_prompt_lines.append(f"{v.get("src")}|{v.get("dst")}|{v.get("info") if v.get("info") != "" else " "}")


        # 拼接成最终的字符串
        glossary_prompt = "\n".join(glossary_prompt_lines)

        return glossary_prompt

    # 构造禁翻表
    def build_ntl_prompt(config: TaskConfig, source_text_dict) -> str:

        # 获取禁翻表内容
        exclusion_list_data = config.exclusion_list_data.copy()


        exclusion_dict = {}  # 用字典存储并自动去重
        texts = list(source_text_dict.values())
        
        # 处理正则匹配
        for element in exclusion_list_data:
            regex = element.get("regex", "").strip()
            marker = element.get("markers", "").strip()
            info = element.get("info", "")
            
            # 检查是否写正则，如果写了，只处理正则
            if regex:
                # 避免错误正则，导致崩溃
                try:
                    # 编译正则表达式字符串为模式对象
                    pattern = re.compile(regex)
                    # 寻找文本中所有符合正则的文本内容
                    for text in texts:
                        for match in pattern.finditer(text):
                            markers = match.group(0)
                            # 避免重复添加
                            if markers not in exclusion_dict: 
                                exclusion_dict[markers] = info
                except re.error:
                    pass
            # 没写正则，只处理标记符        
            else:
                found = any(marker in text for text in texts)
                if found and marker not in exclusion_dict:  # 避免重复添加
                    exclusion_dict[marker] = info
        
        # 检查内容是否为空
        if not exclusion_dict :
            return ""

        # 构建结果字符串
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            result = "\n###禁翻表，以下特殊标记符无需翻译"+ "\n特殊标记符|备注"
        else:
            result = "\n###Non-Translation List,Leave the following marked content untranslated"+ "\nSpecial marker|Remarks"

        for markers, info in exclusion_dict.items():
            result += f"\n{markers}|{info}" if info else f"\n{markers}|"
        
        return result

    # 构造角色设定
    def build_characterization(config: TaskConfig, input_dict: dict) -> str:
        # 将数据存储到中间字典中
        dictionary = {}
        for v in config.characterization_data:
            dictionary[v.get("original_name", "")] = v

        # 筛选，如果该key在发送文本中，则存储进新字典中
        temp_dict = {}
        for key_a, value_a in dictionary.items():
            for _, value_b in input_dict.items():
                if key_a in value_b:
                    temp_dict[key_a] = value_a

        # 如果没有含有字典内容
        if temp_dict == {}:
            return ""

        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = "\n###角色介绍"
            for key, value in temp_dict.items():
                original_name = value.get("original_name")
                translated_name = value.get("translated_name")
                gender = value.get("gender")
                age = value.get("age")
                personality = value.get("personality")
                speech_style = value.get("speech_style")
                additional_info = value.get("additional_info")

                profile += f"\n【{original_name}】"
                if translated_name:
                    profile += f"\n- 译名：{translated_name}"

                if gender:
                    profile += f"\n- 性别：{gender}"

                if age:
                    profile += f"\n- 年龄：{age}"

                if personality:
                    profile += f"\n- 性格：{personality}"

                if speech_style:
                    profile += f"\n- 说话方式：{speech_style}"

                if additional_info:
                    profile += f"\n- 补充信息：{additional_info}"

                profile += "\n"

        else:
            profile = "\n###Character Introduction"
            for key, value in temp_dict.items():
                original_name = value.get("original_name")
                translated_name = value.get("translated_name")
                gender = value.get("gender")
                age = value.get("age")
                personality = value.get("personality")
                speech_style = value.get("speech_style")
                additional_info = value.get("additional_info")

                profile += f"\n【{original_name}】"
                if translated_name:
                    profile += f"\n- Translated_name：{translated_name}"

                if gender:
                    profile += f"\n- Gender：{gender}"

                if age:
                    profile += f"\n- Age：{age}"

                if personality:
                    profile += f"\n- Personality：{personality}"

                if speech_style:
                    profile += f"\n- Speech_style：{speech_style}"

                if additional_info:
                    profile += f"\n- Additional_info：{additional_info}"

                profile += "\n"

        return profile

    # 构造背景设定
    def build_world_building(config: TaskConfig) -> str:
        # 获取自定义内容
        world_building = config.world_building_content

        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = "\n###背景设定"

            profile += f"\n{world_building}\n"

        else:
            profile = "\n###Background Setting"

            profile += f"\n{world_building}\n"

        return profile

    # 构造文风要求
    def build_writing_style(config: TaskConfig) -> str:
        # 获取自定义内容
        writing_style = config.writing_style_content

        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = "\n###翻译风格"

            profile += f"\n{writing_style}\n"

        else:
            profile = "\n###Writing Style"

            profile += f"\n{writing_style}\n"

        return profile

    # 构建翻译示例
    def build_translation_example(config: TaskConfig) -> str:
        data = config.translation_example_data

        # 数据校验
        if len(data) == 0:
            return ""

        # 构建翻译示例字符串
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            translation_example = "\n###翻译示例\n"

        else:
            translation_example = "\n###Translation Example\n"

        for index, pair in enumerate(data, start=1):
            # 使用解构赋值提升可读性
            original = pair.get("src", "")
            translated = pair.get("dst", "")

            # 添加换行符（首行之后才添加）
            if index > 1:
                translation_example += "\n"

            # 使用更严谨的字符串格式化
            if config.target_language in ("chinese_simplified", "chinese_traditional"):
                translation_example += f"  -原文{index}：{original}\n  -译文{index}：{translated}"

            else:
                translation_example += f"  -Original {index}: {original}\n  -Translation {index}: {translated}"

        return translation_example

    # 携带原文上文
    def build_pre_text(config: TaskConfig, input_list: list[str]) -> str:
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = "###上文内容\n"
            profile += "<previous>\n"

        else:
            profile = "###Previous text\n"
            profile += "<previous>\n"

        # 使用列表推导式，转换为字符串列表
        formatted_rows = [item for item in input_list]

        # 使用换行符将列表元素连接成一个字符串
        profile += f"{"\n".join(formatted_rows)}\n"

        profile += "</previous>\n"

        return profile

    # 构建用户示例前文
    def build_userExamplePrefix(config: TaskConfig) -> str:
        # 根据中文开关构建
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = "###这是你接下来的翻译任务，原文文本如下\n"
        else:
            profile = "###This is your next translation task, the original text is as follows\n"

        return profile

    # 构建模型示例前文
    def build_modelExamplePrefix(config: TaskConfig) -> str:
        # 根据中文开关构建
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            # 非cot的构建
            profile = "我完全理解了翻译的要求与原则，我将遵循您的指示进行翻译，以下是对原文的翻译:\n"

        else:
            # Non-CoT prompt construction
            profile = "I have fully understood the translation requirements and principles. I will follow your instructions to perform the translation. Below is my translation of the original text:\n"

        return profile

    # 构建翻译前文:
    def build_userQueryPrefix(config: TaskConfig) -> str:
        # 根据中文开关构建
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = " ###这是你接下来的翻译任务，原文文本如下\n"
        else:
            profile = " ###This is your next translation task, the original text is as follows\n"
        return profile

    # 构建预输入回复的前文
    def build_modelResponsePrefix(config: TaskConfig) -> str:
        # 根据中文开关构建
        if config.target_language in ("chinese_simplified", "chinese_traditional"):
            profile = "我完全理解了翻译的要求与原则，我将遵循您的指示进行翻译，以下是对原文的翻译:"
            profile_cot = "我完全理解了翻译的步骤与原则，我将遵循您的指示进行翻译，并深入思考和解释:"
        else:
            profile = "I have fully understood the translation requirements and principles. I will follow your instructions to perform the translation. Below is my translation of the original text:"
            profile_cot = "I have fully understood the steps and principles of translation. I will follow your instructions to perform the translation and provide in-depth thinking and explanations:"

        # 根据cot开关进行选择
        if config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.COT:
            the_profile = profile_cot
        else:
            the_profile = profile

        return the_profile


    # 生成信息结构 - 通用
    def generate_prompt(config, source_text_dict: dict, previous_text_list: list[str], source_lang) -> tuple[list[dict], str, list[str]]:
        # 储存指令
        messages = []
        # 储存额外日志
        extra_log = []

        # 基础系统提示词
        if config.translation_prompt_selection["last_selected_id"] in (PromptBuilderEnum.COMMON, PromptBuilderEnum.COT, PromptBuilderEnum.THINK):
            system = PromptBuilder.build_system(config, source_lang)
        else:
            custom_prompt = config.translation_prompt_selection["prompt_content"]
            system = PromptBuilder._replace_language_placeholders(custom_prompt, config, source_lang)


        # 如果开启术语表
        if config.prompt_dictionary_switch == True:
            glossary = PromptBuilder.build_glossary_prompt(config, source_text_dict)
            if glossary != "":
                system += glossary
                extra_log.append(glossary)

        # 如果开启禁翻表
        if config.exclusion_list_switch == True:
            ntl = PromptBuilder.build_ntl_prompt(config, source_text_dict)
            if ntl != "":
                system += ntl
                extra_log.append(ntl)


        # 如果角色介绍开关打开
        if config.characterization_switch == True:
            characterization = PromptBuilder.build_characterization(config, source_text_dict)
            if characterization != "":
                system += characterization
                extra_log.append(characterization)

        # 如果启用自定义世界观设定功能
        if config.world_building_switch == True:
            world_building = PromptBuilder.build_world_building(config)
            if world_building != "":
                system += world_building
                extra_log.append(world_building)

        # 如果启用自定义行文措辞要求功能
        if config.writing_style_switch == True:
            writing_style = PromptBuilder.build_writing_style(config)
            if writing_style != "":
                system += writing_style
                extra_log.append(writing_style)

        # 如果启用翻译风格示例功能
        if config.translation_example_switch == True:
            translation_example = PromptBuilder.build_translation_example(config)
            if translation_example != "":
                system += translation_example
                extra_log.append(translation_example)

        # 构建动态few-shot
        switch_A = config.few_shot_and_example_switch # 打开动态示例开关时
        switch_B = config.translation_prompt_selection["last_selected_id"] == PromptBuilderEnum.COMMON #仅在通用提示词
        if switch_A and switch_B:

            # 获取默认示例前置文本
            pre_prompt_example = PromptBuilder.build_userExamplePrefix(config)
            fol_prompt_example = PromptBuilder.build_modelExamplePrefix(config)

            # 获取具体动态示例内容
            original_exmaple, translation_example_content = PromptBuilder.build_translation_sample(config, source_text_dict, source_lang)
            if original_exmaple and translation_example_content:
                messages.append({
                    "role": "user",
                    "content": f"{pre_prompt_example}<textarea>\n{original_exmaple}\n</textarea>"
                })
                messages.append({
                    "role": "assistant",
                    "content": f"{fol_prompt_example}<textarea>\n{translation_example_content}\n</textarea>"
                })
                extra_log.append(f"原文示例已添加：\n{original_exmaple}")
                extra_log.append(f"译文示例已添加：\n{translation_example_content}")

        # 如果加上文，获取上文内容
        previous = ""
        if config.pre_line_counts and previous_text_list:
            previous = PromptBuilder.build_pre_text(config, previous_text_list)
            if previous != "":
                extra_log.append(f"###上文内容\n{"\n".join(previous_text_list)}")


        # 构建待翻译文本
        source_text = PromptBuilder.build_source_text(config,source_text_dict)
        pre_prompt = PromptBuilder.build_userQueryPrefix(config) # 用户提问前置文本
        source_text_str = f"{previous}\n{pre_prompt}<textarea>\n{source_text}\n</textarea>"

        # 构建用户信息
        messages.append(
            {
                "role": "user",
                "content": source_text_str,
            }
        )

        # 构建预输入回复信息
        switch_C = config.translation_prompt_selection["last_selected_id"] in (PromptBuilderEnum.COT, PromptBuilderEnum.COMMON) 
        if switch_A and switch_C:
            fol_prompt = PromptBuilder.build_modelResponsePrefix(config)
            messages.append({"role": "assistant", "content": fol_prompt})


        return messages, system, extra_log




================================================
FILE: ModuleFolders/PromptBuilder/PromptBuilderEnum.py
================================================
from Base.Base import Base

class PromptBuilderEnum(Base):

    COMMON = 100
    COT = 200
    THINK = 300
    CUSTOM = 1000

    POLISH_COMMON = 10001

    FORMAT_COMMON = 20001


================================================
FILE: ModuleFolders/PromptBuilder/PromptBuilderLocal.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/PromptBuilder/PromptBuilderPolishing.py
================================================
import re
from types import SimpleNamespace

from Base.Base import Base
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig
from ModuleFolders.PromptBuilder.PromptBuilderEnum import PromptBuilderEnum
from ModuleFolders.PromptBuilder.PromptBuilder import PromptBuilder
class PromptBuilderPolishing(Base):

    def __init__(self) -> None:
        super().__init__()

    # 获取默认系统提示词，优先从内存中读取，如果没有，则从文件中读取
    def get_system_default(config: TaskConfig) -> str:
        if getattr(PromptBuilderPolishing, "common_system_zh_s", None) == None:
            with open("./Resource/Prompt/Polishing/common_system_zh_s.txt", "r", encoding = "utf-8") as reader:
                PromptBuilderPolishing.common_system_zh_s = reader.read().strip()
        if getattr(PromptBuilderPolishing, "common_system_zh_t", None) == None:
            with open("./Resource/Prompt/Polishing/common_system_zh_t.txt", "r", encoding = "utf-8") as reader:
                PromptBuilderPolishing.common_system_zh_t = reader.read().strip()


        # 如果输入的是字典，则转换为命名空间
        if isinstance(config, dict):
            namespace = SimpleNamespace()
            for key, value in config.items():
                setattr(namespace, key, value)
            config = namespace


        # 构造结果
        if config == None:
            result = PromptBuilderPolishing.common_system_zh_t
        elif  config.polishing_mode_selection == "source_text_polish":
            result = PromptBuilderPolishing.common_system_zh_s
        elif  config.polishing_mode_selection == "target_text_polish":
            result = PromptBuilderPolishing.common_system_zh_t
        else:
            result = PromptBuilderPolishing.common_system_zh_t

        return result

    # 获取系统提示词
    def build_system(config: TaskConfig) -> str:

        # 获取默认系统提示词
        PromptBuilderPolishing.get_system_default(config)

        # 构造结果
        if config == None:
            result = PromptBuilderPolishing.common_system_zh_t
        elif  config.polishing_mode_selection == "source_text_polish":
            result = PromptBuilderPolishing.common_system_zh_s
        elif  config.polishing_mode_selection == "target_text_polish":
            result = PromptBuilderPolishing.common_system_zh_t
        else:
            result = PromptBuilderPolishing.common_system_zh_t

        return result

    # 构造术语表
    def build_glossary_prompt(config: TaskConfig, input_dict: dict) -> str:
        # 将输入字典中的所有值转换为集合
        lines = set(line for line in input_dict.values())

        # 筛选在输入词典中出现过的条目
        result = []
        for v in config.prompt_dictionary_data:
            src_lower = v.get("src").lower() # 将术语表中的 src 转换为小写
            if any(src_lower in line.lower() for line in lines): # 将原文行也转换为小写进行比较
                result.append(v)

        # 数据校验
        if len(result) == 0:
            return ""

        # 避免空的默认内容
        if len(result) == 1 and (result[0]["src"] == ""):
            return ""

        # 初始化变量，以免出错
        glossary_prompt_lines = []

        # 添加开头
        glossary_prompt_lines.append(
            "\n###术语表"
            + "\n" + "原文|译文|备注"
        )

        # 添加数据
        for v in result:
            glossary_prompt_lines.append(f"{v.get("src")}|{v.get("dst")}|{v.get("info") if v.get("info") != "" else " "}")


        # 拼接成最终的字符串
        glossary_prompt = "\n".join(glossary_prompt_lines)

        return glossary_prompt

    # 构造禁翻表
    def build_ntl_prompt(config: TaskConfig, source_text_dict) -> str:

        # 获取禁翻表内容
        exclusion_list_data = config.exclusion_list_data.copy()


        exclusion_dict = {}  # 用字典存储并自动去重
        texts = list(source_text_dict.values())
        
        # 处理正则匹配
        for element in exclusion_list_data:
            regex = element.get("regex", "").strip()
            marker = element.get("markers", "").strip()
            info = element.get("info", "")
            
            # 检查是否写正则，如果写了，只处理正则
            if regex:
                # 避免错误正则，导致崩溃
                try:
                    # 编译正则表达式字符串为模式对象
                    pattern = re.compile(regex)
                    # 寻找文本中所有符合正则的文本内容
                    for text in texts:
                        for match in pattern.finditer(text):
                            markers = match.group(0)
                            # 避免重复添加
                            if markers not in exclusion_dict: 
                                exclusion_dict[markers] = info
                except re.error:
                    pass
            # 没写正则，只处理标记符        
            else:
                found = any(marker in text for text in texts)
                if found and marker not in exclusion_dict:  # 避免重复添加
                    exclusion_dict[marker] = info
        
        # 检查内容是否为空
        if not exclusion_dict :
            return ""

        # 构建结果字符串
        result = "\n###禁翻表，以下特殊标记符无需翻译"+ "\n特殊标记符|备注"


        for markers, info in exclusion_dict.items():
            result += f"\n{markers}|{info}" if info else f"\n{markers}|"
        
        return result


    # 构造文风要求
    def build_writing_style(config: TaskConfig) -> str:
        # 获取自定义内容
        writing_style = config.polishing_style_content

        profile = "\n###润色风格"

        profile += f"\n{writing_style}\n"


        return profile



    # 携带原文上文
    def build_pre_text(config: TaskConfig, input_list: list[str]) -> str:
        profile = "###上文内容\n"

        # 使用列表推导式，转换为字符串列表
        formatted_rows = [item for item in input_list]

        # 使用换行符将列表元素连接成一个字符串
        profile += f"{"\n".join(formatted_rows)}\n"

        return profile

    # 构建润色原文的前缀:
    def build_source_prefix(config: TaskConfig) -> str:
        profile = " ###这是你接下来的润色任务，文本如下\n"

        return profile

    # 构建润色译文的前缀:
    def build_translated_prefix(config: TaskConfig) -> str:
        profile_A = " ###原文文本\n"

        profile_B = "###这是你接下来的润色任务，初译文本如下\n"

        return profile_A , profile_B

    # 生成信息结构 - 通用
    def generate_prompt(config, source_text_dict: dict, translation_text_dict: dict, previous_text_list: list[str]) -> tuple[list[dict], str, list[str]]:
        # 储存指令
        messages = []
        # 储存额外日志
        extra_log = []

        # 基础系统提示词
        if config.polishing_prompt_selection["last_selected_id"]  == PromptBuilderEnum.POLISH_COMMON:
            system = PromptBuilderPolishing.build_system(config)
        else:
            system = config.polishing_prompt_selection["prompt_content"]  # 自定义提示词


        # 如果开启术语表
        if config.prompt_dictionary_switch == True:
            glossary = PromptBuilderPolishing.build_glossary_prompt(config, source_text_dict)
            if glossary != "":
                system += glossary
                extra_log.append(glossary)

        # 如果开启禁翻表
        if config.exclusion_list_switch == True:
            ntl = PromptBuilderPolishing.build_ntl_prompt(config, source_text_dict)
            if ntl != "":
                system += ntl
                extra_log.append(ntl)

        # 如果启用润色风格功能
        if config.polishing_style_switch == True:
            writing_style = PromptBuilderPolishing.build_writing_style(config)
            if writing_style != "":
                system += writing_style
                extra_log.append(writing_style)


        # 如果加上文，获取上文内容
        previous = ""
        if config.polishing_pre_line_counts and previous_text_list:
            previous = PromptBuilderPolishing.build_pre_text(config, previous_text_list)
            if previous != "":
                extra_log.append(f"###上文内容\n{"\n".join(previous_text_list)}")


        # 构建待翻译文本

        if config.polishing_mode_selection == "source_text_polish":

            source_text = PromptBuilder.build_source_text(config,source_text_dict)
            pre_prompt = PromptBuilderPolishing.build_source_prefix(config) # 用户提问前置文本

            source_text_str = f"{previous}\n{pre_prompt}<textarea>\n{source_text}\n</textarea>"

        elif config.polishing_mode_selection == "translated_text_polish":
            source_text = PromptBuilder.build_source_text(config,source_text_dict)
            translation_text = PromptBuilder.build_source_text(config,translation_text_dict)
            pre_prompt_A,pre_prompt_B = PromptBuilderPolishing.build_translated_prefix(config) # 用户提问前置文本

            source_text_str = f"{previous}\n{pre_prompt_A}\n{source_text}\n{pre_prompt_B}<textarea>\n{translation_text}\n</textarea>"


        # 构建用户信息
        messages.append(
            {
                "role": "user",
                "content": source_text_str,
            }
        )

        # 构建预输入回复信息
        switch_A = config.few_shot_and_example_switch # 打开动态示例开关时
        if switch_A :
            messages.append({"role": "assistant", "content": "我完全理解了你的要求，我将遵循您的指示进行润色任务。"})

        return messages, system, extra_log



================================================
FILE: ModuleFolders/PromptBuilder/PromptBuilderSakura.py
================================================
from types import SimpleNamespace

from Base.Base import Base
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig
from ModuleFolders.PromptBuilder.PromptBuilder import PromptBuilder

class PromptBuilderSakura(Base):

    def __init__(self) -> None:
        super().__init__()

    # 获取默认系统提示词，优先从内存中读取，如果没有，则从文件中读取
    def get_system_default(config: TaskConfig) -> str:
        if getattr(PromptBuilderSakura, "sakura_system_zh", None) == None:
            with open("./Resource/Prompt/Sakura/sakura_system_zh.txt", "r", encoding = "utf-8") as reader:
                PromptBuilderSakura.sakura_system_zh = reader.read().strip()


        # 如果输入的是字典，则转换为命名空间
        if isinstance(config, dict):
            namespace = SimpleNamespace()
            for key, value in config.items():
                setattr(namespace, key, value)
            config = namespace


        # 构造结果
        result = PromptBuilderSakura.sakura_system_zh

        return result

    # 获取系统提示词
    def build_system(config: TaskConfig, _source_lang: str) -> str:
        PromptBuilderSakura.get_system_default(config)

        # 构造结果
        result = PromptBuilderSakura.sakura_system_zh


        return result



    # 构造术语表
    def build_glossary(config: TaskConfig, input_dict: dict) -> str:
        # 将输入字典中的所有值转换为集合
        lines = set(line for line in input_dict.values())

        # 筛选在输入词典中出现过的条目
        result: list[dict] = [
            v for v in config.prompt_dictionary_data
            if any(v.get("src", "") in lines for lines in lines)
        ]

        if len(result) == 0:
            return ""

        # 构建指令词典文本
        dict_lines = []
        for item in result:
            src = item.get("src", "")
            dst = item.get("dst", "")
            info = item.get("info", "")

            if info == "":
                dict_lines.append(f"{src}->{dst}")
            else:
                dict_lines.append(f"{src}->{dst} #{info}")

        # 如果指令词典文本不为空
        if dict_lines != []:
            dict_lines_str = "\n".join(dict_lines)
        else:
            return ""

        return dict_lines_str

    # 生成信息结构 - Sakura
    def generate_prompt_sakura(config,  source_text_dict: dict, previous_text_list: list[str], source_lang) -> tuple[list[dict], str, list[str]]:
        # 储存指令
        messages = []
        # 储存额外日志
        extra_log = []

        system = PromptBuilderSakura.build_system(config, source_lang)


        # 如果开启术语表
        glossary = ""
        if config.prompt_dictionary_switch == True:
            glossary = PromptBuilderSakura.build_glossary(config, source_text_dict)
            if glossary != "":
                extra_log.append(glossary)

        # 构建待翻译文本
        source_text = PromptBuilder.build_source_text(config,source_text_dict)

        # 构建主要提示词
        if glossary == "":
            user_prompt = "将下面的日文文本翻译成中文：\n" + source_text
        else:
            user_prompt = (
                "根据以下术语表（可以为空）：\n" + glossary
                + "\n" + "将下面的日文文本根据对应关系和备注翻译成中文：\n" + source_text
            )

        # 构建指令列表
        messages.append(
            {
                "role": "user",
                "content": user_prompt,
            }
        )

        return messages, system, extra_log





================================================
FILE: ModuleFolders/RequestLimiter/RequestLimiter.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/ResponseChecker/AdvancedChecks.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/ResponseChecker/BaseChecks.py
================================================


# 检查接口是否拒绝翻译，而返回一段话
def contains_special_chars(s: str) -> bool:
    special_chars = ['<', '>', '/']
    return any(char in s for char in special_chars)

# 检查数字序号是否正确
def check_dict_order(source_text_dict,input_dict):
    """
    检查输入的字典，字典的key是从零开始增加的字符数字，值是文本。
    顺序检查每个值的开头是否是以数字序号+英文句点开头，并且是从1开始增加的数字序号，
    全部检查通过返回真，反之返回假。

    Args:
        input_dict (dict): 输入的字典，key为字符数字，value为文本。

    Returns:
        bool: 检查全部通过返回True，否则返回False。
    """
    if (len(source_text_dict) == 1) and (len(input_dict) == 1):
        return True  # 一行就不检查了


    expected_num = 1  # 期望的起始序号
    keys = sorted(input_dict.keys(), key=int)  # 获取排序后的key，确保按数字顺序检查

    for key in keys:
        value = input_dict[key]
        prefix = str(expected_num) + "."
        if not value.startswith(prefix):
            return False  # 值没有以期望的序号开头
        expected_num += 1  # 序号递增

    return True  # 所有检查都通过

# 检查回复内容的文本行数
def check_text_line_count(source_dict, response_dict):
    return (
        len(source_dict) > 0 and len(response_dict) > 0 # 数据不为空
        and len(source_dict) == len(response_dict) # 原文与译文行数一致
        and all(str(key) in response_dict for key in range(len(source_dict))) # 译文的 Key 的值为从 0 开始的连续数值字符
    )

# 检查翻译内容是否有空值
def check_empty_response(response_dict):
    for value in response_dict.values():
        #检查value是不是None，因为AI回回复null，但是json.loads()会把null转化为None
        if value is None:
            return False

        # 检查value是不是空字符串，因为AI回回复空字符串，但是json.loads()会把空字符串转化为""
        if value == "":
            return False

    return True




================================================
FILE: ModuleFolders/ResponseChecker/ResponseChecker.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/ResponseChecker/TranslationChecker.py
================================================
import os
import time
import re
import json
from collections import defaultdict
from typing import List, Dict, Any, Tuple

from Base.Base import Base
from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.Cache.CacheManager import CacheManager
from ModuleFolders.FileReader import ReaderUtil
from ModuleFolders.TaskExecutor import TranslatorUtil

# 定义结果码，便于UI判断
class CheckResult:
    SUCCESS_REPORT = "SUCCESS_REPORT"
    SUCCESS_JUDGE_PASS = "SUCCESS_JUDGE_PASS"
    SUCCESS_JUDGE_FAIL = "SUCCESS_JUDGE_FAIL"
    HAS_RULE_ERRORS = "HAS_RULE_ERRORS"  # 存在需要列表展示的错误
    ERROR_CACHE = "ERROR_CACHE"
    ERROR_NO_TRANSLATION = "ERROR_NO_TRANSLATION"
    ERROR_NO_POLISH = "ERROR_NO_POLISH"
    ERROR_INVALID_LANG = "ERROR_INVALID_LANG"

class TranslationChecker(Base):
    """
    双模式语言检查。
    """
    TARGET_LANGUAGE_RATIO_THRESHOLD = 0.75  # [精准判断] 目标语言在块中的占比阈值
    CHUNK_SIZE = 20                         # [精准判断] 每个检测块包含的行数

    def __init__(self, cache_manager: CacheManager):
        super().__init__()
        self.cache_manager = cache_manager
        self.config = self.load_config()

    # --- 主检查流程 ---
    def check_process(self, params: dict) -> Tuple[str, Any]:
        """
        主检查流程
        """
        target = params.get("target", "translate")
        mode = params.get("mode", "report")
        rules = params.get("rules", {})

        # 1. 兼容逻辑
        legacy_mode_str = f"{target}_{mode}" if target == "polish" else mode
        if mode == "report" and target == "polish": legacy_mode_str = "polish"
        
        # 2. 执行原有的语言检测
        # 这个函数跑完后，有问题的 CacheItem 已经被打上了 extra 标记
        lang_result_code, lang_data = self.check_language(legacy_mode_str)

        # 如果基础检查失败（如无缓存），直接返回
        if lang_result_code.startswith("ERROR"):
            return lang_result_code, lang_data

        # 3. 执行规则检测
        all_errors = self._check_rules(target, rules)

        # 4. 从缓存中收集刚才被 check_language 标记的错误
        # 只有在"精准判断"模式下，且语言检测发现问题时才收集
        if "judge" in mode:
            lang_errors = self._collect_lang_errors_from_cache(target)
            if lang_errors:
                all_errors.extend(lang_errors)

        # 5. 如果收集到了任何错误（规则错误 或 语言标记错误），都强制返回 HAS_RULE_ERRORS
        if all_errors:
            return CheckResult.HAS_RULE_ERRORS, all_errors
        
        return lang_result_code, lang_data

    def _collect_lang_errors_from_cache(self, target_type: str) -> List[Dict]:
        """
        辅助函数：遍历缓存，查找被 check_language 打上标记的项
        """
        errors = []
        # 确定标记键和检查属性
        flag_key = "language_mismatch_polish" if target_type == "polish" else "language_mismatch_translation"
        check_attr = "polished_text" if target_type == "polish" else "translated_text"

        for file_path, file_obj in self.cache_manager.project.files.items():
            file_name = os.path.basename(file_path)
            for item in file_obj.items:
                # 检查 extra 字典是否存在且标记为 True
                if item.extra and item.extra.get(flag_key) is True:
                    text_content = getattr(item, check_attr, "")
                    errors.append({
                        "row_id": f"{file_name} : {item.text_index + 1}",
                        "error_type": self.tra("语言比例异常"), # 由于 check_language 没返回具体检测到的语言，只能显示通用错误
                        "source": item.source_text,
                        "check_text": text_content,
                        "file_path": file_path,
                        "text_index": item.text_index,
                        "target_field": check_attr
                    })
        return errors

    # --- 语言检查主流程 ---
    def check_language(self, mode: str) -> Tuple[str, Dict]:
        start_time = time.time()

        pre_check_result, pre_check_data = self._perform_pre_checks(mode)
        if pre_check_result is not None:
            return pre_check_result, pre_check_data

        # 初始化检查参数
        is_judging = "judge" in mode
        check_target = "polished_text" if "polish" in mode else "translated_text"
        flag_key = "language_mismatch_polish" if "polish" in mode else "language_mismatch_translation" #缓存标记
        target_language_name = self.config.get("target_language", "english")
        target_language_code = TranslatorUtil.map_language_name_to_code(target_language_name)
        mode_text = self.tra("润色后文本") if "polish" in mode else self.tra("翻译后文本")

        if not target_language_code:
            self.error(self.tra("检查失败：无法将目标语言名称 '{}' 转换为有效的语言代码。请检查您的配置。").format(target_language_name))
            return CheckResult.ERROR_INVALID_LANG, {"lang_name": target_language_name}

        # 兼容繁中检测
        if target_language_code == 'zh-Hant':
            target_language_code = 'zh'

        self.info(self.tra("开始检查项目的{}...").format(mode_text))
        if is_judging:
            self.info(self.tra("模式: 精准判断，目标语言: {} ({})").format(target_language_name, target_language_code))
            self.info(self.tra("检测块大小: {}行, 块语言比例阈值: {:.0%}").format(self.CHUNK_SIZE, self.TARGET_LANGUAGE_RATIO_THRESHOLD))
        else:
            self.info(self.tra("模式: 宏观统计【将报告每个文件的整体语言组成】"))
        self.print("-" * 20)

        #检查前查看是否有标记
        self.info(self.tra("正在清除旧的语言检查标记..."))
        ## 定义需要清除的标记键
        flag_key_translation = "language_mismatch_translation"
        flag_key_polish = "language_mismatch_polish"

        #遍历所有 item
        for item in self.cache_manager.project.items_iter():
            if item.extra:
                #安全的移除键
                item.extra.pop(flag_key_translation, None)
                item.extra.pop(flag_key_polish, None)

                # 如果 extra 字典在移除标记后变为空，将其设为 None 以保持缓存干净
                if not item.extra:
                    item.extra = None
        self.info(self.tra("旧标记已清除。现在开始新的检查..."))
        self.print("-" * 20)


        # 执行分析
        all_results = []
        try:
            for cache_file in self.cache_manager.project.files.values():
                if is_judging:
                    # [精准判断模式] 使用分块分析
                    file_analysis_result = self._analyze_file_in_chunks(cache_file, check_target, target_language_code, flag_key)
                    if file_analysis_result and file_analysis_result["problematic_chunks"]:
                        all_results.append(file_analysis_result)
                else:
                    # [宏观统计模式] 使用整体文件分析
                    analysis_result = self._analyze_file_for_report(cache_file, check_target)
                    if analysis_result:
                        all_results.append(analysis_result)
        finally:
            ReaderUtil.close_lang_detector()
        self.info(self.tra("语言检查完成，耗时 {:.2f} 秒").format(time.time() - start_time))

        # 如果在精准判断模式下发现了问题，则保存带有标记的缓存
        if is_judging and all_results:
            self.info(self.tra("检测到语言不匹配项，正在将标记保存到磁盘..."))
            try:
                # 从配置中获取正确的输出路径。
                config = self.load_config()
                output_path = config.get("label_output_path")

                if output_path and os.path.isdir(output_path):
                    #为 CacheManager 设置必要的保存路径
                    self.cache_manager.save_to_file_require_path = output_path

                    # 立即执行保存操作
                    self.cache_manager.save_to_file()

                    self.info(self.tra("标记已成功保存到缓存文件。"))
                else:
                    self.warning(self.tra("无法保存标记：输出路径 '{}' 未配置或无效").format(output_path))
            except Exception as e:
                self.error(self.tra("保存标记到缓存时发生错误: {}").format(e))

        # 生成报告
        self._print_report(all_results, is_judging, target_language_code, mode_text)
        if all_results:
             self.print("\n")


        # 返回结果码
        if is_judging:
            if not all_results:
                return CheckResult.SUCCESS_JUDGE_PASS, {"target_language": target_language_name}
            else:
                return CheckResult.SUCCESS_JUDGE_FAIL, {"target_language": target_language_name}
        else:
            return CheckResult.SUCCESS_REPORT, {}

    # --- 规则检查主流程 ---
    def _check_rules(self, target_type: str, rules_config: dict) -> List[Dict]:
        if not any(rules_config.values()):
            return []

        self.info(self.tra("开始执行规则检查..."))
        errors_list = []

        # 准备正则表达式模式
        patterns = []
        if rules_config.get("auto_process"):
            patterns = self._prepare_regex_patterns(rules_config.get("exclusion", False))
        
        # 准备禁翻表数据
        exclusion_data = self.config.get("exclusion_list_data", []) if rules_config.get("exclusion") else []
        check_attr = "polished_text" if target_type == "polish" else "translated_text"
        
        # 准备术语表数据
        term_data = []
        if rules_config.get("terminology"):
            term_data = self.config.get("prompt_dictionary_data", [])

        for file_path, file_obj in self.cache_manager.project.files.items():
            file_name = os.path.basename(file_path)
            for item in file_obj.items:
                text_content = getattr(item, check_attr, "")
                # 跳过空文本或被排除的文本
                if not text_content or not item.source_text or item.translation_status == TranslationStatus.EXCLUDED:
                    continue
                
                current_errors = []

                # 1. 禁翻表
                if rules_config.get("exclusion") and exclusion_data:
                    current_errors.extend(self._rule_check_exclusion(item.source_text, text_content, exclusion_data))
                # 2. 术语表
                if rules_config.get("terminology") and term_data:
                    current_errors.extend(self._rule_check_terminology(item.source_text, text_content, term_data))
                # 3. 自动处理
                if rules_config.get("auto_process") and patterns:
                    current_errors.extend(self._rule_check_auto_process(item.source_text, text_content, patterns))
                # 4. 占位符
                if rules_config.get("placeholder"):
                    current_errors.extend(self._rule_check_placeholder(text_content))
                # 5. 数字序号
                if rules_config.get("number"):
                    current_errors.extend(self._rule_check_number(text_content))
                # 6. 示例复读
                if rules_config.get("example"):
                    current_errors.extend(self._rule_check_example(text_content))
                # 7. 换行符
                if rules_config.get("newline"):
                    current_errors.extend(self._rule_check_newline(item.source_text, text_content))

                # 收集结果
                for err in current_errors:
                    errors_list.append({
                        "row_id": f"{file_name} : {item.text_index + 1}",
                        "error_type": err,
                        "source": item.source_text,
                        "check_text": text_content,
                        "file_path": file_path,
                        "text_index": item.text_index,
                        "target_field": check_attr
                    })
        
        self.info(self.tra("规则检查完成，发现 {} 个问题。").format(len(errors_list)))
        return errors_list

    # --- 规则检查辅助方法 ---
    def _rule_check_terminology(self, src, dst, data):
        errs = []
        for term in data:
            if isinstance(term, dict):
                src_term = term.get("src")
                dst_term = term.get("dst")
                # 确保 src_term 和 dst_term 都存在且非空
                if src_term and dst_term:
                    # 简单的包含检查
                    if src_term in src:
                        if dst_term not in dst:
                            # 使用简短的错误描述以便在表格中显示
                            err_msg = self.tra("术语缺失: {}").format(dst_term)
                            if err_msg not in errs:
                                errs.append(err_msg)
        return errs
    
    def _prepare_regex_patterns(self, include_exclusion: bool):
        patterns = []
        regex_file = os.path.join(".", "Resource", "Regex", "check_regex.json")
        if os.path.exists(regex_file):
            try:
                with open(regex_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    patterns.extend([i["regex"] for i in data if "regex" in i])
            except: pass
        
        if include_exclusion:
            ex_data = self.config.get("exclusion_list_data", [])
            for item in ex_data:
                if item.get("regex"): patterns.append(item["regex"])
                elif item.get("markers"): patterns.append(re.escape(item["markers"]))
        return patterns

    def _rule_check_exclusion(self, src, dst, data):
        errs = []
        for item in data:
            regex = item.get("regex")
            markers = item.get("markers")
            pat = regex if regex else (re.escape(markers) if markers else None)
            if pat:
                try:
                    for match in re.finditer(pat, src):
                        if match.group(0) not in dst:
                            if self.tra("禁翻表错误") not in errs: errs.append(self.tra("禁翻表错误"))
                            break 
                except: continue
        return errs

    def _rule_check_auto_process(self, src, dst, patterns):
        errs = []
        _src = src.rstrip('\n')
        _dst = dst.rstrip('\n')
        for pat in patterns:
            try:
                for match in re.finditer(pat, _src):
                    if match.group(0) not in _dst:
                        if self.tra("自动处理错误") not in errs: errs.append(self.tra("自动处理错误"))
                        break
            except: continue
        return errs

    def _rule_check_placeholder(self, text):
        if re.search(r'\[P\d+\]', text):
            return [self.tra("占位符残留")]
        return []

    def _rule_check_number(self, text):
        if re.search(r'\d+\.\d+\.', text):
            return [self.tra("数字序号残留")]
        return []

    def _rule_check_example(self, text):
        if re.search(r'示例文本[A-Z]-\d+', text):
            return [self.tra("示例文本复读")]
        return []

    def _rule_check_newline(self, src, dst):
        s_n = src.strip().count('\n') + src.strip().count('\\n')
        d_n = dst.strip().count('\n') + dst.strip().count('\\n')
        if s_n != d_n:
            return [self.tra("换行符错误")]
        return []

    # 辅助方法
    def _perform_pre_checks(self, mode: str) -> Tuple[str | None, Dict]:
        """执行预检查，确保项目和缓存数据有效"""
        if not self.cache_manager.project or not self.cache_manager.project.files:
            self.error(self.tra("检查失败，请检查项目文件夹缓存是否正常"))
            return CheckResult.ERROR_CACHE, {}

        has_content = False
        check_target_attr = "polished_text" if "polish" in mode else "translated_text"
        status_to_check = TranslationStatus.POLISHED if "polish" in mode else TranslationStatus.TRANSLATED

        # 检查是否存在至少一个需要被检查的有效文本项
        for item in self.cache_manager.project.items_iter():
            if item.translation_status >= status_to_check and getattr(item, check_target_attr, "").strip():
                has_content = True
                break

        if not has_content:
            if "polish" in mode:
                self.error(self.tra("检查失败，请先执行润色流程"))
                return CheckResult.ERROR_NO_POLISH, {}
            else:
                self.error(self.tra("检查失败，请先执行翻译流程"))
                return CheckResult.ERROR_NO_TRANSLATION, {}

        return None, {}

    def _run_detection(self, items_to_check: List[CacheItem], check_target: str) -> list:
        """辅助函数，对给定的 CacheItem 列表运行语言检测。"""
        texts = [getattr(item, check_target, "") for item in items_to_check]
        # 使用一个临时的、不包含任何复杂数据的 CacheItem 列表进行检测
        dummy_items = [CacheItem(source_text=t) for t in texts]
        return ReaderUtil.detect_language_with_mediapipe(dummy_items, 0, None)


    def _analyze_file_in_chunks(self, cache_file, check_target: str, target_language_code: str, flag_key: str) -> Dict[str, Any] | None:
        """
        [精准判断模式] 按块分析文件。如果块不符合要求，则进行行级分析。
        """
        items_with_text_and_indices = [
            (idx, item) for idx, item in enumerate(cache_file.items)
            if getattr(item, check_target, "").strip()
        ]
        if not items_with_text_and_indices:
            return None

        problematic_chunks = []
        for i in range(0, len(items_with_text_and_indices), self.CHUNK_SIZE):
            chunk_with_indices = items_with_text_and_indices[i : i + self.CHUNK_SIZE]
            chunk_items = [item for idx, item in chunk_with_indices] # 提取 item 用于检测

            # 一次性获取当前块所有行的检测结果
            detection_results = self._run_detection(chunk_items, check_target)

            # 一次循环处理，同时收集块统计和行级信息
            lang_counts = defaultdict(int)
            line_by_line_details = []
            for (original_idx, item), res in zip(chunk_with_indices, detection_results):
                # 使用安全的方式处理可能不完整的返回数据
                detected_lang = "N/A"
                confidence = 0.0
                text_content = getattr(item, check_target, "")

                # 检查返回结果是否有效且不是特殊标记
                if res and res[0] and res[0][0] not in ['no_text', 'symbols_only', 'un']:
                    result_tuple = res[0]

                    # 安全地获取语言代码
                    detected_lang = result_tuple[0]

                    # 安全获取置信度
                    if len(result_tuple) > 1:
                        raw_confidence = result_tuple[1]
                        if isinstance(raw_confidence, (tuple, list)) and raw_confidence:
                           confidence = raw_confidence[0]
                        elif isinstance(raw_confidence, (int, float)):
                           confidence = raw_confidence


                    lang_counts[detected_lang] += 1

                line_by_line_details.append({
                    "original_line_num": original_idx + 1,
                    "detected_lang": detected_lang,
                    "confidence": confidence,
                    "text": text_content
                })

            total_valid_lines = sum(lang_counts.values())
            if total_valid_lines == 0:
                continue

            # 计算块的比例
            target_lang_count = lang_counts.get(target_language_code, 0)
            ratio = target_lang_count / total_valid_lines

            # 如果比例低于阈值，使用已收集的行级信息生成报告
            if ratio < self.TARGET_LANGUAGE_RATIO_THRESHOLD:
                mismatched_lines = [
                    detail for detail in line_by_line_details
                    if detail["detected_lang"] != target_language_code
                ]

                if mismatched_lines:
                    first_item_line_num = chunk_with_indices[0][0] + 1
                    last_item_line_num = chunk_with_indices[-1][0] + 1
                    problematic_chunks.append({
                        "chunk_range": self.tra("行 {}-{}").format(first_item_line_num, last_item_line_num),
                        "ratio": ratio,
                        "mismatched_lines": mismatched_lines
                    })

                    for line_info in mismatched_lines:
                        # 从行号获取在 cache_file.items中的索引
                        item_index = line_info['original_line_num'] - 1
                        item_to_flag = cache_file.items[item_index]

                        # 确保 extra 字典存在
                        if item_to_flag.extra is None:
                            item_to_flag.extra = {}

                        # 添加标记
                        item_to_flag.extra[flag_key] = True
                        self.debug(f"Flagged item at index {item_index} in file {cache_file.storage_path} with key '{flag_key}'")

        if not problematic_chunks:
            return None

        return {
            "file_info": cache_file,
            "problematic_chunks": problematic_chunks
        }

    def _analyze_file_for_report(self, cache_file, check_target: str) -> Dict[str, Any] | None:
        """[宏观统计模式] 对单个文件进行整体语言统计。"""
        items_with_text = [
            item for item in cache_file.items
            if getattr(item, check_target, "").strip()
        ]
        if not items_with_text:
            return None

        # 复用检测逻辑
        detection_results = self._run_detection(items_with_text, check_target)

        # 统计文件内所有语言的行数
        lang_counts = defaultdict(int)
        for res in detection_results:
            if res[0] and res[0][0] not in ['no_text', 'symbols_only', 'un']:
                lang_counts[res[0][0]] += 1

        total_valid_lines = sum(lang_counts.values())
        if total_valid_lines == 0:
            return None

        # 生成用于报告的语言统计信息
        sorted_langs = sorted(lang_counts.items(), key=lambda x: x[1], reverse=True)
        stats_display = [(lang, count / total_valid_lines) for lang, count in sorted_langs]

        return {
            "file_info": cache_file,
            "stats_display": stats_display
        }

    def _print_report(self, results: List[Dict], is_judging: bool, target_language_code: str, mode_text: str):
        """根据模式打印不同风格的报告。"""
        if not results:
            if is_judging:
                self.info(self.tra("检查通过：项目的所有文件 {} 均符合预期.").format(mode_text))
            else:
                self.info(self.tra("未在项目的 {} 中找到可供分析的文本内容.").format(mode_text))
            return

        # 根据模式选择报告格式
        if is_judging:
            # [精准判断模式] 的详细报告
            self.warning(self.tra("检测到 {} 个文件的 {} 中存在语言比例异常的文本块.").format(len(results), mode_text))
            self.warning(self.tra("目标语言 '{}' 占比低于 {:.0%} 的块将被列出.").format(target_language_code, self.TARGET_LANGUAGE_RATIO_THRESHOLD))
            self.print("")

            for res in results:
                cache_file = res["file_info"]
                self.info(self.tra("▼ 文件: {} (类型: {}, 编码: {})").format(cache_file.storage_path, cache_file.file_project_type, cache_file.encoding))

                for chunk in res["problematic_chunks"]:
                    self.warning(
                        self.tra("  └─ 问题区块: {} (目标语言占比: {:.2%})").format(chunk['chunk_range'], chunk['ratio'])
                    )
                    for line_info in chunk['mismatched_lines']:
                        text_preview = line_info['text'].strip().replace('\n', ' ')[:50]
                        self.error(
                            self.tra("    ├─ 行 {}: 检测为 [{}] (置信度: {:.2f}) -> \"{}...\"").format(
                                line_info['original_line_num'],
                                line_info['detected_lang'],
                                line_info['confidence'],
                                text_preview
                            )
                        )
                self.print("")
        else:
            # [宏观统计模式] 的概览报告
            self.info(self.tra("以下是各文件的 {} 语言组成统计报告:").format(mode_text))
            self.print("-" * 20)
            for res in results:
                self._print_report_mode_info(res["file_info"], res["stats_display"])
                self.print("") # 在文件报告之间添加空行

    def _print_report_mode_info(self, cache_file, stats_display):
        """[宏观统计模式] 打印单个文件的统计信息。"""
        formatted_stats = [(lang, f"{conf:.2%}") for lang, conf in stats_display]

        self.info(self.tra("文件: {}").format(cache_file.storage_path))
        self.info(self.tra("  ├─ 类型: {}").format(cache_file.file_project_type))
        self.info(self.tra("  ├─ 编码: {}").format(cache_file.encoding))
        self.info(self.tra("  └─ 语言统计: {}").format(formatted_stats))


================================================
FILE: ModuleFolders/ResponseExtractor/ResponseExtractor.py
================================================
import re
from typing import Dict, List

import rich
from rich.markup import escape


# 回复解析器
class ResponseExtractor:

    # 多行文本数字匹配格式
    # 目前有两个匹配组，第一个为标准数字序号部分，第二个为可能出现的多余引号组（常见于deepseek-v3）
    multiline_number_prefix = r'(\d+\.\d+\.)(")?[,，\s]?(?(2)"|)?'
    # 多行文本段结束后缀
    multiline_quote_suffix = r'(?:\n["“”][,，]|["“”]\n[,，]|["“”]?[,，]?)$'

    # 判断多行文本开始的正则
    multiline_start_reg = re.compile(rf'^\s*["“”]\s*{multiline_number_prefix}')
    # 提取多行文本边界的正则
    boundary_pattern_reg = re.compile(f'["“”][^"“”]*?{multiline_number_prefix}')
    # 提取规范数字序号与正文的正则
    extract_num_text_reg = re.compile(f'["“”][^"“”]*?{multiline_number_prefix}(.*?){multiline_quote_suffix}')

    def __init__(self):
        pass

    # 处理并正则提取翻译内容
    def text_extraction(self, source_text_dict, response_content):

        try:
            # 提取译文结果
            translation_result= ResponseExtractor.extract_translation(self,source_text_dict,response_content)

            return translation_result
        except Exception as e:
            print(f"\033[1;33mWarning:\033[0m 回复内容无法正常提取，请反馈\n错误信息: {str(e)}")
            return {},{},{}

    # 提取翻译结果内容
    def extract_translation(self,source_text_dict,html_string):

        # 提取翻译文本
        text_dict = ResponseExtractor.label_text_extraction(self,source_text_dict,html_string)

        if not text_dict:
            return {}  # 如果没有找到标签内容，返回空 JSON

        # 计算原文行数
        newlines_in_dict = ResponseExtractor.count_newlines_in_dict_values(self,source_text_dict)

        # 合并调整翻译文本
        translation_result= ResponseExtractor.generate_text_by_newlines(self,newlines_in_dict,text_dict)

        return translation_result

    # 辅助函数，正则提取标签文本内容
    def label_text_extraction(self,source_text_dict, html_string):

        # 只提取最后一个 textarea 标签的内容
        textarea_contents = re.findall(r'<textarea.*?>(.*?)</textarea>', html_string, re.DOTALL)
        if not textarea_contents:
            return {}  # 如果没有找到 textarea 标签，返回空字典
        last_content = textarea_contents[-1]

        # 提取文本存储到字典中
        output_dict = ResponseExtractor.extract_text_to_dict(self,last_content)

        # 如果原文是一行，则跳过过滤，主要是本地模型兼容
        if len(source_text_dict) == 1 :
             return output_dict 

        # 从第一个以数字序号开头的行开始，保留之后的所有行(主要是有些AI会在译文内容前面加点说明)
        filtered_dict = {}
        found = False
        # 按行号顺序遍历
        for key in sorted(output_dict.keys(), key=lambda k: int(k)):
            value = output_dict[key]
            if not found:
                if re.match(r'^\d+\.', value):  # 匹配以数字和句点开头的行
                    found = True
                else:
                    continue
            if found:
                filtered_dict[key] = value

        return filtered_dict

    # 提取文本为字典
    def extract_text_to_dict(self, input_string: str) -> Dict[str, str]:
        """
        从特定格式的字符串中提取内容并存入字典 。
        （目前因为AI偶尔会合并翻译，回复的列表块最后一个元素内容是这样的:"3.1."或者"3.1.[换行符]文本内容"，所以后期会检查出换行符不一致）
        Args:
            input_string: 输入的字符串。

        Returns:
            一个字典，键是'0', '1', '2'...，值是提取到的文本行。
        """
        # 1. 初步分割: 按主序号分割成块
        blocks = re.split(r'\n(?=\d+\.)', input_string.strip())

        extracted_items = []

        # 2. 处理每个块
        for block in blocks:
            block = block.strip()
            if not block:
                continue

            # 3. 尝试匹配列表块模式 (N.[ ... ])
            # re.DOTALL 使 '.' 可以匹配换行符
            list_block_match = re.match(r'^\d+\.\s*\[(.*)]$', block, re.DOTALL)
            if list_block_match:
                list_content = list_block_match.group(1).strip()
                # 再次判断是否是列表块内容(通过以特定模式开始作为判断)
                if list_content and ResponseExtractor.multiline_start_reg.match(list_content):
                    items = ResponseExtractor.extract_multiline_content(self, list_content)
                    extracted_items.extend(items)
                else:
                    # 如果方括号内的内容不像带引号列表 (例如 "9.[社团活动后]")
                    # 将整个原始块（包括 N.[...] ）视为一个单独的文本项。
                    extracted_items.append(block)
            else:
                # 4.2 文本块: 不是 N.[...] 格式，直接添加整个块内容
                extracted_items.append(block)

        # 5. 生成最终字典
        result_dict = {str(i): item for i, item in enumerate(extracted_items)}
        return result_dict

    def extract_multiline_content(self, text: str) -> List[str]:
        """
        从文本中提取引号包围的内容，处理嵌套引号。

        Args:
            text: 要处理的文本

        Returns:
            提取出的内容列表
            从捕获组1获取标准序号`n.n.`，然后从捕获组3获取正文，随后组装这两个组（以英文逗号分隔）并返回
        """
        result = []

        # 首先尝试找到所有可能的列表项边界
        # 这个模式匹配：引号 + 可能的空白 + 数字.数字.,
        boundaries = [m.start() for m in ResponseExtractor.boundary_pattern_reg.finditer(text)]

        # 如果找不到边界，返回空列表
        if not boundaries:
            return []

        # 添加文本结束作为最后一个边界
        boundaries.append(len(text))

        # 逐对处理边界
        for i in range(len(boundaries) - 1):
            segment = text[boundaries[i]:boundaries[i + 1]].strip()

            # 目前的 `multiline_number_prefix` 中有两个匹配组：
            # 第一个匹配数字序号n.n. 第二个匹配可能出现的多余引号
            # 因此这里的 `extract_num_text_reg` 使用第三个匹配组进行正文获取
            match = ResponseExtractor.extract_num_text_reg.search(segment)

            if match:
                try:
                    # 提取第1组(数字)和第3组(文本)
                    number_part = match.group(1)
                    text_part = match.group(3)

                    # 确保两个组都被成功捕获
                    if number_part is not None and text_part is not None:
                        # 去除`text_part`中可能出现的`number_part`
                        cleaned_text_part = text_part.replace(number_part, '').replace(number_part.rstrip('.'), '')
                        # 组合数字和文本，保留匹配到的 `text_part` 原始文本
                        assembled_content = f"{number_part},{cleaned_text_part}"
                        result.append(assembled_content)
                    else:
                        # 更详细地指明哪个部分为空
                        missing_parts = []
                        if number_part is None:
                            missing_parts.append("数字部分")
                        if text_part is None:
                            missing_parts.append("文本部分")

                        # 输出更详细的警告信息
                        rich.print(
                            f"[[red]WARNING[/]] 多行文本 提取失败：{', '.join(missing_parts)}为空。"
                            f"原始文本：{escape(match.group(0))[:50]}{'...' if len(match.group(0)) > 50 else ''} "
                        )
                except IndexError as e:
                    # 处理组不存在的情况，添加更详细的错误信息
                    rich.print(
                        f"[[red]WARNING[/]] 多行文本 提取索引错误：{str(e)}。无法从匹配中提取预期组。"
                        f"原始文本：{escape(match.group(0))[:50]}{'...' if len(match.group(0)) > 50 else ''} "
                    )
            else:
                # 添加未匹配情况的日志
                if segment and len(segment.strip()) > 0:  # 只记录非空段落
                    rich.print(
                        f"[[red]WARNING[/]] 多行文本 未找到匹配段落：{escape(segment[:50])}{'...' if len(segment) > 50 else ''} "
                    )

        return result

    # 辅助函数，统计原文中的换行符
    def count_newlines_in_dict_values(self,source_text_dict):
        """
        统计字典中每个文本值内的换行符数量，并生成一个包含换行符统计结果的新字典。

        Args:
            source_text_dict: 输入字典，键为字符串，值为文本字符串。

        Returns:
            一个字典，键与输入字典相同，值为对应文本字符串中的换行符数量。
            例如：
            {'0': 0, '1': 1, '2': 0}
        """
        newline_counts = {}  # 初始化一个空字典用于存储换行符数量

        for key, text in source_text_dict.items():
            newline_count = text.count('\n')  # 使用字符串的count()方法统计换行符数量
            if newline_count == 0:
                newline_counts[key] = newline_count  # 将统计结果存入新字典，键保持不变
            else:
                newline_counts[key] = newline_count
        return newline_counts

    # 辅助函数，根据换行符数量生成最终译文字典，与原文字典进行一一对应
    def generate_text_by_newlines(self, newline_counts_dict, translation_text_dict):
        """
        根据换行符统计字典和源文本字典生成新的字典，并处理多余内容。

        Args:
            newline_counts_dict: 换行符统计字典，键为字符串序号，值为换行符数量。
            translation_text_dict: 源文本字典，键为字符串序号，值为文本内容。

        Returns:
            一个新的字典，键与 newline_counts_dict 相同，值为根据换行符数量从 translation_text_dict
            中提取并拼接的文本内容。如果 translation_text_dict 内容不足，对应值为空字符串。
            如果 translation_text_dict 有剩余内容，将添加新键值对，键为最大原键加1，值为剩余内容按换行拼接。
        """
        result_dict = {}
        translation_keys_sorted = sorted(translation_text_dict.keys(), key=int)
        translation_index = 0

        # 处理每个预定键的行数需求
        for key, newline_count in newline_counts_dict.items():
            extracted_lines = []
            num_lines_to_extract = newline_count + 1 if newline_count > 0 else 1

            for _ in range(num_lines_to_extract):
                if translation_index < len(translation_keys_sorted):
                    current_key = translation_keys_sorted[translation_index]
                    extracted_lines.append(translation_text_dict[current_key])
                    translation_index += 1
                else:
                    break

            if extracted_lines:
                result_dict[key] = '\n'.join(extracted_lines) if newline_count > 0 else extracted_lines[0]
            else:
                result_dict[key] = ''

        # 添加剩余内容为新键值对
        if translation_index < len(translation_keys_sorted):
            if newline_counts_dict:
                max_key = max(map(int, newline_counts_dict.keys()))
            else:
                max_key = 0
            new_key = str(max_key + 1)
            remaining_texts = [translation_text_dict[k] for k in translation_keys_sorted[translation_index:]]
            result_dict[new_key] = '\n'.join(remaining_texts)

        return result_dict


    # 去除数字序号及括号
    def remove_numbered_prefix(self, translation_text_dict):
        """
        去除翻译文本中的数字序号前缀。
        
        处理两个步骤：
        1. 去除各种变形序号（包括特殊前缀字符 + 数字序号 + 特殊后缀标点）
        2. 循环去除开头剩余的简单数字序号
        
        Args:
            translation_text_dict: 翻译文本字典
            
        Returns:
            处理后的文本字典
        """
        output_dict = {}
        for key, value in translation_text_dict.items():

            if not isinstance(value, str):
                output_dict[key] = value
                continue
                
            translation_lines = value.split('\n')
            cleaned_lines = []
            
            for i, line in enumerate(translation_lines):
                temp_line = line
                
                # 第一步：去除各种变形序号
                # 匹配模式：[可选空白][可选特殊前缀][数字序号][可选标点后缀][可选空白]
                # - 特殊前缀：「『【……□ 等引号、省略号、方框等字符
                # - 数字序号：支持 1. 或 1.2. 或 1.2.3. 等多级序号
                # - 标点后缀：, ， 、等中英文标点
                temp_line = re.sub(
                    r'^\s*[「『【（\(……□\s]*\d+(\.\d+)*\.[,，、]?\s*',
                    '',
                    temp_line
                )
                
                # 第二步：循环去除开头剩余的 数字. 格式
                # 处理可能存在的嵌套或多余的数字序号
                max_iterations = 2  # 设置最大迭代次数，防止意外无限循环
                for iteration in range(max_iterations):
                    new_line = re.sub(r'^\s*\d+\.\s*', '', temp_line)
                    # 如果没有变化，说明已经清理完毕
                    if new_line == temp_line:
                        break
                    temp_line = new_line
                
                cleaned_lines.append(temp_line)

            processed_text = '\n'.join(cleaned_lines)

            # 移除尾部的 "/n] 或 /n] (及其前面的空格)
            final_text = re.sub(r'\s*"?\n]$', '', processed_text)
            output_dict[key] = final_text
            
        return output_dict


================================================
FILE: ModuleFolders/SimpleExecutor/SimpleExecutor.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/TaskConfig/TaskConfig.py
================================================
import os
import re
import threading
import urllib

import rapidjson as json

from Base.Base import Base
from ModuleFolders.TaskConfig.TaskType import TaskType


# 接口请求器
class TaskConfig(Base):

    # 打印时的类型过滤器
    TYPE_FILTER = (int, str, bool, float, list, dict, tuple)

    def __init__(self) -> None:
        super().__init__()
        
        # 初始化实例级线程锁和密钥索引
        self._config_lock = threading.Lock()

        self._api_key_lock = threading.Lock()
        self.apikey_index = 0
        self.apikey_list = []


    def __repr__(self) -> str:
        return (
            f"{type(self).__name__}({self.get_vars()})"
        )

    def get_vars(self) -> dict:
        return {
            k:v
            for k, v in vars(self).items()
            if isinstance(v, __class__.TYPE_FILTER)
        }


    def get_next_apikey(self) -> str:
        """
        线程安全的轮询获取 API Key
        """
        with self._api_key_lock:
            if not self.apikey_list:
                return "no_key_required"
            
            # 边界检查
            if self.apikey_index >= len(self.apikey_list):
                self.apikey_index = 0

            key = self.apikey_list[self.apikey_index]

            # 更新索引（如果还有下一个 key，则递增，否则归零）
            if len(self.apikey_list) > 1:
                self.apikey_index = (self.apikey_index + 1) % len(self.apikey_list)

            return key

    # 读取配置文件
    def initialize(self) -> None:
        # 读取配置文件
        config = self.load_config()

        # 将字典中的每一项赋值到类中的同名属性
        for key, value in config.items():
            setattr(self, key, value)

    # API_URL 自动处理方法
    def process_api_url(self, raw_url: str, target_platform: str, auto_complete: bool) -> str:
        if not raw_url:
            return ""

        # 1. 基础清洗
        url = raw_url.strip().rstrip('/')

        # 2. 裁剪后缀
        # 允许输入如: http://127.0.0.1:5000/v1/chat/completions -> 裁剪为 -> http://127.0.0.1:5000/v1
        redundant_suffixes = ["/chat/completions", "/completions", "/chat"]
        for suffix in redundant_suffixes:
            if url.endswith(suffix):
                url = url[:-len(suffix)]
                url = url.rstrip('/') # 再次去除可能暴露出来的斜杠
                break

        # 3. 自动补全 /v1 逻辑
        # 某些平台强制补全，或者配置开启了 auto_complete
        should_auto_complete = (target_platform in ["sakura", "LocalLLM"]) or auto_complete

        if should_auto_complete:
            version_suffixes = ["/v1", "/v2", "/v3", "/v4", "/v5", "/v6"]
            # 如果当前 URL 不以任何版本号结尾，则添加 /v1
            if not any(url.endswith(suffix) for suffix in version_suffixes):
                url += "/v1"

        # 4. 返回处理后的 URL
        return url

    # 准备翻译
    def prepare_for_translation(self,mode) -> None:

        # 获取目标平台

        if mode == TaskType.TRANSLATION:
            self.target_platform = self.api_settings["translate"]
        elif mode == TaskType.POLISH:
            self.target_platform = self.api_settings["polish"]

        # 增加获取不到内容时的异常处理
        if self.target_platform is None:
            raise ValueError(f"当前配置文件中未设置 {mode} 的目标平台，请重新检查接口管理页面，是否设置了执行任务的接口。")

        # 获取模型类型
        self.model = self.platforms.get(self.target_platform).get("model")

        # 分割密钥字符串
        api_key = self.platforms.get(self.target_platform).get("api_key")
        if api_key == "":
            self.apikey_list = ["no_key_required"]
            self.apikey_index = 0
        else:
            self.apikey_list = re.sub(r"\s+","", api_key).split(",")
            self.apikey_index = 0

        # 处理 API URL 和限额
        raw_url = self.platforms.get(self.target_platform).get("api_url", "")
        auto_complete_setting = self.platforms.get(self.target_platform).get("auto_complete", False)
        
        self.base_url = self.process_api_url(raw_url, self.target_platform, auto_complete_setting)

        # 获取接口限额
        self.rpm_limit = self.platforms.get(self.target_platform).get("rpm_limit", 4096)    # 当取不到账号类型对应的预设值，则使用该值
        self.tpm_limit = self.platforms.get(self.target_platform).get("tpm_limit", 10000000)    # 当取不到账号类型对应的预设值，则使用该值

        # 根据密钥数量给 RPM 和 TPM 限额翻倍
        self.rpm_limit = self.rpm_limit * len(self.apikey_list)
        self.tpm_limit = self.tpm_limit * len(self.apikey_list)

        # 如果开启自动设置输出文件夹功能，设置为输入文件夹的平级目录
        if self.auto_set_output_path == True:
            abs_input_path = os.path.abspath(self.label_input_path)
            parent_dir = os.path.dirname(abs_input_path)
            output_folder_name = "AiNieeOutput"
            self.label_output_path = os.path.join(parent_dir, output_folder_name)

            # 润色文本输出路径
            abs_input_path = os.path.abspath(self.label_input_path)
            parent_dir = os.path.dirname(abs_input_path)
            output_folder_name = "PolishingOutput"
            self.polishing_output_path = os.path.join(parent_dir, output_folder_name)

        # 保存新配置
        config = self.load_config()
        config["label_output_path"] = self.label_output_path
        config["polishing_output_path"] = self.polishing_output_path
        self.save_config(config)


        # 计算实际线程数
        self.actual_thread_counts = self.thread_counts_setting(self.user_thread_counts,self.target_platform,self.rpm_limit)


    # 自动计算实际请求线程数
    def thread_counts_setting(self,user_thread_counts,target_platform,rpm_limit) -> None:
        # 如果用户指定了线程数，则使用用户指定的线程数
        if user_thread_counts > 0:
            actual_thread_counts = user_thread_counts

        # 如果是本地类接口，尝试访问slots数
        elif target_platform in ("sakura","LocalLLM"):
            num = self.get_llama_cpp_slots_num(self.platforms.get(target_platform).get("api_url"))
            actual_thread_counts = num if num > 0 else 4
            self.info(f"根据 llama.cpp 接口信息，自动设置同时执行的翻译任务数量为 {actual_thread_counts} 个 ...")

        # 如果用户没有指定线程数，则自动计算
        else :
            actual_thread_counts = self.calculate_thread_count(rpm_limit)
            self.info(f"根据账号类型和接口限额，自动设置同时执行的翻译任务数量为 {actual_thread_counts} 个 ...")

        return actual_thread_counts

    # 获取 llama.cpp 的 slots 数量，获取失败则返回 -1
    def get_llama_cpp_slots_num(self,url: str) -> int:
        try:
            num = -1
            url = url.replace("/v1", "") if url.endswith("/v1") else url
            with urllib.request.urlopen(f"{url}/slots") as response:
                data = json.loads(response.read().decode("utf-8"))
                num = len(data) if data != None and len(data) > 0 else num
        except Exception:
            pass
        finally:
            return num
        
    # 线性计算并发线程数
    def calculate_thread_count(self,rpm_limit):

        min_rpm = 1
        max_rpm = 10000
        min_threads = 1
        max_threads = 100

        if rpm_limit <= min_rpm:
            rpm_threads = min_threads
        elif rpm_limit >= max_rpm:
            rpm_threads = max_threads
        else:
            # 线性插值计算 RPM 对应的线程数
            rpm_threads = min_threads + (rpm_limit - min_rpm) * (max_threads - min_threads) / (max_rpm - min_rpm)

        rpm_threads = int(round(rpm_threads)) # 四舍五入取整

        # 确保线程数在 1-100 范围内，并使用 CPU 核心数作为辅助上限 
        # 更简洁的方式是直接限制在 1-100 范围内，因为 100 通常已经足够高
        actual_thread_counts = max(1, min(100, rpm_threads)) # 限制在 1-100

        return actual_thread_counts


    # 获取接口配置信息包
    def get_platform_configuration(self,platform_type):

        if platform_type == "translationReq":
            target_platform = self.api_settings["translate"]
        elif platform_type == "polishingReq":
            target_platform = self.api_settings["polish"]

        api_url = self.base_url
        api_key = self.get_next_apikey()
        api_format = self.platforms.get(target_platform).get("api_format")
        model_name = self.model
        region = self.platforms.get(target_platform).get("region",'')
        access_key = self.platforms.get(target_platform).get("access_key",'')
        secret_key = self.platforms.get(target_platform).get("secret_key",'')
        request_timeout = self.request_timeout
        temperature = self.platforms.get(target_platform).get("temperature")
        top_p = self.platforms.get(target_platform).get("top_p")
        presence_penalty = self.platforms.get(target_platform).get("presence_penalty")
        frequency_penalty = self.platforms.get(target_platform).get("frequency_penalty")
        extra_body = self.platforms.get(target_platform).get("extra_body",{})
        think_switch = self.platforms.get(target_platform).get("think_switch")
        think_depth = self.platforms.get(target_platform).get("think_depth")
        thinking_budget = self.platforms.get(target_platform).get("thinking_budget", -1)

        params = {
            "target_platform": target_platform,
            "api_url": api_url,
            "api_key": api_key,
            "api_format": api_format,
            "model_name": model_name,
            "region": region,
            "access_key": access_key,
            "secret_key": secret_key,
            "request_timeout": request_timeout,
            "temperature": temperature,
            "top_p": top_p,
            "presence_penalty": presence_penalty,
            "frequency_penalty": frequency_penalty,
            "extra_body": extra_body,
            "think_switch": think_switch,
            "think_depth": think_depth,
            "thinking_budget": thinking_budget
        }



        return params


================================================
FILE: ModuleFolders/TaskConfig/TaskType.py
================================================
from Base.Base import Base

class TaskType(Base):

    TRANSLATION = 1000
    POLISH = 2000


================================================
FILE: ModuleFolders/TaskExecutor/PolisherTask.py
================================================
import copy
import re
import time
import itertools

from rich import box
from rich.table import Table
from rich.markup import escape

from Base.Base import Base
from Base.PluginManager import PluginManager
from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig
from ModuleFolders.LLMRequester.LLMRequester import LLMRequester
from ModuleFolders.PromptBuilder.PromptBuilderPolishing import PromptBuilderPolishing
from ModuleFolders.ResponseExtractor.ResponseExtractor import ResponseExtractor
from ModuleFolders.ResponseChecker.ResponseChecker import ResponseChecker
from ModuleFolders.RequestLimiter.RequestLimiter import RequestLimiter

from ModuleFolders.TextProcessor.PolishTextProcessor import PolishTextProcessor

class PolisherTask(Base):

    def __init__(self, config: TaskConfig, plugin_manager: PluginManager, request_limiter: RequestLimiter) -> None:
        super().__init__()

        self.config = config
        self.plugin_manager = plugin_manager
        self.request_limiter = request_limiter
        self.text_processor = PolishTextProcessor(self.config) # 文本处理器

        # 提示词与信息内容存储
        self.messages = []
        self.system_prompt = ""

        # 输出日志存储
        self.extra_log = []


    # 设置缓存数据
    def set_items(self, items: list[CacheItem]) -> None:
        self.items = items

    # 设置上文数据
    def set_previous_items(self, previous_items: list[CacheItem]) -> None:
        self.previous_items = previous_items

    # 消息构建预处理
    def prepare(self) -> None:

        # 生成上文文本列表
        self.previous_text_list = [v.source_text for v in self.previous_items]

        # 生成原文文本字典
        self.source_text_dict = {str(i): v.source_text for i, v in enumerate(self.items)}

        # 如果开启了翻译文本润色模式
        self.translation_text_dict = {}
        if self.config.polishing_mode_selection == "translated_text_polish":
            self.translation_text_dict = {str(i): v.translated_text for i, v in enumerate(self.items)}

        # 生成文本行数信息
        self.row_count = len(self.source_text_dict)

        # 译前处理
        self.source_text_dict = self.text_processor.replace_all(
            self.config,
            self.source_text_dict
            )
        if self.config.polishing_mode_selection == "translated_text_polish":
            self.translation_text_dict = self.text_processor.replace_all(
                self.config,
                self.translation_text_dict
                )

        # 生成请求指令
        self.messages, self.system_prompt, self.extra_log = PromptBuilderPolishing.generate_prompt(
            self.config,
            self.source_text_dict,
            self.translation_text_dict,
            self.previous_text_list,
        )

        # 预估 Token 消费
        self.request_tokens_consume = self.request_limiter.calculate_tokens(self.messages,self.system_prompt,)


    # 启动任务
    def start(self) -> dict:
        return self.unit_translation_task()

    # 单请求翻译任务
    def unit_translation_task(self) -> dict:
        # 任务开始的时间
        task_start_time = time.time()

        while True:
            # 检测是否收到停止翻译事件
            if Base.work_status == Base.STATUS.STOPING:
                return {}

            # 检查是否超时，超时则直接跳过当前任务，以避免死循环
            if time.time() - task_start_time >= self.config.request_timeout:
                return {}

            # 检查 RPM 和 TPM 限制，如果符合条件，则继续
            if self.request_limiter.check_limiter(self.request_tokens_consume):
                break

            # 如果以上条件都不符合，则间隔 1 秒再次检查
            time.sleep(1)

        # 获取接口配置信息包
        platform_config = self.config.get_platform_configuration("polishingReq")

        # 发起请求
        requester = LLMRequester()
        skip, response_think, response_content, prompt_tokens, completion_tokens = requester.sent_request(
            self.messages,
            self.system_prompt,
            platform_config
        )

        # 如果请求结果标记为 skip，即有运行错误发生，则直接返回错误信息，停止后续任务
        if skip == True:
            return {
                "check_result": False,
                "row_count": 0,
                "prompt_tokens": self.request_tokens_consume,
                "completion_tokens": 0,
            }

        # 返空判断
        if response_content is None or not response_content.strip():
            error = "API请求错误，模型回复内容为空，将在下一轮次重试"
            self.print(
                self.generate_log_table(
                    *self.generate_log_rows(
                        error,
                        task_start_time,
                        prompt_tokens if prompt_tokens is not None else self.request_tokens_consume,
                        0,
                        [],
                        [],
                        []
                    )
                )
            )
            return {
                "check_result": False,
                "row_count": 0,
                "prompt_tokens": self.request_tokens_consume,
                "completion_tokens": 0,
            }

        # 根据润色模式调整文本对象
        if self.config.polishing_mode_selection == "source_text_polish":
            # 如果是源文本润色模式，则直接使用源文本字典
            text_dict = self.source_text_dict
        elif self.config.polishing_mode_selection == "translated_text_polish":
            # 如果是译文润色模式，则使用译文文本字典
            text_dict = self.translation_text_dict

        # 提取回复内容
        response_dict = ResponseExtractor.text_extraction(self, text_dict, response_content)

        # 检查回复内容
        check_result, error_content = ResponseChecker.check_polish_response_content(
            self,
            self.config,
            response_content,
            response_dict,
            text_dict
        )

        # 去除回复内容的数字序号
        response_dict = ResponseExtractor.remove_numbered_prefix(self, response_dict)


        # 模型回复日志
        if response_think:
            self.extra_log.append("模型思考内容：\n" + response_think)
        if self.is_debug():
            self.extra_log.append("模型回复内容：\n" + response_content)

        # 检查译文
        if check_result == False:
            error = f"译文文本未通过检查，将在下一轮次的翻译中重新翻译 - {error_content}"

            # 打印任务结果
            self.print(
                self.generate_log_table(
                    *self.generate_log_rows(
                        error,
                        task_start_time,
                        prompt_tokens,
                        completion_tokens,
                        text_dict.values(),
                        response_dict.values(),
                        self.extra_log,
                    )
                )
            )
        else:
            # 各种翻译后处理
            restore_response_dict = copy.copy(response_dict)
            restore_response_dict = self.text_processor.restore_all(self.config, restore_response_dict)


            # 更新译文结果到缓存数据中
            for item, response in zip(self.items, restore_response_dict.values()):
                with item.atomic_scope():
                    item.model = self.config.model
                    item.polished_text = response
                    item.translation_status = TranslationStatus.POLISHED


            # 打印任务结果
            self.print(
                self.generate_log_table(
                    *self.generate_log_rows(
                        "",
                        task_start_time,
                        prompt_tokens,
                        completion_tokens,
                        text_dict.values(),
                        response_dict.values(),
                        self.extra_log,
                    )
                )
            )


        # 否则返回译文检查的结果
        if check_result == False:
            return {
                "check_result": False,
                "row_count": 0,
                "prompt_tokens": self.request_tokens_consume,
                "completion_tokens": 0,
            }
        else:
            return {
                "check_result": check_result,
                "row_count": self.row_count,
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
            }


    # 生成日志行
    def generate_log_rows(self, error: str, start_time: int, prompt_tokens: int, completion_tokens: int, source: list[str], translated: list[str], extra_log: list[str]) -> tuple[list[str], bool]:
        rows = []

        if error != "":
            rows.append(error)
        else:
            rows.append(
                f"任务耗时 {(time.time() - start_time):.2f} 秒，"
                + f"文本行数 {len(source)} 行，提示消耗 {prompt_tokens} Tokens，补全消耗 {completion_tokens} Tokens"
            )

        # 添加额外日志
        for v in extra_log:
            rows.append(v.strip())

        # 原文译文对比
        pair = ""
        # 修复变量名冲突问题，将循环变量改为 s 和 t
        for idx, (s, t) in enumerate(itertools.zip_longest(source, translated, fillvalue=""), 1):
            pair += f"\n"
            # 处理原文和译文的换行，分割成多行
            s_lines = s.split('\n') if s is not None else ['']
            t_lines = t.split('\n') if t is not None else ['']
            # 逐行对比，确保对齐
            for s_line, t_line in itertools.zip_longest(s_lines, t_lines, fillvalue=""):
                pair += f"{s_line} [bright_blue]-->[/] {t_line}\n"

        rows.append(pair.strip())

        return rows, error == ""

    # 生成日志表格
    def generate_log_table(self, rows: list, success: bool) -> Table:
        table = Table(
            box = box.ASCII2,
            expand = True,
            title = " ",
            caption = " ",
            highlight = True,
            show_lines = True,
            show_header = False,
            show_footer = False,
            collapse_padding = True,
            border_style = "green" if success else "red",
        )
        table.add_column("", style = "white", ratio = 1, overflow = "fold")

        for row in rows:
            if isinstance(row, str):
                table.add_row(escape(row, re.compile(r"(\\*)(\[(?!bright_blue\]|\/\])[a-z#/@][^[]*?)").sub)) # 修复rich table不显示[]内容问题
            else:
                table.add_row(*row)

        return table




================================================
FILE: ModuleFolders/TaskExecutor/TaskExecutor.py
================================================
import time
import threading
import concurrent.futures

import opencc
from tqdm import tqdm

from Base.Base import Base
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheManager import CacheManager
from ModuleFolders.Cache.CacheProject import CacheProjectStatistics
from ModuleFolders.TaskConfig.TaskType import TaskType
from ModuleFolders.TaskExecutor.TranslatorTask import TranslatorTask
from ModuleFolders.TaskExecutor.PolisherTask import PolisherTask
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig
from ModuleFolders.PromptBuilder.PromptBuilder import PromptBuilder
from ModuleFolders.PromptBuilder.PromptBuilderPolishing import PromptBuilderPolishing
from ModuleFolders.PromptBuilder.PromptBuilderEnum import PromptBuilderEnum
from ModuleFolders.PromptBuilder.PromptBuilderLocal import PromptBuilderLocal
from ModuleFolders.PromptBuilder.PromptBuilderSakura import PromptBuilderSakura
from ModuleFolders.RequestLimiter.RequestLimiter import RequestLimiter
from ModuleFolders.TaskExecutor.TranslatorUtil import get_source_language_for_file


# 翻译器
class TaskExecutor(Base):

    def __init__(self, plugin_manager,cache_manager, file_reader, file_writer) -> None:
        super().__init__()

        # 初始化
        self.plugin_manager = plugin_manager
        self.cache_manager = cache_manager
        self.file_reader = file_reader
        self.file_writer = file_writer
        self.config = TaskConfig()
        self.request_limiter = RequestLimiter()

        # 注册事件
        self.subscribe(Base.EVENT.TASK_STOP, self.task_stop)
        self.subscribe(Base.EVENT.TASK_START, self.task_start)
        self.subscribe(Base.EVENT.TASK_MANUAL_EXPORT, self.task_manual_export)
        self.subscribe(Base.EVENT.APP_SHUT_DOWN, self.app_shut_down)

    # 应用关闭事件
    def app_shut_down(self, event: int, data: dict) -> None:
        Base.work_status = Base.STATUS.STOPING

    # 手动导出事件
    def task_manual_export(self, event: int, data: dict) -> None:

        self.print("")
        self.info(f"正在读取数据，准备输出中 ...")
        self.print("")

        # 获取配置信息，此时 config 是一个字典，后面需要使用get
        config = self.load_config()
        
        output_path = data.get("export_path")
        inpput_path = config.get("label_input_path")

        # 触发手动导出插件事件
        self.plugin_manager.broadcast_event("manual_export", config, self.cache_manager.project)

        # 如果开启了转换简繁开关功能，则进行文本转换
        if config.get("response_conversion_toggle"):  # 使用 .get()
            self.print("")

            self.info(f"已启动自动简繁转换功能，正在使用 {config.get('opencc_preset')} 配置进行字形转换 ...")
            self.print("")

            converter = opencc.OpenCC(config.get('opencc_preset'))
            cache_list = self.cache_manager.project.items_iter()
            for item in cache_list:
                if item.translation_status == TranslationStatus.TRANSLATED:
                    item.translated_text = converter.convert(item.translated_text)
                if item.translation_status == TranslationStatus.POLISHED:
                    item.polished_text = converter.convert(item.polished_text)
            self.print("")
            self.info(f"简繁转换完成。")
            self.print("")

        # 输出配置包
        output_config = {
            "translated_suffix": config.get('output_filename_suffix'),
            "bilingual_suffix": "_bilingual",
            "bilingual_order": config.get('bilingual_text_order','translation_first') 
        }

        # 写入文件
        self.file_writer.output_translated_content(
            self.cache_manager.project,
            output_path,
            inpput_path, 
            output_config, 
        )

        self.print("")
        self.info(f"翻译结果已成功保存至 {output_path} 目录。")
        self.print("")

    # 任务停止事件
    def task_stop(self, event: int, data: dict) -> None:
        # 设置运行状态为停止中
        Base.work_status = Base.STATUS.STOPING

        def target() -> None:
            while True:
                time.sleep(0.5)
                if Base.work_status == Base.STATUS.TASKSTOPPED:
                    self.print("")
                    self.info("翻译任务已停止 ...")
                    self.print("")
                    self.emit(Base.EVENT.TASK_STOP_DONE, {})
                    break

        # 子线程循环检测停止状态
        threading.Thread(target = target).start()

    # 任务开始事件
    def task_start(self, event: int, data: dict) -> None:
        # 获取配置信息
        continue_status = data.get("continue_status")
        current_mode = data.get("current_mode")

        # 翻译任务
        if current_mode == TaskType.TRANSLATION:
            threading.Thread(
                target = self.translation_start_target,
                args = (continue_status,),
            ).start()
        
        # 润色任务
        elif current_mode == TaskType.POLISH:
            threading.Thread(
                target = self.polish_start_target,
                args = (continue_status,),
            ).start()

        else:
            self.print("")
            self.error(f"非法的翻译模式：{current_mode}，请检查配置文件 ...")
            self.print("")
            return None

    # 翻译主流程
    def translation_start_target(self, continue_status: bool) -> None:

        # 设置翻译状态为正在翻译状态
        Base.work_status = Base.STATUS.TASKING

        # 读取配置文件，并保存到该类中
        self.config.initialize()

        # 配置翻译平台信息
        self.config.prepare_for_translation(TaskType.TRANSLATION)

        # 配置请求限制器
        self.request_limiter.set_limit(self.config.tpm_limit, self.config.rpm_limit)

        # 初开始翻译时，生成监控数据
        if continue_status == False:
            self.project_status_data = CacheProjectStatistics()
            self.cache_manager.project.stats_data = self.project_status_data
        # 继续翻译时加载存储的监控数据
        else:
            self.project_status_data = self.cache_manager.project.stats_data
            self.project_status_data.start_time = time.time() # 重置开始时间
            self.project_status_data.total_completion_tokens = 0 # 重置完成的token数量

        # 重新同步计数器以反映缓存的当前真实状态（未考虑到被过滤条目）    
        
        # 更新监控面板信息
        self.emit(Base.EVENT.TASK_UPDATE, self.project_status_data.to_dict())

        # 触发插件事件
        self.plugin_manager.broadcast_event("text_filter", self.config, self.cache_manager.project)
        self.plugin_manager.broadcast_event("preproces_text", self.config, self.cache_manager.project)

        # 根据最大轮次循环
        for current_round in range(self.config.round_limit + 1):
            # 检测是否需要停止任务
            if Base.work_status == Base.STATUS.STOPING:
                # 循环次数比实际最大轮次要多一轮，当触发停止翻译的事件时，最后都会从这里退出任务
                # 执行到这里说明停止任意的任务已经执行完毕，可以重置内部状态了
                Base.work_status = Base.STATUS.TASKSTOPPED
                return None

            # 获取 待翻译 状态的条目数量
            item_count_status_untranslated = self.cache_manager.get_item_count_by_status(TranslationStatus.UNTRANSLATED)

            # 判断是否需要继续翻译
            if item_count_status_untranslated == 0:
                self.print("")
                self.info("所有文本均已翻译，翻译任务已结束 ...")
                self.print("")
                break

            # 达到最大翻译轮次时
            if item_count_status_untranslated > 0 and current_round == self.config.round_limit:
                self.print("")
                self.warning("已达到最大翻译轮次，仍有部分文本未翻译，请检查结果 ...")
                self.print("")
                break

            # 第一轮时且不是继续翻译时，记录总行数
            if current_round == 0 and continue_status == False:
                self.project_status_data.total_line = item_count_status_untranslated

            # 第二轮开始对半切分
            if current_round > 0:
                self.config.lines_limit = max(1, int(self.config.lines_limit / 2))
                self.config.tokens_limit = max(1, int(self.config.tokens_limit / 2))

            # 生成缓存数据条目片段的合集列表，原文列表与上文列表一一对应
            chunks, previous_chunks, file_paths = self.cache_manager.generate_item_chunks(
                "line" if self.config.tokens_limit_switch == False else "token",
                self.config.lines_limit if self.config.tokens_limit_switch == False else self.config.tokens_limit,
                self.config.pre_line_counts,
                TaskType.TRANSLATION
            )

            # 生成翻译任务合集列表
            tasks_list = []
            print("")
            self.info(f"正在生成翻译任务 ...")
            for chunk, previous_chunk, file_path in tqdm(zip(chunks, previous_chunks, file_paths),desc="生成翻译任务", total=len(chunks)):
                # 确定该任务的主语言
                language_stats = self.cache_manager.project.get_file(file_path).language_stats # 获取该文件的语言检测数据
                file_source_lang = get_source_language_for_file(self.config.source_language,self.config.target_language,language_stats)

                task = TranslatorTask(self.config, self.plugin_manager, self.request_limiter, file_source_lang)  # 实例化
                task.set_items(chunk)  # 传入该任务待翻译原文
                task.set_previous_items(previous_chunk)  # 传入该任务待翻译原文的上文
                task.prepare(self.config.target_platform)  # 预先构建消息列表
                tasks_list.append(task)
            self.info(f"已经生成全部翻译任务 ...")
            self.print("")

            # 输出开始翻译的日志
            self.print("")
            self.info(f"当前轮次 - {current_round + 1}")
            self.info(f"最大轮次 - {self.config.round_limit}")
            self.info(f"项目类型 - {self.config.translation_project}")
            self.info(f"原文语言 - {self.config.source_language}")
            self.info(f"译文语言 - {self.config.target_language}")
            self.print("")
            self.info(f"接口名称 - {self.config.platforms.get(self.config.target_platform, {}).get("name", "未知")}")
            self.info(f"接口地址 - {self.config.base_url}")
            self.info(f"模型名称 - {self.config.model}")
            self.print("")
            self.info(f"RPM 限额 - {self.config.rpm_limit}")
            self.info(f"TPM 限额 - {self.config.tpm_limit}")

            # 根据提示词规则打印基础指令
            system = ""
            s_lang = self.config.source_language
            if self.config.target_platform == "LocalLLM":  # 需要放在前面，以免提示词预设的分支覆盖
                system = PromptBuilderLocal.build_system(self.config, s_lang)
            elif self.config.target_platform == "sakura":  # 需要放在前面，以免提示词预设的分支覆盖
                system = PromptBuilderSakura.build_system(self.config, s_lang)
            elif self.config.translation_prompt_selection["last_selected_id"] in (PromptBuilderEnum.COMMON, PromptBuilderEnum.COT, PromptBuilderEnum.THINK):
                system = PromptBuilder.build_system(self.config, s_lang)
            else:
                system = self.config.translation_prompt_selection["prompt_content"]
            self.print("")
            if system:
                self.info(f"本次任务使用以下基础提示词：\n{system}\n") 

            self.info(f"即将开始执行翻译任务，预计任务总数为 {len(tasks_list)}, 同时执行的任务数量为 {self.config.actual_thread_counts}，请注意保持网络通畅 ...")
            time.sleep(3)
            self.print("")

            # 开始执行翻译任务,构建异步线程池
            with concurrent.futures.ThreadPoolExecutor(max_workers = self.config.actual_thread_counts, thread_name_prefix = "translator") as executor:
                for task in tasks_list:
                    future = executor.submit(task.start)
                    future.add_done_callback(self.task_done_callback)  # 为future对象添加一个回调函数，当任务完成时会被调用，更新数据

        # 等待可能存在的缓存文件写入请求处理完毕
        time.sleep(CacheManager.SAVE_INTERVAL)

        # 触发插件事件
        self.plugin_manager.broadcast_event("postprocess_text", self.config, self.cache_manager.project)

        # 如果开启了转换简繁开关功能，则进行文本转换
        if self.config.response_conversion_toggle:

            self.print("")
            self.info(f"已启动自动简繁转换功能，正在使用 {self.config.opencc_preset} 配置进行字形转换 ...")
            self.print("")

            converter = opencc.OpenCC(self.config.opencc_preset)
            cache_list = self.cache_manager.project.items_iter()
            for item in cache_list:
                if item.translation_status == TranslationStatus.TRANSLATED:
                    item.translated_text = converter.convert(item.translated_text)
                if item.translation_status == TranslationStatus.POLISHED:
                    item.polished_text = converter.convert(item.polished_text)

        # 输出配置包
        output_config = {
             "translated_suffix": self.config.output_filename_suffix,
             "bilingual_suffix": "_bilingual",
             "bilingual_order": self.config.bilingual_text_order 
        }

        # 写入文件
        self.file_writer.output_translated_content(
            self.cache_manager.project,
            self.config.label_output_path,
            self.config.label_input_path,
            output_config,
        )
        self.print("")
        self.info(f"翻译结果已保存至 {self.config.label_output_path} 目录 ...")
        self.print("")

        # 重置内部状态（正常完成翻译）
        Base.work_status = Base.STATUS.TASKSTOPPED

        # 触发翻译停止完成的事件
        self.emit(Base.EVENT.TASK_STOP_DONE, {})
        self.plugin_manager.broadcast_event("translation_completed", self.config, self.cache_manager.project)

        # 触发翻译完成事件
        self.emit(Base.EVENT.TASK_COMPLETED, {})

    # 润色主流程
    def polish_start_target(self, continue_status: bool) -> None:

        # 设置翻译状态为正在翻译状态
        Base.work_status = Base.STATUS.TASKING

        # 读取配置文件，并保存到该类中
        self.config.initialize()

        # 配置翻译平台信息
        self.config.prepare_for_translation(TaskType.POLISH)

        # 配置请求限制器
        self.request_limiter.set_limit(self.config.tpm_limit, self.config.rpm_limit)

        # 初开始任务时，生成监控数据
        if continue_status == False:
            self.project_status_data = CacheProjectStatistics()
            self.cache_manager.project.stats_data = self.project_status_data
        # 继续翻译时加载存储的监控数据
        else:
            self.project_status_data = self.cache_manager.project.stats_data
            self.project_status_data.start_time = time.time() # 重置开始时间
            self.project_status_data.total_completion_tokens = 0 # 重置完成的token数量                  

        # 更新监控面板信息
        self.emit(Base.EVENT.TASK_UPDATE, self.project_status_data.to_dict())

        # 触发插件事件
        self.plugin_manager.broadcast_event("text_filter", self.config, self.cache_manager.project)


        # 根据最大轮次循环
        for current_round in range(self.config.round_limit + 1):
            # 检测是否需要停止任务
            if Base.work_status == Base.STATUS.STOPING:
                # 循环次数比实际最大轮次要多一轮，当触发停止翻译的事件时，最后都会从这里退出任务
                # 执行到这里说明停止任意的任务已经执行完毕，可以重置内部状态了
                Base.work_status = Base.STATUS.TASKSTOPPED
                return None

            # 根据润色模式，获取可润色的条目数量
            if self.config.polishing_mode_selection == "source_text_polish":
                item_count_status_unpolishd = self.cache_manager.get_item_count_by_status(TranslationStatus.UNTRANSLATED)
            elif self.config.polishing_mode_selection == "translated_text_polish":
                item_count_status_unpolishd = self.cache_manager.get_item_count_by_status(TranslationStatus.TRANSLATED)

            # 判断是否需要继续润色
            if item_count_status_unpolishd == 0:
                self.print("")
                self.info("所有文本均已润色，润色任务已结束 ...")
                self.print("")
                break

            # 达到最大任务轮次时
            if item_count_status_unpolishd > 0 and current_round == self.config.round_limit:
                self.print("")
                self.warning("已达到最大任务轮次，仍有部分文本未翻译，请检查结果 ...")
                self.print("")
                break

            # 第一轮时且不是继续润色时，记录总行数
            if current_round == 0 and continue_status == False:
             self.project_status_data.total_line = item_count_status_unpolishd

            # 第二轮开始对半切分
            if current_round > 0:
                self.config.lines_limit = max(1, int(self.config.lines_limit / 2))
                self.config.tokens_limit = max(1, int(self.config.tokens_limit / 2))

            # 生成缓存数据条目片段的合集列表
            if self.config.polishing_mode_selection == "source_text_polish":
                chunks, previous_chunks, file_paths = self.cache_manager.generate_item_chunks(
                    "line" if self.config.tokens_limit_switch == False else "token",
                    self.config.lines_limit if self.config.tokens_limit_switch == False else self.config.tokens_limit,
                    self.config.polishing_pre_line_counts,
                    TaskType.TRANSLATION
                )
            elif self.config.polishing_mode_selection == "translated_text_polish":
                chunks, previous_chunks, file_paths = self.cache_manager.generate_item_chunks(
                    "line" if self.config.tokens_limit_switch == False else "token",
                    self.config.lines_limit if self.config.tokens_limit_switch == False else self.config.tokens_limit,
                    self.config.polishing_pre_line_counts,
                    TaskType.POLISH
                )

            # 生成润色任务合集列表
            tasks_list = []
            print("")
            self.info(f"正在生成润色任务 ...")
            for chunk, previous_chunk, file_path in tqdm(zip(chunks, previous_chunks, file_paths),desc="生成润色任务", total=len(chunks)):
                task = PolisherTask(self.config, self.plugin_manager, self.request_limiter)  # 实例化
                task.set_items(chunk)  # 传入该任务待润色文
                task.set_previous_items(previous_chunk)  # 传入该任务待润色文的上文
                task.prepare()  # 预先构建消息列表
                tasks_list.append(task)
            self.info(f"已经生成全部润色任务 ...")
            self.print("")

            # 输出开始翻译的日志
            self.print("")
            self.info(f"当前轮次 - {current_round + 1}")
            self.info(f"最大轮次 - {self.config.round_limit}")
            self.info(f"项目类型 - {self.config.translation_project}")
            self.print("")
            self.info(f"接口名称 - {self.config.platforms.get(self.config.target_platform, {}).get("name", "未知")}")
            self.info(f"接口地址 - {self.config.base_url}")
            self.info(f"模型名称 - {self.config.model}")
            self.print("")
            self.info(f"RPM 限额 - {self.config.rpm_limit}")
            self.info(f"TPM 限额 - {self.config.tpm_limit}")

            # 根据提示词规则打印基础指令
            system = ""
            if self.config.polishing_prompt_selection["last_selected_id"] == PromptBuilderEnum.POLISH_COMMON:
                system = PromptBuilderPolishing.build_system(self.config)
            else:
                system = self.config.polishing_prompt_selection["prompt_content"]
            self.print("")
            if system:
                self.info(f"本次任务使用以下基础提示词：\n{system}\n") 

            self.info(f"即将开始执行润色任务，预计任务总数为 {len(tasks_list)}, 同时执行的任务数量为 {self.config.actual_thread_counts}，请注意保持网络通畅 ...")
            time.sleep(3)
            self.print("")

            # 开始执行润色务,构建异步线程池
            with concurrent.futures.ThreadPoolExecutor(max_workers = self.config.actual_thread_counts, thread_name_prefix = "translator") as executor:
                for task in tasks_list:
                    future = executor.submit(task.start)
                    future.add_done_callback(self.task_done_callback)  # 为future对象添加一个回调函数，当任务完成时会被调用，更新数据

        # 等待可能存在的缓存文件写入请求处理完毕
        time.sleep(CacheManager.SAVE_INTERVAL)

        # 输出配置包
        output_config = {
             "translated_suffix": self.config.output_filename_suffix,
             "bilingual_suffix": "_bilingual",
             "bilingual_order": self.config.bilingual_text_order 
        }

        # 写入文件
        self.file_writer.output_translated_content(
            self.cache_manager.project,
            self.config.polishing_output_path,
            self.config.label_input_path,
            output_config,
        )
        self.print("")
        self.info(f"润色结果已保存至 {self.config.polishing_output_path} 目录 ...")
        self.print("")

        # 重置内部状态
        Base.work_status = Base.STATUS.TASKSTOPPED

        # 触发事件
        self.emit(Base.EVENT.TASK_STOP_DONE, {})     # 翻译停止完成的事件
        self.plugin_manager.broadcast_event("polish_completed", self.config, self.cache_manager.project)
        self.emit(Base.EVENT.TASK_COMPLETED, {})     # 翻译完成事件



    # 单个翻译任务完成时,更新项目进度状态   
    def task_done_callback(self, future: concurrent.futures.Future) -> None:
        try:
            # 获取结果
            result = future.result()

            # 结果为空则跳过后续的更新步骤
            if result == None or len(result) == 0:
                return

            # 更新翻译进度到缓存数据
            with self.project_status_data.atomic_scope():
                self.project_status_data.total_requests += 1
                self.project_status_data.error_requests += 0 if result.get("check_result") else 1
                self.project_status_data.line += result.get("row_count", 0)
                self.project_status_data.token += result.get("prompt_tokens", 0) + result.get("completion_tokens", 0)
                self.project_status_data.total_completion_tokens += result.get("completion_tokens", 0)
                self.project_status_data.time = time.time() - self.project_status_data.start_time
                stats_dict = self.project_status_data.to_dict()

            # 请求保存缓存文件
            self.cache_manager.require_save_to_file(self.config.label_output_path)

            # 触发翻译进度更新事件
            self.emit(Base.EVENT.TASK_UPDATE, stats_dict)
        except Exception as e:
            self.error(f"翻译任务错误 ... {e}", e if self.is_debug() else None)




================================================
FILE: ModuleFolders/TaskExecutor/TranslatorTask.py
================================================
import copy
import re
import time
import itertools

from rich import box
from rich.table import Table
from rich.markup import escape

from Base.Base import Base
from Base.PluginManager import PluginManager
from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig
from ModuleFolders.LLMRequester.LLMRequester import LLMRequester
from ModuleFolders.PromptBuilder.PromptBuilder import PromptBuilder
from ModuleFolders.PromptBuilder.PromptBuilderLocal import PromptBuilderLocal
from ModuleFolders.PromptBuilder.PromptBuilderSakura import PromptBuilderSakura
from ModuleFolders.ResponseExtractor.ResponseExtractor import ResponseExtractor
from ModuleFolders.ResponseChecker.ResponseChecker import ResponseChecker
from ModuleFolders.RequestLimiter.RequestLimiter import RequestLimiter

from ModuleFolders.TextProcessor.TextProcessor import TextProcessor


class TranslatorTask(Base):

    def __init__(self, config: TaskConfig, plugin_manager: PluginManager, request_limiter: RequestLimiter, source_lang) -> None:
        super().__init__()

        self.config = config
        self.plugin_manager = plugin_manager
        self.request_limiter = request_limiter
        self.text_processor = TextProcessor(self.config) # 文本处理器

        # 源语言对象
        self.source_lang = source_lang

        # 提示词与信息内容存储
        self.messages = []
        self.system_prompt = ""

        # 输出日志存储
        self.extra_log = []
        # 前后缀处理信息存储
        self.prefix_codes = {}
        self.suffix_codes = {}
        # 占位符顺序存储结构
        self.placeholder_order = {}
        # 前后换行空格处理信息存储
        self.affix_whitespace_storage = {}


    # 设置缓存数据
    def set_items(self, items: list[CacheItem]) -> None:
        self.items = items

    # 设置上文数据
    def set_previous_items(self, previous_items: list[CacheItem]) -> None:
        self.previous_items = previous_items

    # 消息构建预处理
    def prepare(self, target_platform: str) -> None:

        # 生成上文文本列表
        self.previous_text_list = [v.source_text for v in self.previous_items]

        # 生成原文文本字典
        self.source_text_dict = {str(i): v.source_text for i, v in enumerate(self.items)}

        # 生成文本行数信息
        self.row_count = len(self.source_text_dict)

        # 触发插件事件 - 文本正规化
        self.plugin_manager.broadcast_event("normalize_text", self.config, self.source_text_dict)

        # 各种替换步骤，译前替换，提取首尾与占位中间代码
        self.source_text_dict, self.prefix_codes, self.suffix_codes, self.placeholder_order, self.affix_whitespace_storage = \
            self.text_processor.replace_all(
                self.config,
                self.source_lang, 
                self.source_text_dict
            )
        
        # 生成请求指令
        if target_platform == "sakura":
            self.messages, self.system_prompt, self.extra_log = PromptBuilderSakura.generate_prompt_sakura(
                self.config,
                self.source_text_dict,
                self.previous_text_list, 
                self.source_lang, 
            )
        elif target_platform == "LocalLLM":
            self.messages, self.system_prompt, self.extra_log = PromptBuilderLocal.generate_prompt_LocalLLM(
                self.config,
                self.source_text_dict,
                self.previous_text_list,
                self.source_lang,
            )
        else:
            self.messages, self.system_prompt, self.extra_log = PromptBuilder.generate_prompt(
                self.config,
                self.source_text_dict,
                self.previous_text_list,
                self.source_lang,
            )

        # 预估 Token 消费
        self.request_tokens_consume = self.request_limiter.calculate_tokens(self.messages,self.system_prompt,)


    # 启动任务
    def start(self) -> dict:
        return self.unit_translation_task()


    # 单请求翻译任务
    def unit_translation_task(self) -> dict:
        # 任务开始的时间
        task_start_time = time.time()

        while True:
            # 检测是否收到停止翻译事件
            if Base.work_status == Base.STATUS.STOPING:
                return {}

            # 检查是否超时，超时则直接跳过当前任务，以避免死循环
            if time.time() - task_start_time >= self.config.request_timeout:
                return {}

            # 检查 RPM 和 TPM 限制，如果符合条件，则继续
            if self.request_limiter.check_limiter(self.request_tokens_consume):
                break

            # 如果以上条件都不符合，则间隔 1 秒再次检查
            time.sleep(1)

        # 获取接口配置信息包
        platform_config = self.config.get_platform_configuration("translationReq")

        # 发起请求
        requester = LLMRequester()
        skip, response_think, response_content, prompt_tokens, completion_tokens = requester.sent_request(
            self.messages,
            self.system_prompt,
            platform_config
        )

        # 如果请求结果标记为 skip，即有运行错误发生，则直接返回错误信息，停止后续任务
        if skip == True:
            return {
                "check_result": False,
                "row_count": 0,
                "prompt_tokens": self.request_tokens_consume,
                "completion_tokens": 0,
            }

        # 返空判断
        if response_content is None or not response_content.strip():
            error = "API请求错误，模型回复内容为空，将在下一轮次重试"
            self.print(
                self.generate_log_table(
                    *self.generate_log_rows(
                        error,
                        task_start_time,
                        prompt_tokens if prompt_tokens is not None else self.request_tokens_consume,
                        0,
                        [],  
                        [], 
                        []   
                    )
                )
            )
            return {
                "check_result": False,
                "row_count": 0,
                "prompt_tokens": self.request_tokens_consume,
                "completion_tokens": 0,
            }         

        # 提取回复内容
        response_dict = ResponseExtractor.text_extraction(self, self.source_text_dict, response_content)

        # 检查回复内容
        check_result, error_content = ResponseChecker.check_response_content(
            self,
            self.config,
            self.placeholder_order,
            response_content,
            response_dict,
            self.source_text_dict,
            self.source_lang
        )

        # 去除回复内容的数字序号
        response_dict = ResponseExtractor.remove_numbered_prefix(self, response_dict)


        # 模型回复日志
        if response_think:
            self.extra_log.append("模型思考内容：\n" + response_think)
        if self.is_debug():
            self.extra_log.append("模型回复内容：\n" + response_content)

        # 检查译文
        if check_result == False:
            error = f"译文文本未通过检查，将在下一轮次的翻译中重新翻译 - {error_content}"

            # 打印任务结果
            self.print(
                self.generate_log_table(
                    *self.generate_log_rows(
                        error,
                        task_start_time,
                        prompt_tokens,
                        completion_tokens,
                        self.source_text_dict.values(),
                        response_dict.values(),
                        self.extra_log,
                    )
                )
            )
        else:
            # 各种翻译后处理
            restore_response_dict = copy.copy(response_dict)
            restore_response_dict = self.text_processor.restore_all(self.config, restore_response_dict, self.prefix_codes, self.suffix_codes, self.placeholder_order, self.affix_whitespace_storage)

            # 更新译文结果到缓存数据中
            for item, response in zip(self.items, restore_response_dict.values()):
                with item.atomic_scope():
                    item.model = self.config.model
                    item.translated_text = response
                    item.translation_status = TranslationStatus.TRANSLATED


            # 打印任务结果
            self.print(
                self.generate_log_table(
                    *self.generate_log_rows(
                        "",
                        task_start_time,
                        prompt_tokens,
                        completion_tokens,
                        self.source_text_dict.values(),
                        response_dict.values(),
                        self.extra_log,
                    )
                )
            )


        # 否则返回译文检查的结果
        if check_result == False:
            return {
                "check_result": False,
                "row_count": 0,
                "prompt_tokens": self.request_tokens_consume,
                "completion_tokens": 0,
            }
        else:
            return {
                "check_result": check_result,
                "row_count": self.row_count,
                "prompt_tokens": prompt_tokens,
                "completion_tokens": completion_tokens,
            }


    # 生成日志行
    def generate_log_rows(self, error: str, start_time: int, prompt_tokens: int, completion_tokens: int, source: list[str], translated: list[str], extra_log: list[str]) -> tuple[list[str], bool]:
        rows = []

        if error != "":
            rows.append(error)
        else:
            rows.append(
                f"任务耗时 {(time.time() - start_time):.2f} 秒，"
                + f"文本行数 {len(source)} 行，提示消耗 {prompt_tokens} Tokens，补全消耗 {completion_tokens} Tokens"
            )

        # 添加额外日志
        for v in extra_log:
            rows.append(v.strip())

        # 原文译文对比
        pair = ""
        # 修复变量名冲突问题，将循环变量改为 s 和 t
        for idx, (s, t) in enumerate(itertools.zip_longest(source, translated, fillvalue=""), 1):
            pair += f"\n"
            # 处理原文和译文的换行，分割成多行
            s_lines = s.split('\n') if s is not None else ['']
            t_lines = t.split('\n') if t is not None else ['']
            # 逐行对比，确保对齐
            for s_line, t_line in itertools.zip_longest(s_lines, t_lines, fillvalue=""):
                pair += f"{s_line} [bright_blue]-->[/] {t_line}\n"
        
        rows.append(pair.strip())

        return rows, error == ""

    # 生成日志表格
    def generate_log_table(self, rows: list, success: bool) -> Table:
        table = Table(
            box = box.ASCII2,
            expand = True,
            title = " ",
            caption = " ",
            highlight = True,
            show_lines = True,
            show_header = False,
            show_footer = False,
            collapse_padding = True,
            border_style = "green" if success else "red",
        )
        table.add_column("", style = "white", ratio = 1, overflow = "fold")

        for row in rows:
            if isinstance(row, str):
                table.add_row(escape(row, re.compile(r"(\\*)(\[(?!bright_blue\]|\/\])[a-z#/@][^[]*?)").sub)) # 修复rich table不显示[]内容问题
            else:
                table.add_row(*row)

        return table



================================================
FILE: ModuleFolders/TaskExecutor/TranslatorUtil.py
================================================
import langcodes

from ModuleFolders.Cache.CacheProject import CacheProject

pair_en = {
    "japanese": "Japanese",
    "english": "English",
    "korean": "Korean",
    "russian": "Russian",
    "chinese_simplified": "Simplified Chinese",
    "chinese_traditional": "Traditional Chinese",
    "french": "French",
    "german": "German",
    "spanish": "Spanish",
}

pair = {
    "japanese": "日语",
    "english": "英语",
    "korean": "韩语",
    "russian": "俄语",
    "chinese_simplified": "简体中文",
    "chinese_traditional": "繁体中文",
    "french": "法语",
    "german": "德语",
    "spanish": "西班牙语",
}


def map_language_code_to_name(language_code: str) -> str:
    """将语言代码映射到语言名称"""
    mapping = {
        "zh": "chinese_simplified",
        "zh-cn": "chinese_simplified",
        "zh-Hans": "chinese_simplified",
        "zh-tw": "chinese_traditional",
        "yue": "chinese_traditional",
        "zh-Hant": "chinese_traditional",
        "en": "english",
        "es": "spanish",
        "fr": "french",
        "de": "german",
        "ko": "korean",
        "ru": "russian",
        "ja": "japanese"
    }
    return mapping.get(language_code, language_code)


def map_language_name_to_code(language_name: str) -> str:
    """将语言名称映射回语言代码"""
    mapping = {
        "chinese_simplified": "zh",
        "chinese_traditional": "zh-Hant",  # 单独映射到繁中代码
        "english": "en",
        "spanish": "es",
        "french": "fr",
        "german": "de",
        "korean": "ko",
        "russian": "ru",
        "japanese": "ja"
    }
    return mapping.get(language_name, language_name)


def get_language_display_names(source_lang, target_lang):
    """
    获取源语言和目标语言的显示名称
    Args:
        source_lang: 源语言代码
        target_lang: 目标语言代码
    Returns:
        tuple: ((英文源语言名, 中文源语言名), (英文目标语言名, 中文目标语言名))
    """
    # 转换语言代码
    conv_source_lang = map_language_name_to_code(source_lang)
    # 处理源语言
    langcodes_lang = langcodes.Language.get(conv_source_lang)
    if langcodes_lang:
        en_source_lang = langcodes_lang.display_name()
        source_language = langcodes_lang.display_name('zh-Hans')
    else:
        # 处理特殊情况
        if conv_source_lang == 'un':
            en_source_lang = 'UnspecifiedLanguage'
            source_language = '未指定的语言'
        elif conv_source_lang == 'auto':
            en_source_lang = 'Auto Detect'
            source_language = '自动检测'
        else:
            en_source_lang = pair_en[conv_source_lang]
            source_language = pair[conv_source_lang]

    # 处理目标语言
    en_target_language = pair_en[target_lang]
    target_language = pair[target_lang]

    return en_source_lang, source_language, en_target_language, target_language


def get_most_common_language(cache_proj: CacheProject) -> str:
    """
    计算项目中出现次数最多的语言
    Args:
        cache_proj: 项目属性
    Returns:
        出现次数最多的语言代码
    """
    # 语言计数字典
    language_counts = {}

    # 遍历所有文件的语言统计信息
    for path, file in cache_proj.files.items():
        if file.language_stats:
            for lang_stat in file.language_stats:
                if len(lang_stat) >= 2 and lang_stat[0] != 'un':  # 跳过未知语言
                    lang_code = lang_stat[0]
                    count = lang_stat[1] if len(lang_stat) > 1 else 1

                    if lang_code in language_counts:
                        language_counts[lang_code] += count
                    else:
                        language_counts[lang_code] = count

    # 如果没有找到任何语言，返回未知语言作为默认值
    if not language_counts:
        print(
            f"[[red]WARNING[/]] [LanguageFilter] 当前项目没有检测到主要语言信息"
        )
        return "un"

    # 找出出现次数最多的语言
    most_common_lang = max(language_counts.items(), key=lambda x: x[1])[0]

    return most_common_lang

# 确定主语言，通过文件语言统计信息与配置信息计算
def get_source_language_for_file(source_language,target_language, language_stats) -> str:
    """
    为文件确定适当的源语言
    Args:
        storage_path: 文件存储路径
    Returns:
        确定的源语言代码
    """
    # 获取配置文件中预置的源语言配置
    config_s_lang = source_language
    config_t_lang = target_language

    # 如果源语言配置不是自动配置，则直接返回源语言配置，否则使用下面获取到的lang_code
    if config_s_lang != 'auto':
        return config_s_lang

    # 获取文件的语言统计信息
    language_stats = language_stats

    # 如果没有语言统计信息，返回'un'
    if not language_stats:
        return 'un'

    # 获取第一种语言
    first_source_lang = language_stats[0][0]

    # 将first_source_lang转换为与target_lang相同格式的语言名称，方便比较
    first_source_lang_name = map_language_code_to_name(first_source_lang)

    # 检查第一语言是否与目标语言一致
    if first_source_lang_name == config_t_lang:
        # 如果一致，尝试使用第二种语言
        if len(language_stats) > 1:
            return language_stats[1][0]  # 返回第二种语言
        else:
            # 没有第二种语言，返回'un'
            return 'un'
    else:
        # 如果不一致，直接使用第一种语言
        return first_source_lang



================================================
FILE: ModuleFolders/TextProcessor/PolishTextProcessor.py
================================================
[Binary file]


================================================
FILE: ModuleFolders/TextProcessor/TextProcessor.py
================================================
[Binary file]


================================================
FILE: PluginScripts/README.md
================================================

# 插件系统编写指南
欢迎来到插件系统编写指南！本文档将帮助您了解如何为项目编写插件


## 目录
1. [插件编写步骤](#插件编写步骤)
2. [继承插件基类](#继承插件基类)
3. [事件触发说明](#事件触发说明)
4. [示例代码](#示例代码)
5. [插件事件介绍](#插件事件介绍)
6. [贡献指南](#贡献指南)



## 插件编写步骤
1. **环境准备**
   确保您的开发环境满足以下要求：
   - Python 3.12
   - 相关依赖库（请查看`requirements.txt` 和 `requirements_no_deps.txt`）
2. **创建插件文件**
   在项目的`Plugin_Scripts`目录下创建新的子文件夹，并创建新的Python文件，例如`my_plugin.py`。
3. **编写插件代码**
   按照以下模板编写您的插件代码，并确保继承自`PluginBase`类。


## 继承插件基类
所有插件必须继承自`PluginBase`类。以下是`PluginBase`类的简化定义：
```python
class Priority():

    HIGHEST    = 700
    HIGHER     = 600
    HIGH       = 500
    NORMAL     = 400
    LOW        = 300
    LOWER      = 200
    LOWEST     = 100

class PluginBase:

    def __init__(self) -> None:
        self.name = "Unnamed Plugin"
        self.description = "No description provided."

        self.visibility = True      # 是否在插件设置中显示
        self.default_enable = True  # 默认启用状态

        self.events = []            # 插件感兴趣的事件列表，使用字典存储事件名和优先级

    # 加载插件时调用
    def load(self) -> None:
        pass

    # 处理事件
    def on_event(self, event: str, config: TranslatorConfig, event_data: any) -> None:
        pass

    # 添加事件
    def add_event(self, event: str, priority: int) -> None:
        self.events.append(
            {
                "event": event,
                "priority": priority,
            }
        )
```
在编写插件时，您需要创建一个继承自`PluginBase`的新类，并实现必要的方法。


## 事件触发说明
插件可以通过重写 `on_event` 方法来监听和响应事件。以下是事件触发的基本流程：

1. **添加监听事件**
   使用 `add_event` 方法，添加监听的事件及该事件触发的优先级；
   优先级为枚举值，从 `LOWEST` 到 `HIGHEST`，默认为 `NORMAL`；

3. **重写事件处理方法**
   在您的插件类中重写 `on_event` 方法，该方法将接收事件名称和数据。

4. **监听事件**
   在 `on_event` 方法内部，根据事件名称执行相应的逻辑。

## 示例代码
以下是一个简单的插件示例，它继承自 `PluginBase` 并监听了 `manual_export` 、 `preproces_text` 、 `postprocess_text` 事件：
```python
from Plugin_Scripts.PluginBase import PluginBase

class ExamplePlugin(PluginBase):

    def __init__(self) -> None:
        super().__init__()
        self.name = "ExamplePlugin"
        self.description = "This is a Example Plugin ..."

        self.visibility = True          # 是否在插件设置中显示
        self.default_enable = False     # 默认启用状态

        self.add_event("manual_export", PluginBase.PRIORITY.NORMAL)
        self.add_event("preproces_text", PluginBase.PRIORITY.NORMAL)
        self.add_event("postprocess_text", PluginBase.PRIORITY.NORMAL)

    def on_event(self, event: str, config: TranslatorConfig, event_data: list[dict]) -> None:
        if event == "preproces_text":
            self.on_preproces_text(event, config, event_data)

        if event in ("manual_export", "postprocess_text"):
            self.on_postprocess_text(event, config, event_data)

    # 文本预处理事件
    def on_preproces_text(self, event: str, config: TranslatorConfig, event_data: list[dict]) -> None:
        pass

    # 文本后处理事件
    def on_postprocess_text(self, event: str, config: TranslatorConfig, event_data: list[dict]) -> None:
        pass
```


## 插件事件介绍
翻译任务执行过程中会触发以下事件，并提供相应的参数供其他插件或功能模块使用，下面事件触发顺序大致由上到下。


### 文本预过滤事件：text_filter

1. **触发位置**

    在读取原文文件后，在文本预处理事件前触发

2. **传入参数**

    | 参数名 | 类型 | 描述 |
    | ------ | ---- | ---- |
    | event_name | string | text_filter |
    | config | TranslatorConfig | 全局类，包含了在整个应用范围内共享的的配置信息 |
    | event_data | list | 全局缓存文本数据，格式与导出的缓存文件一致 |



### 文本预处理事件：preproces_text

1. **触发位置**

    在文本预过滤事件后，开始请求前触发。

2. **传入参数**

    | 参数名 | 类型 | 描述 |
    | ------ | ---- | ---- |
    | event_name | string | preproces_text |
    | config | TranslatorConfig | 全局类，包含了在整个应用范围内共享的的配置信息 |
    | event_data | list | 全局缓存文本数据，格式与导出的缓存文件一致 |


    - `event_data`: 全局缓存文本数据，格式与导出的缓存文件一致。主要有三层结构project，files，items，每个层有固定属性和拓展属性，更详细具体可查看\ModuleFolders\Cache内的缓存结构代码

    ```python

    {
        "project_id": "aaa",                          #项目ID
        "project_type": "Type",                       #项目类型
        "files": {
            "path/to/file1.txt": {                    # 文件路径
                "storage_path": "...",                # 相对路径
                "file_project_type": "...",           # 文件类型
                "file_name": "...",                   # 原始文件名
                "items": {                            # 该文件内的所有文本条目
                    1: {"text_index": 1, "source_text": "...", ...},  # 文本索引号，原文文本，译文文本，翻译模型
                    2: {"text_index": 2, "source_text": "...", ...},  # 翻译状态，枚举值：0 - 待翻译，1 - 已翻译，2 - 翻译中，7 - 已排除
                }                                                     
            },
            "path/to/file2.txt": { ... }
        }
    }
    ```


### 发送前文本规范事件：normalize_text

1. **触发位置**

    每次获取到待翻译文本，发送请求前触发。

2. **传入参数**

    | 参数名 | 类型 | 描述 |
    | ------ | ---- | ---- |
    | event_name | string | normalize_text |
    | config | TranslatorConfig | 全局类，包含了在整个应用范围内共享的的配置信息 |
    | event_data | dict | 本次任务的待翻译的原文文本 |


    因为没有返回参数，需要直接处理输入的参数event_data


    - `event_data`: 本次任务的待翻译的原文文本，json格式，key值是从0开始的数字序号
    ```json
    {
        "0": "弾：ゾンビ攻撃",
        "1": "敵：タイムボム",
        "2": "敵：スコーピオン",
        "3": "敵：プチデビル：リ",
        "4": "プチデビルのリスポーン用です。"
    }
    ```

### 文本后处理事件：postprocess_text

1. **触发位置**

    翻译完成，翻译文件输出前。

2. **传入参数**

    | 参数名 | 类型 | 描述 |
    | ------ | ---- | ---- |
    | event_name | string | postprocess_text |
    | config | TranslatorConfig | 全局类，包含了在整个应用范围内共享的的配置信息 |
    | event_data | list | 全局缓存文本数据，格式与导出的缓存文件一致 |


### 手动导出事件：manual_export

1. **触发位置**

    用户使用“手动导出翻译文件功能”，在翻译文件导出前触发。

2. **传入参数**

    | 参数名 | 类型 | 描述 |
    | ------ | ---- | ---- |
    | event_name | string | manual_export |
    | config | TranslatorConfig | 全局类，包含了在整个应用范围内共享的的配置信息 |
    | event_data | list | 全局缓存文本数据，格式与导出的缓存文件一致 |


### 翻译完成事件：translation_completed

1. **触发位置**

    翻译完成，写出翻译文件后，任务即将退出前。

2. **传入参数**

    | 参数名 | 类型 | 描述 |
    | ------ | ---- | ---- |
    | event_name | string | translation_completed |
    | config | TranslatorConfig | 全局类，包含了在整个应用范围内共享的的配置信息 |
    | event_data | list | 全局缓存文本数据，格式与导出的缓存文件一致 |

## 贡献指南
1. Fork本项目
2. 创建您的特性分支 (`git checkout -b my-new-feature`)
3. 提交您的改动 (`git commit -am 'Add some feature'`)
4. 将您的分支推送到 GitHub (`git push origin my-new-feature`)
5. 创建新的Pull Request



================================================
FILE: PluginScripts/PluginBase.py
================================================
from ModuleFolders.Cache.CacheProject import CacheProject
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig


class Priority():

    HIGHEST    = 700
    HIGHER     = 600
    HIGH       = 500
    NORMAL     = 400
    LOW        = 300
    LOWER      = 200
    LOWEST     = 100

class PluginBase:

    # 优先级列表
    PRIORITY = Priority()

    def __init__(self) -> None:
        self.name = "Unnamed Plugin"
        self.description = "No description provided."

        self.visibility = True      # 是否在插件设置中显示
        self.default_enable = True  # 默认启用状态

        self.events = []            # 插件感兴趣的事件列表，使用字典存储事件名和优先级

    # 加载插件时调用
    def load(self) -> None:
        pass

    # 处理事件
    def on_event(self, event: str, config: TaskConfig, event_data: CacheProject | dict) -> None:
        pass

    # 添加事件
    def add_event(self, event: str, priority: int) -> None:
        self.events.append(
            {
                "event": event,
                "priority": priority,
            }
        )


================================================
FILE: PluginScripts/BilingualPlugin/BilingualPlugin.py
================================================
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheProject import CacheProject
from PluginScripts.PluginBase import PluginBase


class BilingualPlugin(PluginBase):
    def __init__(self):
        super().__init__()
        self.name = "BilingualPlugin"
        self.description = "双语对照插件"+ "\n"+ "最后输出的翻译内容会是【译文+换行符+原文】的双语组合，请谨慎开启。\nPDF、SRT、EPUB和TXT文件会默认输出译文与双语版本，请不要开启该插件" 

        self.visibility = True  # 是否在插件设置中显示
        self.default_enable = False  # 默认启用状态

        self.add_event("postprocess_text", PluginBase.PRIORITY.LOWEST)  # 添加感兴趣的事件和优先级
        self.add_event("manual_export", PluginBase.PRIORITY.LOWEST)

    def load(self):
        pass

    def on_event(self, event_name, config, event_data: CacheProject):
        if event_name in ("manual_export", "postprocess_text"):
            self.process_dictionary_list(event_data)

    def process_dictionary_list(self, event_data: CacheProject):
        for entry in event_data.items_iter():

            source_text = entry.source_text
            translated_text = entry.translated_text
            translation_status = entry.translation_status

            if translation_status == TranslationStatus.TRANSLATED:
                entry.translated_text = translated_text + "\n" + source_text



================================================
FILE: PluginScripts/GeneralTextFilter/GeneralTextFilter.py
================================================
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheProject import CacheProject
from PluginScripts.PluginBase import PluginBase


class GeneralTextFilter(PluginBase):
    def __init__(self):
        super().__init__()
        self.name = "GeneralTextFilter"
        self.description = "GeneralTextFilter"

        self.visibility = False # 是否在插件设置中显示
        self.default_enable = True # 默认启用状态

        self.add_event('text_filter', PluginBase.PRIORITY.HIGH)

    def load(self):
        pass


    def on_event(self, event_name, config, event_data: CacheProject):

        # 文本预处理事件触发
        if event_name == "text_filter":

            self.filter_text(event_data)

    # 忽视空值内容和将整数型，浮点型数字变换为字符型数字函数，且改变翻译状态为7,因为T++读取到整数型数字时，会报错，明明是自己导出来的...
    def filter_text(self, event_data: CacheProject):
        for entry in event_data.items_iter():

            source_text = entry.source_text

            # 检查文本是否为数值变量
            if isinstance(source_text, (int, float)):
                entry.source_text = str(source_text)
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

            # 检查文本是否为字符型数字
            if (isinstance(source_text, str) and source_text.isdigit()):
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

            # 检查文本是否为空
            if source_text is None or source_text.strip() == "":
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

            # 检查文本是仅换行符
            if source_text.strip() in ("\n", "\\n", "\r", "\\r"):
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

            # 检查是否仅含标点符号的文本组合
            if isinstance(source_text, str) and self.is_punctuation_string(source_text):
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

            #加个检测后缀为MP3，wav，png，这些文件名的文本，都是纯代码文本，所以忽略掉
            if isinstance(source_text, str) and self._get_file_suffix(source_text.rstrip()) in self.EXCLUDE_FILE_SUFFIX:
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

            # 检查开头的
            if isinstance(source_text, str) and any(source_text.startswith(ext) for ext in self.EXCLUDE_PREFIX):
                entry.translation_status = TranslationStatus.EXCLUDED
                continue

    # 检查字符串是否只包含常见的标点符号
    def is_punctuation_string(self,s: str) -> bool:
        """检查字符串是否只是标点符号与双种空格组合"""
        punctuation = set(" " " " "!" '"' "#" "$" "%" "&" "'" "(" ")" "*" "+" "," "-" "." "/" "，" "。"
                        ":" ";" "<" "=" ">" "?" "@" "[" "\\" "]" "^" "_" "`" "{" "|" "}" "~" "—" "・" "？" "↑" "←" "↓" "→" "「" "」" "『" "』" "【" "】" "《" "》"
                        "！" "＂" "＃" "＄" "％" "＆" "＇" "（" "）" "＊" "＋" "，" "－" "．" "／" "：" "；" "＜" "＝" "＞" "？" "＠" )
        return all(char in punctuation for char in s)

    def _get_file_suffix(self, text: str):
        split = text.rsplit(".", 1)
        return f".{split[1]}" if len(split) == 2 else split[0]

    EXCLUDE_PREFIX = ('MapData/', 'SE/', 'BGS', '0=', 'BGM/', 'FIcon/', '<input type=', 'width:', '<div ', 'EV0', '\\img')

    EXCLUDE_FILE_SUFFIX = frozenset([
        '.mp3', '.wav', '.png', '.jpg', '.gif', '.rar', '.zip', '.json', '.ogg', '.txt', '.mps', '.woff',
        '.txt', '.wav', '.webp', '.jpg)', '.txt', '.doc', '.html', '.bmp', '.pic', '.aac', '.flac', '.avi',
        '.py', '.c', '.cpp', '.js', '.java', '.css', '.xml', '.flac', '.jpeg', '.mov', '.mkv', '.flv',
    ])



================================================
FILE: PluginScripts/IncrementalFilePlugin/IncrementalFilePlugin.py
================================================
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheManager import CacheManager
from ModuleFolders.Cache.CacheProject import CacheProject
from PluginScripts.PluginBase import PluginBase


class IncrementalFilePlugin(PluginBase):
    def __init__(self):
        super().__init__()
        self.name = "IncrementalFilePlugin"
        self.description = (
            "增量文件插件，当文件夹下新增或修改文件后，只翻译新增或修改的文件。\n"
            "注意！翻译完成后存量文件也会重新输出！"
        )

        self.visibility = True  # 是否在插件设置中显示
        self.default_enable = False  # 默认不启用

        # 为保证增量文本读取在其他插件之前，用最高优先级
        self.add_event("text_filter", PluginBase.PRIORITY.HIGHEST)

    def on_event(self, event_name, config, event_data: CacheProject):
        if event_name == "text_filter":
            self.read_incremental_files(config, event_data)

    def read_incremental_files(self, config, event_data: CacheProject):

        cache_manager = CacheManager()
        cache_manager.load_from_file(config.label_output_path)
        if not hasattr(cache_manager, "project"):
            return
        cache_files = cache_manager.project.files

        for file in event_data.files.values():
            if file.storage_path in cache_files:
                cache_line_set = set(x.source_text for x in cache_files[file.storage_path].items)
                cache_items = iter(cache_files[file.storage_path].items)  # 用迭代器代替下标

                for line in file.items:
                    # 防止中间插入的行遍历完迭代器
                    if line.source_text not in cache_line_set:
                        continue
                    for cache_line in cache_items:
                        # 在缓存中找到当前的片段
                        if cache_line.source_text == line.source_text:
                            # 更新已翻译的片段
                            if cache_line.translation_status == TranslationStatus.TRANSLATED and line.translation_status == TranslationStatus.UNTRANSLATED:
                                line.translation_status = cache_line.translation_status
                                line.model = cache_line.model
                                line.translated_text = cache_line.translated_text
                            break



================================================
FILE: PluginScripts/IOPlugins/CustomRegistry.py
================================================
from typing import TYPE_CHECKING, Any, Self

from ModuleFolders.FileOutputer.BaseWriter import BaseTranslationWriter
from ModuleFolders.FileReader.BaseReader import BaseSourceReader

if TYPE_CHECKING:
    from ModuleFolders.FileOutputer.FileOutputer import FileOutputer
    from ModuleFolders.FileReader.FileReader import FileReader


class CustomWriter(BaseTranslationWriter):
    """插件式Writer，继承后可自动注册"""
    _writers: list[Self] = []

    def __init_subclass__(cls, **kwargs) -> None:
        super().__init_subclass__(**kwargs)
        # import 发生在 PluginManager 中
        CustomWriter._writers.append(cls)

    @classmethod
    def register_writers(cls, register: "FileOutputer"):
        for writer in CustomWriter._writers:
            register.register_writer(writer, **writer.get_default_init_args())

    @classmethod
    def get_default_init_args(cls) -> dict[str, Any]:
        return {}


class CustomReader(BaseSourceReader):
    """插件式Reader，继承后可自动注册"""
    _readers: list[Self] = []

    def __init_subclass__(cls, **kwargs) -> None:
        super().__init_subclass__(**kwargs)
        # import 发生在 PluginManager 中
        CustomReader._readers.append(cls)

    @classmethod
    def register_readers(cls, register: "FileReader"):
        for reader in CustomReader._readers:
            register.register_reader(reader, **reader.get_default_init_args())

    @classmethod
    def get_default_init_args(cls) -> dict[str, Any]:
        return {}



================================================
FILE: PluginScripts/LanguageFilter/LanguageFilter.py
================================================
from tqdm import tqdm
from rich import print

from ModuleFolders.Cache.CacheProject import CacheProject
from ModuleFolders.TaskExecutor import TranslatorUtil
from PluginScripts.PluginBase import PluginBase
from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig


class LanguageFilter(PluginBase):
    # 平假名
    HIRAGANA = ("\u3040", "\u309F")

    # 片假名
    KATAKANA = ("\u30A0", "\u30FF")

    # 半角片假名（包括半角浊音、半角拗音等）
    KATAKANA_HALF_WIDTH = ("\uFF65", "\uFF9F")

    # 片假名语音扩展
    KATAKANA_PHONETIC_EXTENSIONS = ("\u31F0", "\u31FF")

    # 濁音和半浊音符号
    VOICED_SOUND_MARKS = ("\u309B", "\u309C")

    # 韩文字母 (Hangul Jamo)
    HANGUL_JAMO = ("\u1100", "\u11FF")

    # 韩文字母扩展-A (Hangul Jamo Extended-A)
    HANGUL_JAMO_EXTENDED_A = ("\uA960", "\uA97F")

    # 韩文字母扩展-B (Hangul Jamo Extended-B)
    HANGUL_JAMO_EXTENDED_B = ("\uD7B0", "\uD7FF")

    # 韩文音节块 (Hangul Syllables)
    HANGUL_SYLLABLES = ("\uAC00", "\uD7AF")

    # 韩文兼容字母 (Hangul Compatibility Jamo)
    HANGUL_COMPATIBILITY_JAMO = ("\u3130", "\u318F")

    # 中日韩统一表意文字
    CJK = ("\u4E00", "\u9FFF")

    # 中日韩通用标点符号
    GENERAL_PUNCTUATION = ("\u2000", "\u206F")
    CJK_SYMBOLS_AND_PUNCTUATION = ("\u3000", "\u303F")
    HALFWIDTH_AND_FULLWIDTH_FORMS = ("\uFF00", "\uFFEF")
    OTHER_CJK_PUNCTUATION = (
        "\u30FB"  # ・ 在片假名 ["\u30A0", "\u30FF"] 范围内
    )

    # 拉丁字符
    LATIN_1 = ("\u0041", "\u005A")  # 大写字母 A-Z
    LATIN_2 = ("\u0061", "\u007A")  # 小写字母 a-z
    LATIN_EXTENDED_A = ("\u0100", "\u017F")
    LATIN_EXTENDED_B = ("\u0180", "\u024F")
    LATIN_SUPPLEMENTAL = ("\u00A0", "\u00FF")

    # 拉丁标点符号
    LATIN_PUNCTUATION_BASIC_1 = ("\u0020", "\u002F")
    LATIN_PUNCTUATION_BASIC_2 = ("\u003A", "\u0040")
    LATIN_PUNCTUATION_BASIC_3 = ("\u005B", "\u0060")
    LATIN_PUNCTUATION_BASIC_4 = ("\u007B", "\u007E")
    LATIN_PUNCTUATION_GENERAL = ("\u2000", "\u206F")
    LATIN_PUNCTUATION_SUPPLEMENTAL = ("\u2E00", "\u2E7F")

    # 俄文字符
    CYRILLIC_BASIC = ("\u0410", "\u044F")  # 基本俄文字母 (大写字母 А-Я, 小写字母 а-я)
    CYRILLIC_SUPPLEMENT = ("\u0500", "\u052F")  # 俄文字符扩展区（补充字符，包括一些历史字母和其他斯拉夫语言字符）
    CYRILLIC_EXTENDED_A = ("\u2C00", "\u2C5F")  # 扩展字符 A 区块（历史字母和一些东斯拉夫语言字符）
    CYRILLIC_EXTENDED_B = ("\u0300", "\u04FF")  # 扩展字符 B 区块（更多历史字母）
    CYRILLIC_SUPPLEMENTAL = ("\u1C80", "\u1C8F")  # 俄文字符补充字符集，包括一些少见和历史字符
    CYRILLIC_SUPPLEMENTAL_EXTRA = ("\u2DE0", "\u2DFF")  # 其他扩展字符（例如：斯拉夫语言的一些符号）
    CYRILLIC_OTHER = ("\u0500", "\u050F")  # 其他字符区块（包括斯拉夫语系其他语言的字符，甚至一些特殊符号）

    def __init__(self) -> None:
        super().__init__()

        self.name = "LanguageFilter"
        self.description = (
                "语言过滤器，在翻译开始前，根据原文语言对文本中的无效条目进行过滤以节约 翻译时间 与 Token 消耗"
                + "\n"
                + "兼容性：支持全部语言；支持全部模型；支持全部文本格式；支持翻译润色流程；"
        )

        self.visibility = True  # 是否在插件设置中显示
        self.default_enable = True  # 默认启用状态

        self.add_event("text_filter", PluginBase.PRIORITY.NORMAL)

    def on_event(self, event: str, config: TaskConfig, data: CacheProject) -> None:

        if event == "text_filter":
            self.on_text_filter(event, config, data)

    # 文本后处理事件
    def on_text_filter(self, event: str, config: TaskConfig, data: CacheProject) -> None:
        print("")
        print("[LanguageFilter] 开始执行预处理 ...")

        target = []  # 存储需要排除的条目

        # 自动检测语言模式
        if config.source_language == "auto":
            print("[LanguageFilter] 使用自动检测语言模式...")

            # 计算项目中出现次数最多的语言
            most_common_language = TranslatorUtil.get_most_common_language(data)
            # 获取可读更强的名称
            en_source_lang, source_language, _, _ = TranslatorUtil.get_language_display_names(most_common_language, 'chinese_simplified')
            print(f"[LanguageFilter] 项目主要使用语言: {most_common_language} - {en_source_lang}/{source_language}")

            # 处理每个文件中的条目
            for path, file in data.files.items():
                # 获取语言信息
                language_stats = file.language_stats
                # 原文片段列表
                file_items = file.items

                # 确定使用的语言
                if not language_stats:
                    print(
                        f"[[red]WARNING[/]] [LanguageFilter] 文件 {path} 没有检测到语言信息，使用项目主要语言 {most_common_language}"
                    )
                    first_language = most_common_language
                else:
                    first_language = language_stats[0][0]
                    if first_language != 'un':
                        print(
                            f"[[green]INFO[/]] [LanguageFilter] 文件 {path} 主要语言为 {first_language}"
                        )

                # 根据不同情况分别处理
                if TranslatorUtil.map_language_code_to_name(first_language) == config.target_language:
                    target.extend(self._filter_target_language_match(path, file_items, first_language))
                elif first_language == 'un':
                    target.extend(self._filter_unknown_language(path, file_items))
                else:
                    target.extend(self._filter_normal_language(file, file_items, first_language))

        # 指定原文语言模式
        else:
            print("[LanguageFilter] 使用指定语言模式...")
            print(f"[LanguageFilter] 项目主要使用语言: {config.source_language}")
            for path, file in data.files.items():
                # 原文片段列表
                file_items = file.items

                # 原有的非自动检测模式，优化为使用统一的函数
                #target.extend(self._filter_normal_language(file, data.items_iter(), config.source_language)) # 性能更好
                target.extend(self._filter_normal_language(file, file_items, config.source_language))

        print("")
        for item in tqdm(target):
            item.translation_status = TranslationStatus.EXCLUDED

        # 输出结果
        print(f"[LanguageFilter] 语言过滤已完成，共过滤 {len(target)} 个不包含目标语言的条目 ...")
        print("")

    # 判断字符是否为汉字（中文）字符
    def is_cjk(self, char: str) -> bool:
        return LanguageFilter.CJK[0] <= char <= LanguageFilter.CJK[1]

    # 判断字符是否为拉丁字符
    def is_latin(self, char: str) -> bool:
        return (
                LanguageFilter.LATIN_1[0] <= char <= LanguageFilter.LATIN_1[1]
                or LanguageFilter.LATIN_2[0] <= char <= LanguageFilter.LATIN_2[1]
                or LanguageFilter.LATIN_EXTENDED_A[0] <= char <= LanguageFilter.LATIN_EXTENDED_A[1]
                or LanguageFilter.LATIN_EXTENDED_B[0] <= char <= LanguageFilter.LATIN_EXTENDED_B[1]
                or LanguageFilter.LATIN_SUPPLEMENTAL[0] <= char <= LanguageFilter.LATIN_SUPPLEMENTAL[1]
        )

    # 判断字符是否为韩文（含汉字）字符
    def is_korean(self, char: str) -> bool:
        return (
                LanguageFilter.CJK[0] <= char <= LanguageFilter.CJK[1]
                or LanguageFilter.HANGUL_JAMO[0] <= char <= LanguageFilter.HANGUL_JAMO[1]
                or LanguageFilter.HANGUL_JAMO_EXTENDED_A[0] <= char <= LanguageFilter.HANGUL_JAMO_EXTENDED_A[1]
                or LanguageFilter.HANGUL_JAMO_EXTENDED_B[0] <= char <= LanguageFilter.HANGUL_JAMO_EXTENDED_B[1]
                or LanguageFilter.HANGUL_SYLLABLES[0] <= char <= LanguageFilter.HANGUL_SYLLABLES[1]
                or LanguageFilter.HANGUL_COMPATIBILITY_JAMO[0] <= char <= LanguageFilter.HANGUL_COMPATIBILITY_JAMO[1]
        )

    # 判断字符是否为俄文字符
    def is_russian(self, char: str) -> bool:
        return (
                LanguageFilter.CYRILLIC_BASIC[0] <= char <= LanguageFilter.CYRILLIC_BASIC[1]
                or LanguageFilter.CYRILLIC_SUPPLEMENT[0] <= char <= LanguageFilter.CYRILLIC_SUPPLEMENT[1]
                or LanguageFilter.CYRILLIC_EXTENDED_A[0] <= char <= LanguageFilter.CYRILLIC_EXTENDED_A[1]
                or LanguageFilter.CYRILLIC_EXTENDED_B[0] <= char <= LanguageFilter.CYRILLIC_EXTENDED_B[1]
                or LanguageFilter.CYRILLIC_SUPPLEMENTAL[0] <= char <= LanguageFilter.CYRILLIC_SUPPLEMENTAL[1]
                or LanguageFilter.CYRILLIC_SUPPLEMENTAL_EXTRA[0] <= char <= LanguageFilter.CYRILLIC_SUPPLEMENTAL_EXTRA[
                    1]
                or LanguageFilter.CYRILLIC_OTHER[0] <= char <= LanguageFilter.CYRILLIC_OTHER[1]
        )

    # 判断字符是否为日文（含汉字）字符
    def is_japanese(self, char: str) -> bool:
        return (
                LanguageFilter.CJK[0] <= char <= LanguageFilter.CJK[1]
                or LanguageFilter.KATAKANA[0] <= char <= LanguageFilter.KATAKANA[1]
                or LanguageFilter.HIRAGANA[0] <= char <= LanguageFilter.HIRAGANA[1]
                or LanguageFilter.KATAKANA_HALF_WIDTH[0] <= char <= LanguageFilter.KATAKANA_HALF_WIDTH[1]
                or LanguageFilter.KATAKANA_PHONETIC_EXTENSIONS[0] <= char <=
                LanguageFilter.KATAKANA_PHONETIC_EXTENSIONS[1]
                or LanguageFilter.VOICED_SOUND_MARKS[0] <= char <= LanguageFilter.VOICED_SOUND_MARKS[1]
        )

    # 检查字符串是否包含至少一个汉字（中文）字符
    def has_any_cjk(self, text: str) -> bool:
        return any(self.is_cjk(char) for char in text)

    # 检查字符串是否包含至少一个拉丁字符
    def has_any_latin(self, text: str) -> bool:
        return any(self.is_latin(char) for char in text)

    # 检查字符串是否包含至少一个韩文（含汉字）字符
    def has_any_korean(self, text: str) -> bool:
        return any(self.is_korean(char) for char in text)

    # 检查字符串是否包含至少一个俄文字符
    def has_any_russian(self, text: str) -> bool:
        return any(self.is_russian(char) for char in text)

    # 检查字符串是否包含至少一个日文（含汉字）字符
    def has_any_japanese(self, text: str) -> bool:
        return any(self.is_japanese(char) for char in text)

    def get_filter_function(self, language_code: str, path: str):
        """根据语言代码获取相应的语言过滤函数"""
        # 语言代码到过滤函数的映射
        code_to_function = {
            # 中文
            'zh': self.has_any_cjk,
            'zh-cn': self.has_any_cjk,
            'zh-tw': self.has_any_cjk,
            'yue': self.has_any_cjk,
            # 英语和拉丁语系
            'en': self.has_any_latin,
            'es': self.has_any_latin,
            'fr': self.has_any_latin,
            'de': self.has_any_latin,
            # 韩语
            'ko': self.has_any_korean,
            # 俄语
            'ru': self.has_any_russian,
            # 日语
            'ja': self.has_any_japanese
        }

        # 尝试直接匹配
        if language_code in code_to_function:
            return code_to_function[language_code]

        # 尝试匹配前两个字符
        if language_code and language_code[:2] in code_to_function:
            return code_to_function[language_code[:2]]

        # 未知语言默认使用拉丁文过滤函数
        print(f"[[red]WARNING[/]] [LanguageFilter] 文件 {path} 未知的语言代码 {language_code}，无法使用内置语言过滤函数")
        return None

    def _filter_target_language_match(self, path, file_items, language):
        """处理检测语言与目标语言相同的情况"""
        print(f"[LanguageFilter] 文件 {path} 检测到的主要语言 {language} 与译文语言相同，将只翻译不符合该语言特征的文本")

        has_any = self.get_filter_function(language, path)
        if has_any is not None:
            return [item for item in file_items
                    if item.translation_status == TranslationStatus.EXCLUDED or
                    not isinstance(item.source_text, str) or
                    not item.lang_code or
                    (has_any(item.source_text) and
                     item.lang_code[0] == language and
                     item.lang_code[1] > 0.92)]
        else:
            # 过滤原文检测语言与行语言相同的行
            return [item for item in file_items
                    if item.translation_status == TranslationStatus.EXCLUDED or
                    not isinstance(item.source_text, str) or
                    not item.lang_code or
                    (item.lang_code[0] == language and
                     item.lang_code[1] > 0.92)]

    def _filter_unknown_language(self, path, file_items):
        """处理未知语言的文件"""
        print(f"[LanguageFilter] 文件 {path} 未检测到具体语言，将只翻译置信度较高（大于0.82）的文本行")

        return [item for item in file_items
                if item.translation_status == TranslationStatus.EXCLUDED or
                not isinstance(item.source_text, str) or
                not item.lang_code or
                item.lang_code[1] < 0.82]

    def _filter_normal_language(self, file, file_items, language):
        """处理一般语言情况"""
        # 将Ainiee内置语言代码映射为ISO标准语言代码
        main_source_lang = TranslatorUtil.map_language_name_to_code(language)
        # 如果返回的代码是繁中，重新映射回zh代码
        if main_source_lang == 'zh-Hant':
            main_source_lang = 'zh'
        # 获取语言处理函数
        has_any = self.get_filter_function(main_source_lang, file.file_name)

        # 获取当前文件的低置信度语言统计
        lc_languages = set()
        if file.lc_language_stats:
            lc_languages = {lang for lang, _, _ in file.lc_language_stats}

        filtered_items = []
        for item in file_items:
            # 如果item已经被标记为排除，直接添加
            if item.translation_status == TranslationStatus.EXCLUDED:
                filtered_items.append(item)
                continue

            if not isinstance(item.source_text, str):
                filtered_items.append(item)
                continue

            lang_info = item.get_lang_code(default_lang=main_source_lang)
            detected_lang, confidence = lang_info[0], lang_info[1]
            other_langs = lang_info[2] if len(lang_info) > 2 else []

            # 判断是否不需要过滤:
            # 1. 检测语言与主要源语言不同
            # 2. 检测语言出现在低置信度语言统计中
            # 3. 其他语言列表中包含主要源语言
            not_filter_for_lc = (
                    detected_lang != main_source_lang and
                    detected_lang in lc_languages and
                    main_source_lang in other_langs
            )

            if not_filter_for_lc:
                continue

            # 原有的过滤逻辑
            if has_any is not None:
                if not has_any(item.source_text) or (detected_lang != main_source_lang and confidence > 0.92):
                    filtered_items.append(item)
            else:
                if detected_lang != main_source_lang and confidence > 0.92:
                    filtered_items.append(item)

        return filtered_items



================================================
FILE: PluginScripts/MToolOptimizer/MToolOptimizer.py
================================================
from collections import defaultdict
import unicodedata
from itertools import zip_longest

from tqdm import tqdm
from rich import print

from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.Cache.CacheProject import CacheProject, ProjectType
from PluginScripts.PluginBase import PluginBase
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig

class MToolOptimizer(PluginBase):

    def __init__(self) -> None:
        super().__init__()

        self.name = "MToolOptimizer"
        self.description = (
            "MTool 优化器，优化翻译流程，提升翻译质量，至多可减少 40% 的 翻译时间 与 Token 消耗"
            + "\n" + "但可能会带来稳定性下降，翻译错行，翻译不通畅等问题，请酌情开启"
            + "\n" + "兼容性：支持全部语言；支持全部模型；仅支持 MTool 文本；仅支持翻译流程；"
        )

        self.visibility = True          # 是否在插件设置中显示
        self.default_enable = False     # 默认启用状态

        self.add_event("manual_export", PluginBase.PRIORITY.NORMAL)
        self.add_event("preproces_text", PluginBase.PRIORITY.NORMAL)
        self.add_event("postprocess_text", PluginBase.PRIORITY.NORMAL)

    def on_event(self, event: str, config: TaskConfig, data: CacheProject) -> None:

        # 限制文本格式
        if ProjectType.MTOOL not in data.file_project_types:
            return

        if event == "preproces_text":
            # 检查数据是否已经被插件处理过
            if data.get_extra("mtool_optimizer_processed", False):
                return
            mtool_items = list(data.items_iter(ProjectType.MTOOL))
            self.on_preproces_text(event, config, mtool_items)
            data.set_extra("mtool_optimizer_processed", True)

        if event in ("manual_export", "postprocess_text"):
            # 检查数据是否已经被插件处理过
            if not data.get_extra("mtool_optimizer_processed", False):
                return
            mtool_items = list(data.items_iter(ProjectType.MTOOL))
            self.on_postprocess_text(event, config, mtool_items)

    # 文本预处理事件
    def on_preproces_text(self, event: str, config: TaskConfig, items: list[CacheItem]) -> None:

        # 检查需要移除的条目
        # 将包含换行符的长句拆分，然后查找与这些拆分后得到的短句相同的句子并移除它们
        print("")
        print("[MToolOptimizer] 开始执行预处理 ...")
        print("")

        # 记录处理前的条目数量
        orginal_length = len([v for v in items if v.translation_status == TranslationStatus.EXCLUDED])

        # 找到重复短句条目
        texts_to_delete = set()
        for v in tqdm(items):

            # 找到需要移除的重复条目
            if v.source_text.find("\n") >= 0:
                texts_to_delete.update(
                    v.strip() for v in v.source_text.splitlines() if v.strip() != ""
                )

        # 移除重复短句条目
        for v in tqdm(items):
            if v.source_text.strip() in texts_to_delete:
                v.translation_status = TranslationStatus.EXCLUDED

        print("")
        print(f"[MToolOptimizer] 预处理执行成功，已移除 {len([v for v in items if v.translation_status == TranslationStatus.EXCLUDED]) - orginal_length} 个重复的条目 ...")
        print("")

    # 文本后处理事件
    def on_postprocess_text(self, event: str, config: TaskConfig, items: list[CacheItem]) -> None:

        print("")
        print("[MToolOptimizer] 开始执行后处理 ...")
        print("")

        # 记录实际处理的条目
        seen = set()

        # 找到短句，并按原文分组
        source_text_mapping = defaultdict[str, list[CacheItem]](list)
        for item in items:
            if item.source_text.find("\n") == -1:
                source_text_mapping[item.source_text.strip()].append(item)

        # 尝试将包含换行符的长句还原回短句
        for v in tqdm(items):

            # 获取原文和译文按行切分，并移除空条目以避免连续换行带来的影响
            source_text = v.source_text.strip()
            translated_text = v.translated_text.strip()
            lines_source = [v.strip() for v in source_text.splitlines() if v.strip() != ""]
            lines_translated = [v.strip() for v in translated_text.splitlines() if v.strip() != ""]

            # 跳过原文只有一行的条目
            if len(lines_source) <= 1:
                continue

            # 统计原文和译文的最大单行显示长度
            max_length_source = max(self.get_display_length(v) for v in lines_source) if len(lines_source) > 0 else 0
            max_length_translated = max(self.get_display_length(v) for v in lines_translated) if len(lines_translated) > 0 else 0

            # 第一种情况：原文和译文行数相等
            if len(lines_source) == len(lines_translated):
                self.update_data(lines_source, lines_translated, seen, source_text_mapping)
            # 第二种情况：原文行数大于译文行数，且原文最大显示长度不少于译文最大显示长度
            elif len(lines_source) > len(lines_translated) and max_length_source >= max_length_translated:
                self.update_data(lines_source, lines_translated, seen, source_text_mapping)
            # 兜底的情况
            else:
                # 切分前，先将译文中的换行符移除，避免重复换行，切分长度为子句最大长度 - 2
                lines_translated = self.split_string_by_display_length(
                    translated_text.replace("\r", "").replace("\n", ""),
                    max(20, max_length_source - 2)
                )

                self.update_data(lines_source, lines_translated, seen, source_text_mapping)

        print("")
        print(f"[MToolOptimizer] 后处理执行成功，已还原 {len(seen)} 个条目 ...")
        print("")

    # 更新数据
    def update_data(self, lines_s: list[str], lines_t: list[str], seen: set, source_text_mapping: defaultdict[str, list[CacheItem]]):
        # 按照数据对处理译文，长度不足时，则补齐长度
        for source, translated in zip_longest(lines_s, lines_t, fillvalue = ""):
            # 跳过重复的条目
            if source.strip() in seen:
                continue
            else:
                seen.add(source.strip())

            # 更新短句的译文
            for item in source_text_mapping.get(source.strip(), ()):
                item.translated_text = translated.strip() if translated.strip() != "" else "　"
                item.translation_status = TranslationStatus.TRANSLATED

    # 按显示长度切割字符串
    def split_string_by_display_length(self, string: str, display_length: int) -> list[str]:
        result = []
        current_length = 0
        current_chunk = []

        for char in string:
            char_length = self.get_display_length(char)
            if current_length + char_length > display_length:
                result.append(''.join(current_chunk))
                current_chunk = []
                current_length = 0

            current_chunk.append(char)
            current_length += char_length

        if current_chunk:
            result.append(''.join(current_chunk))

        return result

    # 计算字符串的显示长度
    def get_display_length(self, text: str) -> int:
        # unicodedata.east_asian_width(c) 返回字符 c 的东亚洲宽度属性。
        # NaH 表示窄（Narrow）、中立（Neutral）和半宽（Halfwidth）字符，这些字符通常被认为是半角字符。
        # 其他字符（如全宽字符）的宽度属性为 W 或 F，这些字符被认为是全角字符。
        return sum(1 if unicodedata.east_asian_width(c) in "NaH" else 2 for c in text)


================================================
FILE: PluginScripts/SpecialTextFilter/SpecialTextFilter.py
================================================
import re
from typing import Iterator

from ModuleFolders.Cache.CacheItem import CacheItem, TranslationStatus
from ModuleFolders.Cache.CacheProject import CacheProject, ProjectType
from ..PluginBase import PluginBase

class SpecialTextFilter(PluginBase):
    def __init__(self):
        super().__init__()
        self.name = "SpecialTextFilter"
        self.description = "SpecialTextFilter"

        self.visibility = False # 是否在插件设置中显示
        self.default_enable = True # 默认启用状态

        self.add_event('text_filter', PluginBase.PRIORITY.NORMAL)

    def load(self):
        pass


    def on_event(self, event_name, config, event_data: CacheProject):

        # 文本预处理事件触发
        if event_name == "text_filter":

            MD_EXCLUDE_REGEXS = (
                # 1.  ![...](http://...) and ![...](data:image...)
                re.compile(r"^\s*!\[[^\]]*\]\([^)]*\)\s*$"),
                # 2.  ![alt][id]
                re.compile(r"^\s*!\[[^\]]*\]\[[^\]]+\]\s*$"),
                # 3.  [id]: url "title" or [id]: <url> "title"
                re.compile(r"^\s*\[[^\]]+\]:\s*<?.*>?\s*(?:(?:\".*\")|(?:'.*'))?\s*$"),
            )

            # 针对MD项目的处理
            if ProjectType.MD in event_data.file_project_types:

                SpecialTextFilter.filter_md_text(self, event_data.items_iter(ProjectType.MD),MD_EXCLUDE_REGEXS)


    # 特殊文本过滤器——md项目
    def filter_md_text(self, cache_list: Iterator[CacheItem],MD_EXCLUDE_REGEXS):

        for entry in cache_list:
            source_text = entry.source_text

            if any(regex.match(source_text) for regex in MD_EXCLUDE_REGEXS):
                entry.translation_status = TranslationStatus.EXCLUDED



================================================
FILE: PluginScripts/TextLayoutRepairPlugin/TextLayoutRepairPlugin.py
================================================
import re

from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheProject import CacheProject

from ..PluginBase import PluginBase


class TextLayoutRepairPlugin(PluginBase):
    def __init__(self):
        super().__init__()
        self.name = "TextLayoutRepairPlugin"
        self.description = ("文本排版修复插件"
                            + "\n"
                            + "根据原文恢复译文中改变的标点符号和排版格式"
                            + "\n"
                            + "只适合日语;仅支持翻译流程"
                            )

        self.visibility = True  # 是否在插件设置中显示
        self.default_enable = False  # 默认启用状态

        self.add_event("postprocess_text", PluginBase.PRIORITY.LOWEST)  # 添加感兴趣的事件和优先级
        self.add_event("manual_export", PluginBase.PRIORITY.LOWEST)

    def load(self):
        pass

    def on_event(self, event_name, config, event_data: CacheProject):
        if event_name in ("manual_export", "postprocess_text"):
            self.process_dictionary_list(event_data)

    def process_dictionary_list(self, cache_list: CacheProject):
        for entry in cache_list.items_iter():

            source_text = entry.source_text
            translated_text = entry.translated_text
            translation_status = entry.translation_status

            if translation_status == TranslationStatus.TRANSLATED:
                entry.translated_text = self.fix_typography(source_text, translated_text)



    def fix_typography(self, original_text: str, translated_text: str) -> str:
        """
        修复译文的排版，分阶段处理首尾和内部标点。

        Args:
            original_text: 原始文本字符串。
            translated_text: 需要修复排版的译文文本字符串。

        Returns:
            修复排版后的译文文本字符串。
        """
        if not isinstance(original_text, str) or not isinstance(translated_text, str):
            return translated_text

        # --- 阶段 0: 处理前后缀空白 ---
        leading_whitespace_match = re.match(r"^(\s*)", original_text)
        trailing_whitespace_match = re.search(r"(\s*)$", original_text)
        leading_whitespace = leading_whitespace_match.group(1) if leading_whitespace_match else ""
        trailing_whitespace = trailing_whitespace_match.group(1) if trailing_whitespace_match else ""

        # 处理原文与译文的首尾空白
        original_stripped = original_text.strip()
        translated_stripped = translated_text.strip()

        # 如果原文或译文为空，则直接返回译文
        if not original_stripped or not translated_stripped:
            return translated_text

        # 平常内容是:说话文本
        # 或者是:说话文本+其他文本
        # 或者是:其他文本+说话文本       
        # 但有些内容是:说话文本+说话文本+说话文本
        # 也有些内容是:说话文本+其他文本+说话文本
        # 也有些内容是:其他文本+说话文本+其他文本
        # 例如：
        # "source_text": '「文句を言う前に、俺に謝るのが筋じゃないか」と少年は砂を払いながら、掠れて大人びた声でいきなり言った。「人様の楽しみを無茶苦茶にしておいて、貴方は謝罪もできないのか」',
        # "translated_text": '"在抱怨之前，先向我道歉才是道理吧"少年一边拍打身上的沙子，突然用沙哑而老成的语气说道。"把别人的快乐搅得一团糟，你连道歉都不会吗"',

        #"source_text": "「息子さんが結婚したの。それはおめでとうございます」乾杯。「めでたいものか、ちくしょう」「まあまあ」乾杯。「俺が育てたのに自分で勝手に育ったようなツラをする」「親はなくても子は育つ」「俺は居ても居なくても一緒かい」「そんなわけないでしょう社長さん」乾杯。",
        #"translated_text": '"儿子结婚了啊。那可要恭喜""干杯。""有什么好恭喜的，混蛋""好啦好啦"干杯。"明明是我养大的，却摆出一副自己长大的嘴脸""没有父母孩子照样能长大""我在不在都一样是吧""怎么会呢社长"干杯。',

        #"source_text": "「東堂さん」と私は叫び、続いて「お父さん」と呟いたのは新婦でした。",
        #"translated_text": '"东堂先生"我喊道，接着轻声说出"爸爸"的是新娘。',

        #"source_text": "その日は銀閣寺交番の前で待ち合わせをしました。哲学の道沿いの桜並木もすっかり冬の風に葉を散らしてしまって、あの砂糖菓子のような満開の桜を想像することもできない淋しい風景です。ぴうぴう吹く風に私の髪も散ってしまいそう。寒い寒いようと思いながら大文字山を見上げ、「北風小僧の寒太郎」を口ずさんでいると、やがて紀子さんと元パンツ総番長が二人でやって来ました。彼らはお見舞いの品をたくさん持っています。「やあ、その後いかがですか」と、元パンツ総番長が晴れ晴れとした顔で言いました。彼は宿願であった紀子さんとの再会を果たし、パンツを決して穿き替えないという荒行から足を洗った身、下半身の病気ともサヨナラして、ずいぶんと御機嫌でした。まことに喜ばしいことです。",
        #"translated_text": '那天我们在银阁寺派出所前碰头。哲学之道两旁的樱花树早已被冬风吹落叶子，完全想象不出那些像糖果般盛开的樱花，只剩一片萧瑟景象。寒风呼啸，我的头发都快被吹散了。我一边想着"好冷好冷"，一边仰望着大文字山，哼着《北风小子寒太郎》的调子，不久纪子小姐和前内裤总长就一起来了。他们带了很多慰问品。"哟，最近怎么样啊？"前内裤总长神清气爽地说道。他实现了与纪子小姐重逢的心愿，也告别了"绝不换内裤"的苦行，连下半身的疾病都痊愈了，显得特别高兴。真是可喜可贺。',

        #"source_text": "“하악…! 허윽, 하악!”",
        #"translated_text": '"哈啊…! 呃啊，哈啊!"',


        # --- 阶段 1: 处理仅首尾有符号的说话文本 --
        # 成对型标点检查映射
        # 格式: (原文开始符, 原文结束符, [译文可能替代开始符], [译文可能替代结束符])
        boundary_punctuation_pairs = [
            ('「', '」', ['“', '‘', '"'], ['”', '’', '"']),
            ('『', '』', ['“', '‘', '"'], ['”', '’', '"']),
            ('“', '”', ['‘','「', '"'], ['’','」', '"']),
            ('‘', '’', ['“', '「','"'], ['”','」', '"']),
            # 可以添加更多首尾标点对，例如 ('(', ')', ['（'], ['）']) 等
        ]

        for orig_start, orig_end, alt_starts, alt_ends in boundary_punctuation_pairs:
            # 检查原文的开头与结尾标点，且只有一个成对标点
            if original_stripped.startswith(orig_start) and original_stripped.endswith(orig_end) and original_stripped.count(orig_start) == 1 and original_stripped.count(orig_end) == 1:
                matched_alt = False
                for i, alt_start in enumerate(alt_starts):

                    alt_end = alt_ends[i]
                    # 检查译文是否以对应的替代标点开头和结尾
                    if translated_stripped.startswith(alt_start) and translated_stripped.endswith(alt_end):

                        # 替换译文的首尾标点为原文的标点
                        inner_text = translated_stripped[len(alt_start):-len(alt_end)]    # 截取掉译文的首尾标点
                        translated_stripped = orig_start + inner_text + orig_end  # 用原文标点包裹

                        # 处理完当前原文标点对后，跳出循环
                        matched_alt = True
                        break # 找到匹配的替代项后，不再尝试其他替代项

                if matched_alt:
                    break # 处理完当前原文标点对后，不再尝试其他原文标点对


        # --- 阶段2: 处理其他类型文本 ---
        # 1. 定义原文和译文的内部引号
        orig_internal_start = '「'
        orig_internal_end = '」'
        trans_internal_quote = '"' # 英文双引号，开始和结束相同

        # 2. 检查原文中是否有成对的「 和 」，并计算对数
        orig_start_count = original_stripped.count(orig_internal_start)
        orig_end_count = original_stripped.count(orig_internal_end)

        # 3. 检查译文中是否有成对的英文双引号，并计算数量
        trans_quote_count = translated_stripped.count(trans_internal_quote)

        # 4. 条件判断：
        #    - 原文中「 和 」数量相等且大于0
        #    - 译文中 " 数量是偶数且大于0
        #    - 原文中的对数 == 译文中的对数 
        if ((orig_start_count > 0 and orig_start_count == orig_end_count) and (trans_quote_count > 0 and trans_quote_count % 2 == 0) and (orig_start_count == trans_quote_count // 2)):

            # 5. 执行替换：从左到右，依次将 " 替换为 「 和 」
            temp_translated_list = list(translated_stripped) # 转为列表方便修改
            quote_indices = [i for i, char in enumerate(temp_translated_list) if char == trans_internal_quote]

            open_quote = True # 标记下一个应该是开引号还是闭引号
            replacements_done = 0
            
            # 确保找到的引号数量和预期一致
            if len(quote_indices) == trans_quote_count:

                for index in quote_indices:
                    if open_quote:
                        temp_translated_list[index] = orig_internal_start # 直接修改列表
                    else:
                        temp_translated_list[index] = orig_internal_end # 直接修改列表
                        replacements_done += 1
                    open_quote = not open_quote # 切换状态

                translated_stripped = "".join(temp_translated_list) # 转换回字符串

        # --- 阶段3: 处理内部可以全局替换的标点符号 ---
        # 定义标点替换映射：key 是原文期望的标点，value 是译文中可能出现的需要被替换的标点列表
        punctuation_map = {
            '…': ['...', '。。。'], # 中文省略号 替换 英文省略号 或 多个句号
            '—': ['--', '——'],   # 中文破折号 替换 两个连字符或 加长破折号
            #'！': ['!'],          # 不能替换，因为rpgmaker游戏中感叹号是代码...
            '？': ['?'],          # 中文问号 替换 英文问号
        }

        # 遍历标点映射表
        for original_punc, alternative_puncs in punctuation_map.items():
            # 遍历该原文标点对应的所有可能替代标点
            for alt_punc in alternative_puncs:
                # 在译文中全局替换替代标点为原文标点
                translated_stripped = translated_stripped.replace(alt_punc, original_punc)

        # --- 阶段4: 针对多行文本的双引号处理 ---
        original_stripped , translated_stripped = self.check_and_adjust_quotes(original_stripped, translated_stripped)

        # --- 最终处理: 还原前后空白 ---
        # 将处理过的核心文本与原文的前后空白结合
        result = leading_whitespace + translated_stripped + trailing_whitespace
        return result
    

    # 处理多行文本的双引号问题，有些AI会在多行文本时，将每一行当作一句话进行翻译，导致每一行都加上了双引号
    def check_and_adjust_quotes(self,original, translation):
        # 分割原文和译文为行
        original_lines = original.split("\n")
        translation_lines = translation.split("\n")

        # 检查行数一致
        if  len(original_lines) !=len(translation_lines):
            return original, translation

        modified_translation = []

        for orig_line, trans_line in zip(original_lines, translation_lines):

            if len(trans_line) >= 2 and trans_line.startswith('"'):
                # 获取原文行首字符
                orig_start = orig_line[0] if len(orig_line) > 0 else ''

                # 如果原文首不符合要求，则去掉译文双引号
                if orig_start not in {'"', '“', '「', """'"""} :
                    trans_line = trans_line[1:]

            if len(trans_line) >= 2 and trans_line.endswith('"'):
                # 获取原文行尾字符
                orig_end = orig_line[-1] if len(orig_line) > 0 else ''

                # 如果原文尾不符合要求，则去掉译文双引号
                if orig_end not in {'"', '”', '」', """'"""}:
                    trans_line = trans_line[:-1]

            modified_translation.append(trans_line)

        # 重建译文文本
        adjusted_translation = '\n'.join(modified_translation)
        return original, adjusted_translation


================================================
FILE: PluginScripts/TextNormalizer/TextNormalizer.py
================================================
import itertools
import unicodedata

from PluginScripts.PluginBase import PluginBase
from ModuleFolders.TaskConfig.TaskConfig import TaskConfig

class TextNormalizer(PluginBase):

    # 自定义规则
    CUSTOM_RULE = {}

    # 全角转半角
    CUSTOM_RULE.update({chr(i): chr(i - 0xFEE0) for i in itertools.chain(
        range(0xFF21, 0xFF3A + 1),   # 全角 A-Z 转换为 半角 A-Z
        range(0xFF41, 0xFF5A + 1),   # 全角 a-z 转换为 半角 a-z
        range(0xFF10, 0xFF19 + 1),   # 全角 0-9 转换为 半角 0-9
    )})

    # 全角转半角 - 片假名
    CUSTOM_RULE.update({
        "ｱ": "ア",
        "ｲ": "イ",
        "ｳ": "ウ",
        "ｴ": "エ",
        "ｵ": "オ",
        "ｶ": "カ",
        "ｷ": "キ",
        "ｸ": "ク",
        "ｹ": "ケ",
        "ｺ": "コ",
        "ｻ": "サ",
        "ｼ": "シ",
        "ｽ": "ス",
        "ｾ": "セ",
        "ｿ": "ソ",
        "ﾀ": "タ",
        "ﾁ": "チ",
        "ﾂ": "ツ",
        "ﾃ": "テ",
        "ﾄ": "ト",
        "ﾅ": "ナ",
        "ﾆ": "ニ",
        "ﾇ": "ヌ",
        "ﾈ": "ネ",
        "ﾉ": "ノ",
        "ﾊ": "ハ",
        "ﾋ": "ヒ",
        "ﾌ": "フ",
        "ﾍ": "ヘ",
        "ﾎ": "ホ",
        "ﾏ": "マ",
        "ﾐ": "ミ",
        "ﾑ": "ム",
        "ﾒ": "メ",
        "ﾓ": "モ",
        "ﾔ": "ヤ",
        "ﾕ": "ユ",
        "ﾖ": "ヨ",
        "ﾗ": "ラ",
        "ﾘ": "リ",
        "ﾙ": "ル",
        "ﾚ": "レ",
        "ﾛ": "ロ",
        "ﾜ": "ワ",
        "ｦ": "ヲ",
        "ﾝ": "ン",
        "ｧ": "ァ",
        "ｨ": "ィ",
        "ｩ": "ゥ",
        "ｪ": "ェ",
        "ｫ": "ォ",
        "ｬ": "ャ",
        "ｭ": "ュ",
        "ｮ": "ョ",
        "ｯ": "ッ",
        "ｰ": "ー",
        "ﾞ": "゛",  # 浊音符号
        "ﾟ": "゜",  # 半浊音符号
    })

    def __init__(self) -> None:
        super().__init__()

        self.name = "TextNormalizer"
        self.description = (
            "文本规范器，对文本中不规范的字符（例如半角片假名）进行修正，按需开启"
            + "\n"
            + "兼容性：支持英语、日语；支持全部模型；支持全部文本格式；仅支持翻译流程；"
        )

        self.visibility = True  # 是否在插件设置中显示
        self.default_enable = True  # 默认启用状态

        self.add_event("normalize_text", PluginBase.PRIORITY.NORMAL)

    def on_event(self, event: str, config: TaskConfig, data: dict) -> None:
        if event in ("normalize_text",):
            self.on_normalize_text(event, config, data)

    # 文本规范化事件
    def on_normalize_text(self, event: str, config: TaskConfig, data: dict) -> None:
        for k in data.keys():
            data[k] = self.normalize(data.get(k, ""))

    # 规范化
    def normalize(self, text: str) -> str:
        # NFC（Normalization Form C）：将字符分解后再合并成最小数量的单一字符（合成字符）。
        # NFD（Normalization Form D）：将字符分解成组合字符（即一个字母和附加的重音符号等）。
        # NFKC（Normalization Form KC）：除了合成与分解外，还会进行兼容性转换，例如将全角字符转换为半角字符。
        # NFKD（Normalization Form KD）：除了分解外，还会进行兼容性转换。
        text = unicodedata.normalize("NFC", text)

        # 应用自定义的规则
        text = "".join([TextNormalizer.CUSTOM_RULE.get(char, char) for char in text])

        # 返回结果
        return text


================================================
FILE: PluginScripts/TranslationCheckPlugin/TranslationCheckPlugin.py
================================================
import json
import os
import re
import time

from ModuleFolders.Cache.CacheItem import TranslationStatus
from ModuleFolders.Cache.CacheProject import CacheProject
from ..PluginBase import PluginBase

class TranslationCheckPlugin(PluginBase):
    def __init__(self):
        super().__init__()
        self.name = "TranslationCheckPlugin"
        self.description = "翻译流程检查插件，用于翻译结果与功能运行评估，包括术语表、禁翻表、换行符和自动处理等。\n错误信息文件将输出到 output 文件夹。"
        self.visibility = True
        self.default_enable = False
        self.add_event("translation_completed", PluginBase.PRIORITY.LOWEST)

    def load(self):
        pass

    def on_event(self, event_name, config, event_data: CacheProject):
        if event_name == "translation_completed":
            self.check_cache(config, event_data)

    def prepare_regex_patterns(self, exclusion_list_data):
        """准备所有需要使用的正则表达式模式"""
        patterns = []
        regex_file_path = os.path.join(".", "Resource", "Regex", "check_regex.json") # 修正路径拼接

        # 从正则库加载基础正则
        if os.path.exists(regex_file_path):
            try:
                with open(regex_file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    file_patterns = [item["regex"] for item in data if isinstance(item, dict) and "regex" in item]
                    patterns.extend(file_patterns)
            except (FileNotFoundError, json.JSONDecodeError, KeyError) as e:
                print(f"[WARNING][TranslationCheckPlugin] 加载正则文件 '{regex_file_path}' 失败: {e}")
        else:
             print(f"[WARNING][TranslationCheckPlugin] 正则文件未找到: '{regex_file_path}'")


        # 合并禁翻表数据
        if exclusion_list_data: # 检查 exclusion_list_data 是否存在且非空
            exclusion_patterns = []
            for item in exclusion_list_data:
                if isinstance(item, dict): # 确保 item 是字典
                    if regex := item.get("regex"):
                        try:
                            re.compile(regex) # 尝试编译，验证正则有效性
                            exclusion_patterns.append(regex)
                        except re.error as e:
                            print(f"[WARNING][TranslationCheckPlugin] 禁翻表中的无效正则表达式: '{regex}', 错误: {e}")
                    elif markers := item.get("markers"): # 使用 markers 字段
                        exclusion_patterns.append(re.escape(markers)) # 转义 markers 并添加
            patterns.extend(exclusion_patterns)
        return patterns

    def check_cache(self, config, cache_data: CacheProject):
        error_entries = [] # 存储结构化错误信息
        output_path = config.label_output_path
        timestamp = time.strftime("%Y%m%d-%H%M%S")
        json_error_filename = f"translation_check_errors_{timestamp}.json" # 错误信息单独json文件
        json_error_filepath = os.path.join(output_path, json_error_filename)


        if not os.path.exists(output_path):
            os.makedirs(output_path, exist_ok=True)

        # 获取配置项
        prompt_dictionary_switch = config.prompt_dictionary_switch
        prompt_dictionary_data = config.prompt_dictionary_data if prompt_dictionary_switch else [] # 仅在开关打开时获取
        exclusion_list_switch = config.exclusion_list_switch
        exclusion_list_data = config.exclusion_list_data if exclusion_list_switch else [] # 仅在开关打开时获取
        auto_process_text_code_segment = config.auto_process_text_code_segment

        # 仅在需要时准备正则模式
        patterns = []
        if exclusion_list_switch or auto_process_text_code_segment:
            patterns = self.prepare_regex_patterns(exclusion_list_data if exclusion_list_switch else [])

        project_report_logged = False # 标记项目报告是否已输出

        total_error_count = 0 # 统计总错误数
        check_summary = {
            "prompt_dictionary_errors": 0,
            "exclusion_list_errors": 0,
            "auto_process_errors": 0,
            "newline_errors": 0,
            "placeholder_errors": 0,
            "numbered_prefix_errors": 0,
            "example_text_errors": 0
        }
        
        # 初始化项目报告相关变量
        project_type = ""
        start_time = None
        total_completion_tokens = 0
        total_requests = 0
        error_requests = 0
        total_line = 0
        translated_line = 0

        project_type = cache_data.project_type
        data = cache_data.stats_data
        start_time = data.start_time
        total_completion_tokens = data.total_completion_tokens
        total_requests = data.total_requests
        error_requests = data.error_requests
        total_line = data.total_line
        translated_line = data.line
        end_time = time.time()

        if start_time: # 确保 start_time 有效
            elapsed_time = end_time - start_time
            tokens_per_second = total_completion_tokens / elapsed_time if elapsed_time > 0 else 0
            performance_level = self.map_performance_level(tokens_per_second) # 使用新的映射函数

            project_report = [
                "=" * 60,
                "          💻 项目运行报告 💻          ",
                "─" * 60,
                f"  📌 项目类型: {project_type}",
                f"  ⏱ 开始时间: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(start_time))}",
                f"  🏁 结束时间: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(end_time))}",
                f"  ⏳ 运行时长: {elapsed_time:.2f} 秒",
                f"  📨 总请求数: {total_requests}",
                f"  ❌ 错误请求数: {error_requests}",
                f"  📝 总行数: {total_line}",
                f"  ✅ 翻译行数: {translated_line}",
                f"  ⚡ Tokens速度: {tokens_per_second:.2f} t/s",
                "─" * 60,
                "          📊 性能评估报告 📊          ",
                f"{performance_level}",
                "=" * 60 + "\n"
            ]
            print("\n".join(project_report)) # 项目报告直接输出到控制台
            project_report_logged = True # 标记已输出
        else:
            print("[WARNING][TranslationCheckPlugin] 项目报告条目缺少有效的 'start_time'。")

        # 再处理文本检查条目
        for file in cache_data.files.values():
            for entry in file.items:

                # 文本条目检查逻辑...
                source_text = entry.source_text
                translated_text = entry.translated_text
                translation_status = entry.translation_status
                storage_path = file.storage_path
                file_name = file.file_name if file.file_name else "Unknown File"
                text_index = entry.text_index

                # 安全获取文本，避免 None 导致后续检查出错
                source_text = source_text if source_text is not None else ""
                translated_text = translated_text if translated_text is not None else ""

                if translation_status == TranslationStatus.EXCLUDED:  # 已被过滤
                    continue # 跳过被过滤的条目

                current_entry_errors = [] # 存储当前条目的错误信息

                if translation_status == 0: # 未翻译
                    error_msg = "🚧 [WARNING] 条目未翻译 "
                    current_entry_errors.append(error_msg) # 记录错误

                elif translation_status == 1: # 已翻译条目
                    # 各项检查，并将错误信息添加到 current_entry_errors
                    # 术语表检查
                    if prompt_dictionary_switch and prompt_dictionary_data:
                        errors = self.check_prompt_dictionary(source_text, translated_text, prompt_dictionary_data)
                        if errors:
                            check_summary["prompt_dictionary_errors"] += len(errors)
                            current_entry_errors.extend(errors)
                    # 禁翻表功能检查
                    if exclusion_list_switch and exclusion_list_data:
                        errors = self.check_exclusion_list(source_text, translated_text, exclusion_list_data)
                        if errors:
                            check_summary["exclusion_list_errors"] += len(errors)
                            current_entry_errors.extend(errors)
                    # 自动处理检查
                    if auto_process_text_code_segment and patterns:
                        errors = self.check_auto_process(source_text, translated_text, patterns)
                        if errors:
                            check_summary["auto_process_errors"] += len(errors)
                            current_entry_errors.extend(errors)
                    # 占位符检查
                    if auto_process_text_code_segment:
                        errors = self.check_placeholder_residue( translated_text)
                        if errors:
                            check_summary["placeholder_errors"] += len(errors)
                            current_entry_errors.extend(errors)

                    # 数字序号检查
                    errors = self.check_numbered_prefix( translated_text)
                    if errors:
                        check_summary["numbered_prefix_errors"] += len(errors)
                        current_entry_errors.extend(errors)

                    # 示例文本复读检查
                    errors = self.check_example_text( translated_text)
                    if errors:
                        check_summary["example_text_errors"] += len(errors)
                        current_entry_errors.extend(errors)

                    # 换行符检查
                    errors = self.check_newline(source_text, translated_text)
                    if errors:
                        check_summary["newline_errors"] += len(errors)
                        current_entry_errors.extend(errors)


                if current_entry_errors: # 如果当前条目有错误，则添加到结构化错误日志
                    total_error_count += len(current_entry_errors)
                    error_entries.append({
                        "file_name": file_name,
                        "storage_path": storage_path,
                        "text_index": text_index,
                        "source_text": source_text,
                        "translated_text": translated_text,
                        "errors": current_entry_errors
                    })


        # 输出检查总结到控制台 (仅当有文本条目被检查过才输出总结)
        # 通过检查 total_error_count 或 check_summary 的值是否非零判断
        if any(v > 0 for v in check_summary.values()) or total_error_count > 0 or not project_report_logged:
             # 如果没有项目报告，或者有错误，或者总结非零，则输出总结
            summary_messages = ["\n"+"=" * 60, "          ✨ 检查总结 ✨          ", "─" * 60]
            if total_error_count > 0:
                summary_messages.append(f"          ❌ 共发现 {total_error_count} 个潜在问题 ❌")
                if check_summary["prompt_dictionary_errors"] > 0:
                    summary_messages.append(f"  - 📚 术语表检查: {check_summary['prompt_dictionary_errors']} 个错误 ⚠️")
                if check_summary["exclusion_list_errors"] > 0:
                    summary_messages.append(f"  - 🚫 禁翻表检查: {check_summary['exclusion_list_errors']} 个错误 ⚠️")
                if check_summary["auto_process_errors"] > 0:
                    summary_messages.append(f"  - ⚙️ 自动处理检查: {check_summary['auto_process_errors']} 个错误 ⚠️")
                if check_summary["placeholder_errors"] > 0:
                    summary_messages.append(f"  - 🍩 占位符残留检查: {check_summary['placeholder_errors']} 个错误 ⚠️")
                if check_summary["numbered_prefix_errors"] > 0:
                    summary_messages.append(f"  - 🔢 数字序号检查: {check_summary['numbered_prefix_errors']} 个错误 ⚠️")
                if check_summary["example_text_errors"] > 0:
                    summary_messages.append(f"  - 💦 示例文本复读检查: {check_summary['example_text_errors']} 个错误 ⚠️")
                if check_summary["newline_errors"] > 0:
                    summary_messages.append(f"  - 📃 换行符检查: {check_summary['newline_errors']} 个错误 ⚠️")

                if any(e['errors'][0] == "🚧 [WARNING] 条目未翻译 " for e in error_entries if e['errors']):
                    untranslated_count = sum(1 for e in error_entries if e['errors'] and e['errors'][0] == "🚧 [WARNING] 条目未翻译 ")
                    summary_messages.append(f"  - 🚧 未翻译条目: {untranslated_count} 个 ⚠️")

            elif any(cache_data.items_iter()):  # 上面遍历了所有items，所以只要items不为空就能确保有文本条目被检查过
                summary_messages.append("✅ 恭喜！所有已翻译条目的检查项均未发现明显错误 🎉🎉🎉")
            else: # 如果 cache_list 为空或只有项目报告
                 summary_messages.append("ℹ️ 未检查任何文本条目。")

            summary_messages.append("=" * 60 + "\n")
            print("\n".join(summary_messages)) # 控制台输出总结信息


        # 写入结构化错误信息到 JSON 文件
        if error_entries:
            try:
                with open(json_error_filepath, 'w', encoding='utf-8') as json_file:
                    json.dump(error_entries, json_file, indent=4, ensure_ascii=False) # 缩进和中文支持
                print(f"[INFO][TranslationCheckPlugin] {len(error_entries)} 个错误条目的详细信息已保存到: {json_error_filepath}")
            except IOError as e:
                print(f"[ERROR][TranslationCheckPlugin] 无法写入错误日志文件 '{json_error_filepath}': {e}")

        elif total_error_count == 0 and any(cache_data.items_iter()):  # 上面遍历了所有items，所以只要items不为空就能确保有文本条目被检查过
            print("[INFO][TranslationCheckPlugin] 所有已检查条目均无错误，未生成错误日志文件。")
        # 如果没有文本条目被检查，则不输出此信息


    def map_performance_level(self, tokens_per_second):
        """
        根据 tokens/s 速度进行性能评级，并计算超越用户百分比。
        百分比在每个速度等级区间内线性增长。
        """
        # 性能等级定义: (速度上限, 等级名称, 描述, 在该速度上限时达到的超越百分比)
        # 百分比应单调递增，且介于 0 到 100 之间。
        levels = [
            # (Max Speed, Level Name, Description, Percentile Target AT this Max Speed)
            (20,   "          🐌 蜗牛速",      "需要加油哦",   10.0),  # 在 20 t/s 时，超越 10.0%
            (100,   "          🚲 自行车速",    "正常起步",    30.0),  # 在 50 t/s 时，超越 30.0%
            (300,  "          🚗 汽车速度",    "流畅运行",     60.0),  # 在 100 t/s 时，超越 60.0%
            (500,  "          🚄 高铁速度",    "效率惊人",     85.0),  # 在 200 t/s 时，超越 85.0%
            (700,  "          ✈️ 飞机速度",    "专业级表现",   95.0),  # 在 350 t/s 时，超越 95.0%
            (800,  "          🚀 火箭速度",    "顶尖水平",     99.0),  # 在 600 t/s 时，超越 99.0%
            (1000, "          ⚡ 光子速度",    "超越物理极限", 99.9)   # 在 1000 t/s 时，超越 99.9%
            # 对于超过 1000 t/s 的速度，我们将百分比限制在 99.9%
        ]

        # 处理 tokens_per_second <= 0 的情况
        if tokens_per_second <= 0:
            level_name = levels[0][1]
            level_desc = levels[0][2]
            display_percent = 0.0
            return f"{level_name} {level_desc} \n  🎉恭喜你，超越全宇宙 {display_percent:.1f}% 的翻译用户！！！"

        level_name = levels[-1][1] # 默认名称为最高等级
        level_desc = levels[-1][2] # 默认描述为最高等级
        display_percent = levels[-1][3] # 默认百分比为最高等级目标

        prev_max_speed = 0.0
        prev_percentile = 0.0

        for max_speed, name, desc, target_percentile in levels:
            if tokens_per_second <= max_speed:
                level_name = name
                level_desc = desc

                # 在当前区间 [prev_max_speed, max_speed] 内进行线性插值
                speed_range = max_speed - prev_max_speed
                percentile_range = target_percentile - prev_percentile

                if speed_range > 0:
                    # 计算当前速度在速度区间内的比例
                    ratio = (tokens_per_second - prev_max_speed) / speed_range
                    # 根据比例计算插值后的百分比
                    display_percent = prev_percentile + ratio * percentile_range
                else: # 处理 speed_range 为 0 或负数（理论上不应发生，除非 levels 定义错误）
                      # 或者 tokens_per_second 恰好等于 prev_max_speed
                    display_percent = prev_percentile # 直接使用上一级的百分比

                # 确保百分比不会超过当前等级的目标值（防止浮点误差）
                # 同时确保百分比不低于上一等级的目标值
                display_percent = max(prev_percentile, min(display_percent, target_percentile))
                
                # 对最终结果应用一个全局上限，例如 99.9%
                display_percent = min(display_percent, 99.9)
                break # 找到对应的等级区间，停止循环

            # 更新上一等级的信息，为下一次迭代或超出最高等级时使用
            prev_max_speed = max_speed
            prev_percentile = target_percentile
        else:
            # 如果循环正常结束（未 break），说明 tokens_per_second 大于最后一个 max_speed
            # 使用最高等级的名称和描述，并将百分比限制在最终目标值（或全局上限）
            level_name = levels[-1][1]
            level_desc = levels[-1][2]
            display_percent = levels[-1][3]
            display_percent = min(display_percent, 99.9) # 再次确保上限

        # 确保百分比不为负（虽然理论上不会，但作为保险）
        display_percent = max(0.0, display_percent)

        return f"{level_name} {level_desc} \n  🎉恭喜你，翻译速度超越全宇宙 {display_percent:.1f}% 的用户！！！"


    def check_prompt_dictionary(self, source_text, translated_text, prompt_dictionary_data):
        """检查术语表功能, 返回错误信息列表"""
        errors = []
        # prompt_dictionary_data 已在调用前检查过非空
        for term in prompt_dictionary_data:
           if isinstance(term, dict): # 确保 term 是字典
                src_term = term.get("src")
                dst_term = term.get("dst")
                # 确保 src_term 和 dst_term 都存在且非空
                if src_term and dst_term:
                    # 简单的包含检查，可能需要更复杂的逻辑（如大小写、词形变化）
                    if src_term in source_text:
                        if dst_term not in translated_text:
                            error_msg = f"📚[术语表错误] 原文含 '{src_term}'，译文未找到对应术语 '{dst_term}'"
                            errors.append(error_msg)
        return errors


    def check_exclusion_list(self, source_text, translated_text, exclusion_list_data):
        """检查禁翻表功能, 返回错误信息列表"""
        errors = []
        # exclusion_list_data 已在调用前检查过非空
        for item in exclusion_list_data:
            pattern_to_check = None
            original_marker = None # 用于错误信息展示

            if isinstance(item, dict): # 确保 item 是字典
                regex = item.get("regex")
                markers = item.get("markers")

                if regex:
                    try:
                        re.compile(regex) # 再次验证（虽然 prepare_regex_patterns 可能已做）
                        pattern_to_check = regex
                        original_marker = f"正则 '{regex}'"
                    except re.error:
                        # 忽略无效正则，或记录一个警告
                        continue # 跳过这个无效项
                elif markers:
                    pattern_to_check = re.escape(markers)
                    original_marker = f"标记符 '{markers}'"

            if pattern_to_check and original_marker:
                try:
                     # 使用 finditer 获取所有匹配及其位置，更精确
                    for match in re.finditer(pattern_to_check, source_text):
                        matched_text = match.group(0) # 获取匹配到的具体文本
                        # 检查译文中是否“原样”包含这个匹配到的文本
                        if matched_text not in translated_text:
                            error_msg = f"🚫[禁翻表错误] 原文含 {original_marker} 匹配到的 '{matched_text}'，但译文缺少此内容"
                            # 避免重复添加完全相同的错误信息
                            if error_msg not in errors:
                                 errors.append(error_msg)
                except re.error:
                     # 处理 pattern_to_check 编译失败的情况（理论上不应发生）
                     continue
        return errors
    

    def check_auto_process(self, source_text, translated_text, patterns):
        """检查自动处理功能 (基于 patterns 列表), 返回错误信息列表"""
        errors = []

        # 确保输入是字符串，如果不是则视为空字符串处理或保持原样以便后续处理
        _source_text = source_text if isinstance(source_text, str) else ""
        _translated_text = translated_text if isinstance(translated_text, str) else ""

        # --- 去除尾部所有换行符 ---
        _source_text = _source_text.rstrip('\n')
        _translated_text = _translated_text.rstrip('\n')

        # patterns 已在调用前检查过非空 
        for pattern in patterns:
            try:
                # 使用 finditer 获取所有匹配
                for match in re.finditer(pattern, _source_text):
                    matched_text = match.group(0)
                    # 检查处理过的译文中是否“原样”包含这个匹配到的文本
                    if matched_text not in _translated_text:
                        # 对 pattern 做截断，防止过长
                        pattern_display = pattern[:50] + '...' if len(pattern) > 50 else pattern
                        error_msg = f"⚙️[自动处理错误] 规则 '{pattern_display}' 匹配到 '{matched_text}'，但译文缺少此内容"
                        if error_msg not in errors:
                             errors.append(error_msg)
            except re.error:
                 continue
        return errors


    def check_newline(self, source_text, translated_text):
        """检查换行符数量一致性, 返回错误信息列表"""
        errors = []

        # 确保输入是字符串，如果不是则视为空字符串处理或保持原样以便后续处理
        _source_text = source_text if isinstance(source_text, str) else ""
        _translated_text = translated_text if isinstance(translated_text, str) else ""

        # 去除头尾的空格和换行符
        trimmed_source_text = _source_text.strip()
        trimmed_translated_text = _translated_text.strip()

        # 在处理过的文本上计算文本内的换行符数量
        source_newlines = trimmed_source_text.count('\n')
        # 检查原文中的转义换行符
        source_newlines += trimmed_source_text.count('\\n')

        translated_newlines = trimmed_translated_text.count('\n')
        translated_newlines += trimmed_translated_text.count('\\n')

        if source_newlines != translated_newlines:
            error_msg = f"📃[换行符错误] 原文有 {source_newlines} 个换行符，译文有 {translated_newlines} 个"
            errors.append(error_msg)
        return errors


    def check_placeholder_residue(self,  translated_text):
        """检查占位符残留, 返回错误信息列表"""
        errors = []
        
        # 确保输入是字符串，如果不是则视为空字符串处理或保持原样以便后续处理
        translated_text = translated_text if isinstance(translated_text, str) else ""
        
        # 正则表达式匹配 [P+数字] 格式的占位符
        pattern = r'\[P\d+\]'  # 匹配示例：[P3]、[P25]、[P999]
        
        if re.search(pattern, translated_text):
            error_msg = f"🍩[占位符残留] 译文中残留有类似[P数字]的占位符，未能还原成功（示例：{re.findall(pattern, translated_text)[0]}）"
            errors.append(error_msg)
        return errors

    def check_numbered_prefix(self,  translated_text):
        """检查数字序号残留, 返回错误信息列表"""
        errors = []
        
        # 确保输入是字符串，如果不是则视为空字符串处理或保持原样以便后续处理
        translated_text = translated_text if isinstance(translated_text, str) else ""
        
        # 正则表达式匹配 1.2. 格式的占位符
        pattern = r'\d+\.\d+\.'  # 匹配示例：1.2.
        
        if re.search(pattern, translated_text):
            error_msg = f"🔢[数字序号残留] 译文中残留数字子序号，未能清除成功（示例：{re.findall(pattern, translated_text)[0]}）"
            errors.append(error_msg)
        return errors
    
    # 针对“示例文本[随机字母]-[随机数字]”的残留检查，目前只针对中文进行检查
    def check_example_text(self, translated_text):
        """检查示例文本复读, 返回错误信息列表"""
        errors = []
        
        # 确保输入是字符串，如果不是则视为空字符串处理或保持原样以便后续处理
        translated_text = translated_text if isinstance(translated_text, str) else ""
        
        # 正则表达式匹配 示例文本B-1 格式的示例复读文本
        # 匹配示例：示例文本B-1
        pattern = r'示例文本[A-Z]-\d+'
        
        if re.search(pattern, translated_text):
            error_msg = f"🔢[示例文本复读] 译文中出现示例文本复读问题，未能正确翻译（示例：{re.findall(pattern, translated_text)[0]}）"
            errors.append(error_msg)
        return errors




================================================
FILE: Resource/Localization/APIManagement.json
================================================
[Binary file]


================================================
FILE: Resource/Localization/AppFluentWindow.json
================================================
{
  "PART_1": {
    "确定是否退出程序": {
      "简中": "确定是否退出程序",
      "繁中": "確定是否退出程式",
      "English": "Confirm Exit",
      "日本語": "プログラムを終了しますか？"
    },
    "主窗口已关闭，稍后应用将自动退出": {
      "简中": "主窗口已关闭，稍后应用将自动退出",
      "繁中": "主視窗已關閉，稍後應用程式將自動退出",
      "English": "Main window closed, application will exit automatically.",
      "日本語": "メインウィンドウは閉じられました。アプリケーションは後で自動的に終了します。"
    },
    "应用设置": {
      "简中": "应用设置",
      "繁中": "應用程式設定",
      "English": "Application Settings",
      "日本語": "アプリケーション設定"
    },
    "主题切换": {
      "简中": "主题切换",
      "繁中": "主題切換",
      "English": "Theme Switching",
      "日本語": "テーマ切り替え"
    },
    "接口管理": {
      "简中": "接口管理",
      "繁中": "API 管理",     
      "English": "API Management",
      "日本語": "API管理"
    },
    "开始翻译": {
      "简中": "开始翻译",
      "繁中": "開始翻譯",
      "English": "Start Translation",
      "日本語": "翻訳を開始"
    },
    "任务设置": {
      "简中": "任务设置",
      "繁中": "任務設定",
      "English": "Task Settings",
      "日本語": "タスク設定"
    },
    "输出设置": {
      "简中": "输出设置",
      "繁中": "輸出設定",
      "English": "Output Settings",
      "日本語": "出力設定"
    },
    "插件设置": {
      "简中": "插件设置",
      "繁中": "插件程式設定",
      "English": "Plugin Settings",
      "日本語": "プラグイン設定"
    },
    "翻译设置": {
      "简中": "翻译设置",
      "繁中": "翻譯設定",
      "English": "Translation Settings",
      "日本語": "翻訳設定"
    },
    "润色设置": {
      "简中": "润色设置",
      "繁中": "潤飾設定",
      "English": "Polishing Settings",
      "日本語": "推敲設定"
    },
    "提示词设置": {
      "简中": "提示词设置",
      "繁中": "提示詞設定",
      "English": "Prompt Settings",
      "日本語": "プロンプト設定"
    },
    "翻译提示词": {
      "简中": "翻译提示词",
      "繁中": "翻譯提示詞",
      "English": "Translation Prompts",
      "日本語": "翻訳プロンプト"
    },
    "润色提示词": {
      "简中": "润色提示词",
      "繁中": "潤飾提示詞",
      "English": "Polishing Prompts",
      "日本語": "推敲プロンプト"
    },
    "排版提示词": {
      "简中": "排版提示词",
      "繁中": "排版提示詞",
      "English": "Formatting Prompts",
      "日本語": "組版プロンプト"
    },
    "排版参考": {
      "简中": "排版参考",
      "繁中": "排版參考",
      "English": "Format Reference",
      "日本語": "タイポグラフィー参考"
    },
    "基础提示": {
      "简中": "基础提示",
      "繁中": "基礎提示",
      "English": "Basic Prompts",
      "日本語": "基本プロンプト"
    },
    "背景设定": {
      "简中": "背景设定",
      "繁中": "背景設定",
      "English": "Background Settings",
      "日本語": "背景設定"
    },
    "角色介绍": {
      "简中": "角色介绍",
      "繁中": "角色介紹",
      "English": "Role Introduction",
      "日本語": "役割紹介"
    },
    "翻译风格": {
      "简中": "翻译风格",
      "繁中": "翻譯風格",
      "English": "Translation Style",
      "日本語": "翻訳スタイル"
    },
    "润色风格": {
      "简中": "润色风格",
      "繁中": "潤飾風格",
      "English": "Polishing Style",
      "日本語": "推敲スタイル"
    },
    "翻译示例": {
      "简中": "翻译示例",
      "繁中": "翻譯範例",
      "English": "Translation Example",
      "日本語": "翻訳例"
    },
    "术语表": {
      "简中": "术语表",
      "繁中": "術語表",
      "English": "Glossary",
      "日本語": "用語集"
    },
    "禁翻表": {
      "简中": "禁翻表",
      "繁中": "禁譯表",
      "English": "Do Not Translate List",
      "日本語": "翻訳禁止リスト"
    },
    "文本替换": {
      "简中": "文本替换",
      "繁中": "文字替換",
      "English": "Text Replacement",
      "日本語": "テキスト置換"
    },
    "译前替换": {
      "简中": "译前替换",
      "繁中": "譯前替換",
      "English": "Pre-translation Replacement",
      "日本語": "翻訳前置換"
    },
    "译后替换": {
      "简中": "译后替换",
      "繁中": "譯後替換",
      "English": "Post-translation Replacement",
      "日本語": "翻訳後置換"
    },
    "导出文本": {
      "简中": "导出文本",
      "繁中": "匯出文字",
      "English": "Export Text",
      "日本語": "テキストをエクスポート"
    },
    "导入文本": {
      "简中": "导入文本",
      "繁中": "匯入文字",
      "English": "Import Text",
      "日本語": "テキストをインポート"
    },
    "导出增量文本": {
      "简中": "导出增量文本",
      "繁中": "匯出增量文字",
      "English": "Export Incremental Text",
      "日本語": "増分テキストをエクスポート"
    },
    "检查更新": {
      "简中": "检查更新",
      "繁中": "檢查更新",
      "English": "Check for Updates",
      "日本語": "更新を確認"
    },
    "更新检查失败": {
      "简中": "更新检查失败",
      "繁中": "更新檢查失敗",
      "English": "Update Check Failed",
      "日本語": "更新チェック失敗"
    },
    "请检查报错信息": {
      "简中": "请检查报错信息",
      "繁中": "請檢查錯誤訊息",
      "English": "Please check the error message",
      "日本語": "エラーメッセージを確認してください"
    },
    "发现新版本": {
      "简中": "发现新版本",
      "繁中": "發現新版本",
      "English": "New Version Found",
      "日本語": "新しいバージョンが見つかりました"
    },
    "当前版本: {0}, 最新版本: {1}, 点击更新按钮进行更新": {
      "简中": "当前版本: {0}, 最新版本: {1}, 点击更新按钮进行更新",
      "繁中": "當前版本: {0}, 最新版本: {1}, 點擊更新按鈕進行更新",
      "English": "Current version: {0}, Latest version: {1}, Click the update button to update",
      "日本語": "現在のバージョン: {0}, 最新バージョン: {1}, 更新ボタンをクリックして更新してください"
    },
    "更新检查": {
      "简中": "更新检查",
      "繁中": "更新檢查",
      "English": "Update Check",
      "日本語": "更新チェック"
    },
    "当前已是最新版本": {
      "简中": "当前已是最新版本",
      "繁中": "當前已是最新版本",
      "English": "Already the latest version",
      "日本語": "すでに最新バージョンです"
    }
  }
}


================================================
FILE: Resource/Localization/ApplicationSettings.json
================================================
[Binary file]


================================================
FILE: Resource/Localization/BasicTablePage.json
================================================
[Binary file]


================================================
FILE: Resource/Localization/EditView.json
================================================
{
  "UI_TEXT": {
    "返回": {
      "简中": "返回",
      "繁中": "返回",
      "English": "Back",
      "日本語": "戻る"
    },
    "开始翻译": {
      "简中": "开始翻译",
      "繁中": "開始翻譯",
      "English": "Start Translation",
      "日本語": "翻訳開始"
    },
    "开始润色": {
      "简中": "开始润色",
      "繁中": "開始潤色",
      "English": "Start Polishing",
      "日本語": "推敲開始"
    },
    "继续": {
      "简中": "继续",
      "繁中": "繼續",
      "English": "Continue",
      "日本語": "続ける"
    },
    "停止": {
      "简中": "停止",
      "繁中": "停止",
      "English": "Stop",
      "日本語": "停止"
    },
    "定时": {
      "简中": "定时",
      "繁中": "定時",
      "English": "Schedule",
      "日本語": "タイマー"
    },
    "导出结果": {
      "简中": "导出结果",
      "繁中": "匯出結果",
      "English": "Export Results",
      "日本語": "エクスポート結果"
    },
    "翻译模式": {
      "简中": "翻译模式",
      "繁中": "翻譯模式",
      "English": "Translation Mode",
      "日本語": "翻訳モード"
    },
    "润色模式": {
      "简中": "润色模式",
      "繁中": "潤色模式",
      "English": "Polishing Mode",
      "日本語": "推敲モード"
    },
    "模式已切换为": {
      "简中": "模式已切换为",
      "繁中": "模式已切換為",
      "English": "Mode switched to",
      "日本語": "モードが次に切り替わりました"
    },
    "选择导出目录": {
      "简中": "选择导出目录",
      "繁中": "選擇匯出目錄",
      "English": "Select Export Directory",
      "日本語": "エクスポート先を選択"
    },
    "定时任务": {
      "简中": "定时任务",
      "繁中": "定時任務",
      "English": "Scheduled Task",
      "日本語": "スケジュールタスク"
    },
    "请设置开始任务的时间": {
      "简中": "请设置开始任务的时间",
      "繁中": "請設定開始任務的時間",
      "English": "Please set task start time",
      "日本語": "タスク開始時間を設定してください"
    },
    "定时任务已取消": {
      "简中": "定时任务已取消",
      "繁中": "定時任務已取消",
      "English": "Scheduled task cancelled",
      "日本語": "スケジュールされたタスクはキャンセルされました"
    },
    "已设置定时任务，将在": {
      "简中": "已设置定时任务，将在",
      "繁中": "已設定定時任務，將在",
      "English": "Scheduled task set for",
      "日本語": "タスクをスケジュールしました、開始時刻"
    },
    "定时开始任务": {
      "简中": "定时开始任务",
      "繁中": "定時開始任務",
      "English": "to start the task",
      "日本語": "にタスクを開始します"
    }
  },
  "SearchDialog": {
    "未找到结果": {
      "简中": "未找到结果",
      "繁中": "未找到結果",
      "English": "No Results Found",
      "日本語": "結果が見つかりません"
    },
    "未能找到与 '{}' 匹配的内容。": {
      "简中": "未能找到与 '{}' 匹配的内容。",
      "繁中": "未能找到與 '{}' 匹配的內容。",
      "English": "No content matching '{}' could be found.",
      "日本語": "'{}' に一致する内容が見つかりませんでした。"
    },
    "使用正则表达式": {
      "简中": "使用正则表达式",
      "繁中": "使用正規表示式",
      "English": "Use regular expression",
      "日本語": "正規表現を使用"
    },
    "仅搜索被标记行": {
      "简中": "仅搜索被标记行",
      "繁中": "僅搜索被標記行",
      "English": "Search only marked lines",
      "日本語": "マークされた行のみを検索"
    },
    "搜索": {
      "简中": "搜索",
      "繁中": "搜尋",
      "English": "Search",
      "日本語": "検索"
    },
    "搜索替换": {
      "简中": "搜索替换",
      "繁中": "搜尋替換",
      "English": "Search & Replace",
      "日本語": "検索と置換"
    },
    "取消": {
      "简中": "取消",
      "繁中": "取消",
      "English": "Cancel",
      "日本語": "キャンセル"
    },
    "文件": {
      "简中": "文件",
      "繁中": "檔案",
      "English": "File",
      "日本語": "ファイル"
    },
    "查找内容:": {
      "简中": "查找内容:",
      "繁中": "尋找內容:",
      "English": "Find what:",
      "日本語": "検索内容:"
    },
    "输入搜索内容...": {
      "简中": "输入搜索内容...",
      "繁中": "輸入搜尋內容...",
      "English": "Enter search text...",
      "日本語": "検索内容を入力..."
    },
    "替换为:": {
      "简中": "替换为:",
      "繁中": "替換為:",
      "English": "Replace with:",
      "日本語": "置換後の文字列:"
    },
    "输入替换后的文本...": {
      "简中": "输入替换后的文本...",
      "繁中": "輸入替換後的文字...",
      "English": "Enter replacement text...",
      "日本語": "置換後のテキストを入力..."
    },
    "选项:": {
      "简中": "选项:",
      "繁中": "選項:",
      "English": "Options:",
      "日本語": "オプション:"
    },
    "区分大小写": {
      "简中": "区分大小写",
      "繁中": "區分大小寫",
      "English": "Case sensitive",
      "日本語": "大文字と小文字を区別"
    },
    "全词匹配": {
      "简中": "全词匹配",
      "繁中": "全詞比對",
      "English": "Match whole word",
      "日本語": "単語単位で検索"
    },
    "正则模式": {
      "简中": "正则模式",
      "繁中": "正規表示式",
      "English": "Regular expression",
      "日本語": "正規表現"
    },
    "范围:": {
      "简中": "范围:",
      "繁中": "範圍:",
      "English": "Scope:",
      "日本語": "範囲:"
    },
    "译文列": {
      "简中": "译文列",
      "繁中": "譯文列",
      "English": "Translation column",
      "日本語": "訳文列"
    },
    "润文列": {
      "简中": "润文列",
      "繁中": "潤文列",
      "English": "Polished column",
      "日本語": "校閲文列"
    },
    "全部替换": {
      "简中": "全部替换",
      "繁中": "全部替換",
      "English": "Replace All",
      "日本語": "すべて置換"
    },
    "行": {
      "简中": "行",
      "繁中": "行",
      "English": "Line",
      "日本語": "行"
    },
    "原文": {
      "简中": "原文",
      "繁中": "原文",
      "English": "Source",
      "日本語": "原文"
    },
    "译文": {
      "简中": "译文",
      "繁中": "譯文",
      "English": "Translation",
      "日本語": "訳文"
    },
    "润文": {
      "简中": "润文",
      "繁中": "潤文",
      "English": "Polished",
      "日本語": "校閲文"
    },
    "失败": {
      "简中": "失败",
      "繁中": "失敗",
      "English": "Failed",
      "日本語": "失敗"
    },
    "查找内容不能为空。": {
      "简中": "查找内容不能为空。",
      "繁中": "尋找內容不能為空。",
      "English": "Find content cannot be empty.",
      "日本語": "検索内容を空にすることはできません。"
    },
    "请至少选择一个替换范围（译文列或润文列）。": {
      "简中": "请至少选择一个替换范围（译文列或润文列）。",
      "繁中": "請至少選擇一個替換範圍（譯文列或潤文列）。",
      "English": "Please select at least one scope (Translation or Polished column).",
      "日本語": "少なくとも一つの置換範囲（訳文列または校閲文列）を選択してください。"
    },
    "替换失败": {
      "简中": "替换失败",
      "繁中": "替換失敗",
      "English": "Replace Failed",
      "日本語": "置換失敗"
    },
    "无效的正则表达式：{}": {
      "简中": "无效的正则表达式：{}",
      "繁中": "無效的正規表示式: {}",
      "English": "Invalid regular expression: {}",
      "日本語": "無効な正規表現: {}"
    },
    "操作完成": {
      "简中": "操作完成",
      "繁中": "操作完成",
      "English": "Operation Completed",
      "日本語": "操作完了"
    },
    "共找到并替换了 {} 处。": {
      "简中": "共找到并替换了 {} 处。",
      "繁中": "共找到並替換了 {} 處。",
      "English": "Found and replaced {} occurrences.",
      "日本語": "{}箇所を検索して置換しました。"
    },
    "检查": {
      "简中": "检查",
      "繁中": "検査",
      "English": "Inspect",
      "日本語": "検査"
    },
    "宏观统计": {
      "简中": "宏观统计",
      "繁中": "宏觀統計",
      "English": "Macro Statistics",
      "日本語": "マクロ統計"
    },
    "精准判断": {
      "简中": "精准判断",
      "繁中": "精準判斷",
      "English": "Precise Judgment",
      "日本語": "精密判定"
    }
  },
  "LanguageCheck": {
    "开始检查": {
      "简中": "开始检查",
      "繁中": "開始檢查",
      "English": "Start Check",
      "日本語": "チェック開始"
    },
    "取消": {
      "简中": "取消",
      "繁中": "取消",
      "English": "Cancel",
      "日本語": "キャンセル"
    },
    "检测对象:": {
      "简中": "检测对象:",
      "繁中": "檢測對象:",
      "English": "Target:",
      "日本語": "検出対象:"
    },
    "译文": {
      "简中": "译文",
      "繁中": "譯文",
      "English": "Translation",
      "日本語": "訳文"
    },
    "润文": {
      "简中": "润文",
      "繁中": "潤文",
      "English": "Polished",
      "日本語": "校閲文"
    },
    "语言检测:": {
      "简中": "语言检测:",
      "繁中": "語言檢測:",
      "English": "Lang Detect:",
      "日本語": "言語検出:"
    },
    "宏观统计": {
      "简中": "宏观统计",
      "繁中": "宏觀統計",
      "English": "Macro Statistics",
      "日本語": "マクロ統計"
    },
    "精准判断": {
      "简中": "精准判断",
      "繁中": "精準判斷",
      "English": "Precise Judgment",
      "日本語": "精密判定"
    },
    "规则检查项": {
      "简中": "规则检查项",
      "繁中": "規則檢查項",
      "English": "Rule Check Items",
      "日本語": "ルールチェック項目"
    },
    "术语表检查": {
      "简中": "术语表检查",
      "繁中": "術語表檢查",
      "English": "Glossary Check",
      "日本語": "用語集チェック"
    },
    "禁翻表检查": {
      "简中": "禁翻表检查",
      "繁中": "禁翻表檢查",
      "English": "Exclusion Check",
      "日本語": "翻訳除外チェック"
    },
    "自动处理检查": {
      "简中": "自动处理检查",
      "繁中": "自動處理檢查",
      "English": "Auto-process Check",
      "日本語": "自動処理チェック"
    },
    "占位符残留": {
      "简中": "占位符残留",
      "繁中": "佔位符殘留",
      "English": "Placeholder Residue",
      "日本語": "プレースホルダー残留"
    },
    "数字序号残留": {
      "简中": "数字序号残留",
      "繁中": "數字序號殘留",
      "English": "Numbering Residue",
      "日本語": "数字連番の残留"
    },
    "示例文本复读": {
      "简中": "示例文本复读",
      "繁中": "示例文本復讀",
      "English": "Example Repetition",
      "日本語": "例文のリピート"
    },
    "换行符一致性": {
      "简中": "换行符一致性",
      "繁中": "換行符一致性",
      "English": "Newline Consistency",
      "日本語": "改行の一致性"
    },
    "检查译文中是否包含术语表中的预定义译法": {
      "简中": "检查译文中是否包含术语表中的预定义译法",
      "繁中": "檢查譯文中是否包含術語表中的預定義譯法",
      "English": "Check if translation uses Glossary terms.",
      "日本語": "訳文に用語集の訳語が含まれているか確認します"
    },
    "检查译文中是否正确保留禁翻内容": {
      "简中": "检查译文中是否正确保留禁翻内容",
      "繁中": "檢查譯文中是否正確保留禁翻內容",
      "English": "Check if excluded content is preserved.",
      "日本語": "翻訳除外内容が保持されているか確認します"
    },
    "检查默认处理规则是否被正确执行": {
      "简中": "检查默认处理规则是否被正确执行",
      "繁中": "檢查默認處理規則是否被正確執行",
      "English": "Check if default rules are executed.",
      "日本語": "デフォルト処理ルールが実行されたか確認します"
    },
    "检查 [P0] 等占位标签是否残留在文本中": {
      "简中": "检查 [P0] 等占位标签是否残留在文本中",
      "繁中": "檢查 [P0] 等佔位標籤是否殘留在文本中",
      "English": "Check for placeholder tags like [P0].",
      "日本語": "[P0]などのタグが残っているか確認します"
    },
    "检查行首数字编号 (1.) 是否残留": {
      "简中": "检查行首数字编号 (1.) 是否残留",
      "繁中": "檢查行首數字編號 (1.) 是否殘留",
      "English": "Check for leading numbers (e.g., 1.).",
      "日本語": "行頭の番号(1.など)が残っているか確認します"
    },
    "检查是否存在由模型生成的无效内容": {
      "简中": "检查是否存在由模型生成的无效内容",
      "繁中": "檢查是否存在由模型生成的無效內容",
      "English": "Check for invalid AI-generated content.",
      "日本語": "AI生成の無効な内容が含まれるか確認します"
    },
    "检查译文换行符数量是否与原文一致": {
      "简中": "检查译文换行符数量是否与原文一致",
      "繁中": "檢查譯文換行符數量是否與原文一致",
      "English": "Check if newlines match source text.",
      "日本語": "改行数が原文と一致するか確認します"
    }
  },
  "TermExtraction": {
    "提取术语": {
      "简中": "提取术语",
      "繁中": "提取術語",
      "English": "Extract Terms",
      "日本語": "用語抽出"
    },
    "选择合适的NER模型，自动识别并提取文本中的专有名词（如人名、地名）。": {
      "简中": "选择合适的NER模型，自动识别并提取文本中的专有名词（如人名、地名）。",
      "繁中": "選擇合適的NER模型，自動識別並提取文本中的專有名詞（如人名、地名）。",
      "English": "Select an NER model to automatically extract proper nouns (names, locations, etc.).",
      "日本語": "適切なNERモデルを選択し、固有名詞（人名、地名など）を自動抽出します。"
    },
    "1. 选择分词模型": {
      "简中": "1. 选择分词模型",
      "繁中": "1. 選擇分詞模型",
      "English": "1. Select Model",
      "日本語": "1. モデル選択"
    },
    "模型下载指南": {
      "简中": "模型下载指南",
      "繁中": "模型下載指南",
      "English": "Download Guide",
      "日本語": "DLガイド"
    },
    "提示: 日语选择ja模型，英语选择en模型，韩语选择ko模型": {
      "简中": "提示: 日语选择ja模型，英语选择en模型，韩语选择ko模型",
      "繁中": "提示: 日語選擇ja模型，英語選擇en模型，韓語選擇ko模型",
      "English": "Tip: 'ja' for Japanese, 'en' for English, 'ko' for Korean.",
      "日本語": "ヒント: 日本語はja、英語はen、韓国語はkoを選択"
    },
    "2. 提取内容类型": {
      "简中": "2. 提取内容类型",
      "繁中": "2. 提取內容類型",
      "English": "2. Content Types",
      "日本語": "2. 抽出タイプ"
    },
    "人物 (Person)": {
      "简中": "人物 (Person)",
      "繁中": "人物 (Person)",
      "English": "Person",
      "日本語": "人物 (Person)"
    },
    "组织 (Org)": {
      "简中": "组织 (Org)",
      "繁中": "組織 (Org)",
      "English": "Organization (Org)",
      "日本語": "組織 (Org)"
    },
    "国家/城市 (GPE)": {
      "简中": "国家/城市 (GPE)",
      "繁中": "國家/城市 (GPE)",
      "English": "Country/City (GPE)",
      "日本語": "国/都市 (GPE)"
    },
    "地点 (Loc)": {
      "简中": "地点 (Loc)",
      "繁中": "地點 (Loc)",
      "English": "Location (Loc)",
      "日本語": "場所 (Loc)"
    },
    "产品/作品 (Product)": {
      "简中": "产品/作品 (Product)",
      "繁中": "產品/作品 (Product)",
      "English": "Product/Work",
      "日本語": "製品/作品 (Product)"
    },
    "事件 (Event)": {
      "简中": "事件 (Event)",
      "繁中": "事件 (Event)",
      "English": "Event",
      "日本語": "イベント (Event)"
    },
    "日期 (Date)": {
      "简中": "日期 (Date)",
      "繁中": "日期 (Date)",
      "English": "Date",
      "日本語": "日付 (Date)"
    },
    "地点 (Location)": {
      "简中": "地点 (Location)",
      "繁中": "地點 (Location)",
      "English": "Location",
      "日本語": "場所 (Location)"
    },
    "数量 (Quantity)": {
      "简中": "数量 (Quantity)",
      "繁中": "數量 (Quantity)",
      "English": "Quantity",
      "日本語": "数量 (Quantity)"
    },
    "开始提取": {
      "简中": "开始提取",
      "繁中": "開始提取",
      "English": "Start Extraction",
      "日本語": "抽出開始"
    },
    "取消": {
      "简中": "取消",
      "繁中": "取消",
      "English": "Cancel",
      "日本語": "キャンセル"
    },
    "未找到模型目录": {
      "简中": "未找到模型目录",
      "繁中": "未找到模型目錄",
      "English": "Model directory not found",
      "日本語": "モデルディレクトリが見つかりません"
    },
    "目录中无可用模型": {
      "简中": "目录中无可用模型",
      "繁中": "目錄中無可用模型",
      "English": "No available models in the directory",
      "日本語": "ディレクトリに利用可能なモデルがありません"
    },
    "错误": {
      "简中": "错误",
      "繁中": "錯誤",
      "English": "Error",
      "日本語": "エラー"
    },
    "术语提取结果": {
      "简中": "术语提取结果",
      "繁中": "術語提取結果",
      "English": "Term Extraction Results",
      "日本語": "用語抽出結果"
    },
    "未找到": {
      "简中": "未找到",
      "繁中": "未找到",
      "English": "Not Found",
      "日本語": "見つかりません"
    },
    "未能提取到任何符合条件的术语。": {
      "简中": "未能提取到任何符合条件的术语。",
      "繁中": "未能提取到任何符合條件的術語。",
      "English": "No terms matching the conditions were extracted.",
      "日本語": "条件に一致する用語は抽出されませんでした。"
    },
    "请先选择一个可用的语言模型。": {
      "简中": "请先选择一个可用的语言模型。",
      "繁中": "請先選擇一個可用的語言模型。",
      "English": "Please select an available language model first.",
      "日本語": "利用可能な言語モデルを先に選択してください。"
    },
    "请至少选择一个提取类型。": {
      "简中": "请至少选择一个提取类型。",
      "繁中": "請至少選擇一個提取類型。",
      "English": "Please select at least one entity type.",
      "日本語": "少なくとも一つの抽出タイプを選択してください。"
    },
    "翻译后保存到术语表": {
      "简中": "翻译后保存到术语表",
      "繁中": "翻譯後儲存至術語表",
      "English": "Translate and Save to Glossary",
      "日本語": "翻訳して用語集に保存"
    },
    "直接保存到术语表": {
      "简中": "直接保存到术语表",
      "繁中": "直接儲存至術語表",
      "English": "Save Directly to Glossary",
      "日本語": "直接用語集に保存"
    },
    "术语": {
      "简中": "术语",
      "繁中": "術語",
      "English": "Term",
      "日本語": "用語"
    },
    "出现次数": {
      "简中": "出现次数",
      "繁中": "出現次數",
      "English": "Occurrences",
      "日本語": "出現回数"
    },
    "类型": {
      "简中": "类型",
      "繁中": "類型",
      "English": "Type",
      "日本語": "タイプ"
    },
    "所在原文": {
      "简中": "所在原文",
      "繁中": "所在原文",
      "English": "Context (Original Text)",
      "日本語": "原文コンテキスト"
    },
    "来源文件": {
      "简中": "来源文件",
      "繁中": "來源檔案",
      "English": "Source File",
      "日本語": "ソースファイル"
    },
    "删除选中行": {
      "简中": "删除选中行",
      "繁中": "刪除選中行",
      "English": "Delete Selected Rows",
      "日本語": "選択した行を削除"
    },
    "总行数: {}": {
      "简中": "总行数: {}",
      "繁中": "總行數: {}",
      "English": "Total Rows: {}",
      "日本語": "総行数: {}"
    },
    "确认删除": {
      "简中": "确认删除",
      "繁中": "確認刪除",
      "English": "Confirm Deletion",
      "日本語": "削除の確認"
    },
    "您确定要删除选中的 {} 行吗？此操作不可撤销。": {
      "简中": "您确定要删除选中的 {} 行吗？此操作不可撤销。",
      "繁中": "您確定要刪除選中的 {} 行嗎？此操作不可撤銷。",
      "English": "Are you sure you want to delete the selected {} rows? This action cannot be undone.",
      "日本語": "選択した{}行を削除してもよろしいですか？この操作は元に戻せません。"
    },
    "操作成功": {
      "简中": "操作成功",
      "繁中": "操作成功",
      "English": "Success",
      "日本語": "操作成功"
    },
    "已成功删除 {} 行。": {
      "简中": "已成功删除 {} 行。",
      "繁中": "已成功刪除 {} 行。",
      "English": "Successfully deleted {} rows.",
      "日本語": "{}行の削除に成功しました。"
    },
    "提示": {
      "简中": "提示",
      "繁中": "提示",
      "English": "Info",
      "日本語": "ヒント"
    },
    "没有可保存的术语。": {
      "简中": "没有可保存的术语。",
      "繁中": "沒有可儲存的術語。",
      "English": "No terms to save.",
      "日本語": "保存する用語がありません。"
    },
    "保存成功": {
      "简中": "保存成功",
      "繁中": "儲存成功",
      "English": "Saved Successfully",
      "日本語": "保存成功"
    },
    "已添加 {} 个新术语到术语表。": {
      "简中": "已添加 {} 个新术语到术语表。",
      "繁中": "已新增 {} 個新術語至術語表。",
      "English": "Added {} new terms to the glossary.",
      "日本語": "{}個の新しい用語を用語集に追加しました。"
    },
    "保存失败": {
      "简中": "保存失败",
      "繁中": "儲存失敗",
      "English": "Save Failed",
      "日本語": "保存に失敗しました"
    },
    "没有可处理的术语。": {
      "简中": "没有可处理的术语。",
      "繁中": "沒有可處理的術語。",
      "English": "No terms to process.",
      "日本語": "処理する用語がありません。"
    },
    "任务已开始": {
      "简中": "任务已开始",
      "繁中": "任務已開始",
      "English": "Task Started",
      "日本語": "タスク開始"
    },
    "正在后台根据原文进行提取、翻译和保存，请稍后...": {
      "简中": "正在后台根据原文进行提取、翻译和保存，请稍后...",
      "繁中": "正在後台根據原文進行提取、翻譯和儲存，請稍後...",
      "English": "Extracting, translating, and saving in the background. Please wait...",
      "日本語": "バックグラウンドで原文に基づき抽出、翻訳、保存を行っています。しばらくお待ちください..."
    }
  },
  "GeneralMessages": {
    "警告": {
      "简中": "警告",
      "繁中": "警告",
      "English": "Warning",
      "日本語": "警告"
    },
    "提示": {
      "简中": "提示",
      "繁中": "提示",
      "English": "Info",
      "日本語": "情報"
    },
    "错误": {
      "简中": "错误",
      "繁中": "錯誤",
      "English": "Error",
      "日本語": "エラー"
    },
    "确认": {
      "简中": "确认",
      "繁中": "確認",
      "English": "Confirm",
      "日本語": "確認"
    },
    "取消": {
      "简中": "取消",
      "繁中": "取消",
      "English": "Cancel",
      "日本語": "キャンセル"
    },
    "将重置尚未完成的任务": {
      "简中": "将重置尚未完成的任务",
      "繁中": "將重置尚未完成的任務",
      "English": "This will reset the unfinished task.",
      "日本語": "未完了のタスクがリセットされます。"
    },
    "是否确定停止任务": {
      "简中": "是否确定停止任务",
      "繁中": "是否確定停止任務",
      "English": "Are you sure you want to stop the task?",
      "日本語": "タスクを停止してもよろしいですか？"
    },
    "无效时间": {
      "简中": "无效时间",
      "繁中": "無效時間",
      "English": "Invalid Time",
      "日本語": "無効な時間"
    },
    "与当前时间间隔过短": {
      "简中": "与当前时间间隔过短",
      "繁中": "與當前時間間隔過短",
      "English": "The time interval is too short from the current time",
      "日本語": "現在時刻との間隔が短すぎます"
    },
    "当前没有打开的标签页。": {
      "简中": "当前没有打开的标签页。",
      "繁中": "當前沒有開啟的標籤頁。",
      "English": "There are no open tabs.",
      "日本語": "開いているタブはありません。"
    },
    "请在原始数据表格标签页上执行此操作。": {
      "简中": "请在原始数据表格标签页上执行此操作。",
      "繁中": "請在原始資料表格標籤頁上執行此操作。",
      "English": "Please perform this action on an original data table tab.",
      "日本語": "この操作は元のデータテーブルタブで実行してください。"
    },
    "操作受限": {
      "简中": "操作受限",
      "繁中": "操作受限",
      "English": "Operation Restricted",
      "日本語": "操作が制限されています"
    },
    "选择无效": {
      "简中": "选择无效",
      "繁中": "選擇無效",
      "English": "Invalid Selection",
      "日本語": "無効な選択"
    },
    "无法从缓存中加载文件: {}": {
      "简中": "无法从缓存中加载文件: {}",
      "繁中": "無法從快取中載入檔案: {}",
      "English": "Failed to load file from cache: {}",
      "日本語": "キャッシュからファイルをロードできませんでした: {}"
    },
    "项目缓存文件已保存到翻译输出文件夹": {
      "简中": "项目缓存文件已保存到翻译输出文件夹",
      "繁中": "專案快取文件已保存到翻譯輸出資料夾",
      "English": "Project cache file has been saved to the translation output folder",
      "日本語": "プロジェクトキャッシュファイルは翻訳出力フォルダに保存されました"
    }
  }
}


================================================
FILE: Resource/Localization/MonitoringPage.json
================================================
{
  "PART_1": {
    "任务进度": {
      "简中": "任务进度",
      "繁中": "任務進度",
      "English": "Task Progress",
      "日本語": "タスク進捗"
    },
    "停止中": {
      "简中": "停止中",
      "繁中": "停止中",
      "English": "Stopping",
      "日本語": "停止中"
    },
    "任务中": {
      "简中": "任务中",
      "繁中": "任務中",
      "English": "In Progress",
      "日本語": "実行中"
    },
    "无任务": {
      "简中": "无任务",
      "繁中": "無任務",
      "English": "No tasks",
      "日本語": "タスクなし"
    },
    "累计时间": {
      "简中": "累计时间",
      "繁中": "累計時間",
      "English": "Total time",
      "日本語": "累積時間"
    },
    "剩余时间": {
      "简中": "剩余时间",
      "繁中": "剩餘時間",
      "English": "Remaining time",
      "日本語": "残り時間"
    },
    "行数统计": {
      "简中": "行数统计",
      "繁中": "行數統計",
      "English": "Line Count",
      "日本語": "行数統計"
    },
    "已完成": {
      "简中": "已完成",
      "繁中": "已完成",
      "English": "Completed",
      "日本語": "完了"
    },
    "剩余": {
      "简中": "剩余",
      "繁中": "剩餘",
      "English": "Remaining",
      "日本語": "残り"
    },
    "波形图": {
      "简中": "波形图",
      "繁中": "波形圖",
      "English": "Waveform",
      "日本語": "波形図"
    },
    "翻译行数": {
      "简中": "翻译行数",
      "繁中": "翻譯行數",
      "English": "Translated lines",
      "日本語": "翻訳行数"
    },
    "剩余行数": {
      "简中": "剩余行数",
      "繁中": "剩餘行數",
      "English": "Remaining lines",
      "日本語": "残り行数"
    },
    "平均速度": {
      "简中": "平均速度",
      "繁中": "平均速度",
      "English": "Average speed",
      "日本語": "平均速度"
    },
    "累计消耗": {
      "简中": "累计消耗",
      "繁中": "累計消耗",
      "English": "Total consumption",
      "日本語": "累積消費"
    },
    "实时任务数": {
      "简中": "实时任务数",
      "繁中": "即時任務數",
      "English": "Active tasks",
      "日本語": "アクティブタスク数"
    },
    "任务稳定性": {
      "简中": "任务稳定性",
      "繁中": "任務穩定性",
      "English": "Stability",
      "日本語": "安定性"
    }
  }
}


================================================
FILE: Resource/Localization/OutputSettings.json
================================================
[Binary file]


================================================
FILE: Resource/Localization/PolishingSettings.json
================================================
{
  "PART_1": { 
    "参考上文行数": {
      "简中": "参考上文行数",
      "繁中": "參考上文行數",
      "English": "Context Lines Above",
      "日本語": "上文参照行数"
    },
    "行数不宜设置过大，建议10行以内": {
      "简中": "行数不宜设置过大，建议10行以内",
      "繁中": "行數不宜設定過大，建議10行以內",
      "English": "Keep line count moderate (recommended ≤10)",
      "日本語": "行数は過大設定せず10行以内を推奨"
    },
    "润色模式选择": {
      "简中": "润色模式选择",
      "繁中": "潤飾模式選擇",
      "English": "Polishing Scope",
      "日本語": "推敲範囲選択"
    },
    "选择需要润色的文本范围\n选择【原文】将润色原文文本，原文不需要翻译情况下使用\n选择【译文】将润色译文文本，在原文翻译完成后再使用": {
      "简中": "选择需要润色的文本范围\n选择【原文】将润色原文文本（原文不需要翻译时使用）\n选择【译文】将润色译文文本（原文翻译完成后使用）",
      "繁中": "選取需要潤飾的文本範圍\n選擇【原文】將潤飾原始文本（原始文本不需翻譯時使用）\n選擇【譯文】將潤飾譯文文本（原文翻譯完成後使用）",
      "English": "Select text range to polish\nChoose [Source] to polish original text (use when no translation needed)\nChoose [Translation] to polish translated text (use after source is translated)",
      "日本語": "編集範囲を選択\n【原文】選択時は原文をリライト（翻訳不要な場合に使用）\n【訳文】選択時は訳文をリライト（原文翻訳後に使用）"
    },
    "原文": {
      "简中": "原文",
      "繁中": "原文",
      "English": "Source",
      "日本語": "原文"
    },
    "译文": {
      "简中": "译文",
      "繁中": "譯文",
      "English": "Translation",
      "日本語": "訳文"
    }
  }
}


================================================
FILE: Resource/Localization/PromptSettings.json
================================================
{
  "PART_1": {
    "编辑": {
      "简中": "编辑",
      "繁中": "編輯",
      "English": "Edit",
      "日本語": "編集"
    },
    "删除": {
      "简中": "删除",
      "繁中": "刪除",
      "English": "Delete",
      "日本語": "削除"
    },
    "系统预设": {
      "简中": "系统预设",
      "繁中": "系統預設",
      "English": "System Preset",
      "日本語": "システムプリセット"
    },
    "保存": {
      "简中": "保存",
      "繁中": "儲存",
      "English": "Save",
      "日本語": "保存"
    },
    "卡片名称:": {
      "简中": "卡片名称:",
      "繁中": "卡片名稱:",
      "English": "Card Name:",
      "日本語": "カード名:"
    },
    "提示词内容:": {
      "简中": "提示词内容:",
      "繁中": "提示詞內容:",
      "English": "Prompt Content:",
      "日本語": "プロンプト内容:"
    },
    "当前提示词": {
      "简中": "当前提示词",
      "繁中": "目前提示詞",
      "English": "Current Prompt",
      "日本語": "現在のプロンプト"
    },
    "名称：": {
      "简中": "名称：",
      "繁中": "名稱：",
      "English": "Name:",
      "日本語": "名称："
    },
    "提示词广场": {
      "简中": "提示词广场",
      "繁中": "提示詞廣場",
      "English": "Prompt Plaza",
      "日本語": "プロンプト広場"
    },
    "创建新提示词": {
      "简中": "创建新提示词",
      "繁中": "建立新提示詞",
      "English": "Create New Prompt",
      "日本語": "新規プロンプト作成"
    },
    "通用": {
      "简中": "通用",
      "繁中": "通用",
      "English": "General",
      "日本語": "一般"
    },
    "思维链": {
      "简中": "思维链",
      "繁中": "思維鏈",
      "English": "Chain of Thought",
      "日本語": "思考チェーン"
    },
    "推理模型": {
      "简中": "推理模型",
      "繁中": "推理模型",
      "English": "Reasoning Model",
      "日本語": "推論モデル"
    }

  },
  "PART_2": {
    "数据已保存": {
      "简中": "数据已保存",
      "繁中": "數據已儲存",
      "English": "Data saved",
      "日本語": "データ保存済み"
    },
    "保存": {
      "简中": "保存",
      "繁中": "儲存",
      "English": "Save",
      "日本語": "保存"
    },
    "是否确认重置为默认数据": {
      "简中": "是否确认重置为默认数据",
      "繁中": "是否確認重置為預設數據",
      "English": "Confirm reset to default data?",
      "日本語": "デフォルトデータにリセットしてもよろしいですか？"
    },
    "确认": {
      "简中": "确认",
      "繁中": "確認",
      "English": "Confirm",
      "日本語": "確認"
    },
    "取消": {
      "简中": "取消",
      "繁中": "取消",
      "English": "Cancel",
      "日本語": "キャンセル"
    },
    "数据已重置": {
      "简中": "数据已重置",
      "繁中": "數據已重置",
      "English": "Data reset",
      "日本語": "データリセット済み"
    },
    "重置": {
      "简中": "重置",
      "繁中": "重置",
      "English": "Reset",
      "日本語": "リセット"
    },
    "插入行": {
      "简中": "插入行",
      "繁中": "插入行",
      "English": "Insert row",
      "日本語": "行を挿入"
    },
    "删除行": {
      "简中": "删除行",
      "繁中": "刪除列",
      "English": "Delete Row",
      "日本語": "行を削除"
    },
    "新行已插入": {
      "简中": "新行已插入",
      "繁中": "新行已插入",
      "English": "New row inserted",
      "日本語": "新しい行が挿入されました"
    },
    "移除选取行": {
      "简中": "移除选取行",
      "繁中": "移除選取行",
      "English": "Remove selected row",
      "日本語": "選択行を削除"
    },
    "选取行已移除": {
      "简中": "选取行已移除",
      "繁中": "選取行已移除",
      "English": "Selected row removed",
      "日本語": "選択行が削除されました"
    }
  },
  "PART_3": {
    "自定义角色介绍": {
      "简中": "自定义角色介绍",
      "繁中": "自訂角色介紹",
      "English": "Custom character introduction",
      "日本語": "カスタムキャラクター紹介"
    },
    "启用此功能后，将根据本页中设置的构建角色介绍，并补充到基础提示词中（不支持本地类模型）": {
      "简中": "启用此功能后，将根据本页中设置的构建角色介绍，并补充到基础提示词中（不支持本地类模型）",
      "繁中": "啟用此功能後，將根據本頁中設定的構建角色介紹，並補充到基礎提示詞中（不支援本地類模型）",
      "English": "When enabled, character introduction will be built based on the settings on this page and added to the basic prompt (local models are not supported)",
      "日本語": "この機能を有効にすると、このページの設定に基づいてキャラクター紹介が構築され、基本プロンプトに追加されます（ローカルモデルはサポートされていません）"
    },
    "原名": {
      "简中": "原名",
      "繁中": "原名",
      "English": "Original name",
      "日本語": "原名"
    },
    "译名": {
      "简中": "译名",
      "繁中": "譯名",
      "English": "Translated name",
      "日本語": "訳名"
    },
    "性别": {
      "简中": "性别",
      "繁中": "性別",
      "English": "Gender",
      "日本語": "性別"
    },
    "年龄": {
      "简中": "年龄",
      "繁中": "年齡",
      "English": "Age",
      "日本語": "年齢"
    },
    "性格": {
      "简中": "性格",
      "繁中": "性格",
      "English": "Personality",
      "日本語": "性格"
    },
    "说话风格": {
      "简中": "说话风格",
      "繁中": "說話風格",
      "English": "Speaking style",
      "日本語": "話し方"
    },
    "补充信息": {
      "简中": "补充信息",
      "繁中": "補充資訊",
      "English": "Additional information",
      "日本語": "補足情報"
    },
    "选择文件": {
      "简中": "选择文件",
      "繁中": "選擇檔案",
      "English": "Select file",
      "日本語": "ファイルを選択"
    },
    "数据已导入": {
      "简中": "数据已导入",
      "繁中": "數據已導入",
      "English": "Data imported",
      "日本語": "データインポート済み"
    },
    "导入": {
      "简中": "导入",
      "繁中": "導入",
      "English": "Import",
      "日本語": "インポート"
    },
    "导出_角色介绍": {
      "简中": "导出_角色介绍",
      "繁中": "導出_角色介紹",
      "English": "Export_Character Introduction",
      "日本語": "エクスポート_キャラクター紹介"
    },
    "导出_翻译示例": {
      "简中": "导出_翻译示例",
      "繁中": "導出_翻譯範例",
      "English": "Export_Translation Example",
      "日本語": "エクスポート_翻訳例"
    },
    "数据已导出到应用根目录": {
      "简中": "数据已导出到应用根目录",
      "繁中": "數據已導出到應用程式根目錄",
      "English": "Data exported to application root directory",
      "日本語": "データはアプリケーションのルートディレクトリにエクスポートされました"
    },
    "导出": {
      "简中": "导出",
      "繁中": "導出",
      "English": "Export",
      "日本語": "エクスポート"
    },
    "新行已添加": {
      "简中": "新行已添加",
      "繁中": "新行已新增",
      "English": "New row added",
      "日本語": "新しい行が追加されました"
    },
    "添加": {
      "简中": "添加",
      "繁中": "新增",
      "English": "Add",
      "日本語": "追加"
    },
    "数据已保存": {
      "简中": "数据已保存",
      "繁中": "數據已儲存",
      "English": "Data saved",
      "日本語": "データ保存済み"
    },
    "保存": {
      "简中": "保存",
      "繁中": "儲存",
      "English": "Save",
      "日本語": "保存"
    },
    "是否确认重置为默认数据": {
      "简中": "是否确认重置为默认数据",
      "繁中": "是否確認重置為預設數據",
      "English": "Confirm reset to default data?",
      "日本語": "デフォルトデータにリセットしてもよろしいですか？"
    },
    "确认": {
      "简中": "确认",
      "繁中": "確認",
      "English": "Confirm",
      "日本語": "確認"
    },
    "取消": {
      "简中": "取消",
      "繁中": "取消",
      "English": "Cancel",
      "日本語": "キャンセル"
    },
    "数据已重置": {
      "简中": "数据已重置",
      "繁中": "數據已重置",
      "English": "Data reset",
      "日本語": "データリセット済み"
    },
    "重置": {
      "简中": "重置",
      "繁中": "重置",
      "English": "Reset",
      "日本語": "リセット"
    }
  },
  "PART_4": {
    "自定义背景设定": {
      "简中": "自定义背景设定",
      "繁中": "自訂背景設定",
      "English": "Custom background setting",
      "日本語": "カスタム背景設定"
    },
    "启用此功能后，将根据本页中设置的内容构建背景设定提示，并补充到基础提示词中（不支持本地类模型）": {
      "简中": "启用此功能后，将根据本页中设置的内容构建背景设定提示，并补充到基础提示词中（不支持本地类模型）",
      "繁中": "啟用此功能後，將根據本頁中設定的內容構建背景設定提示，並補充到基礎提示詞中（不支援本地類模型）",
      "English": "When enabled, background setting prompt will be built based on the settings on this page and added to the basic prompt (local models are not supported)",
      "日本語": "この機能を有効にすると、このページの設定に基づいて背景設定プロンプトが構築され、基本プロンプトに追加されます（ローカルモデルはサポートされていません）"
    },
    "自定义翻译风格": {
      "简中": "自定义翻译风格",
      "繁中": "自訂翻譯風格",
      "English": "Custom translation style",
      "日本語": "カスタム翻訳スタイル"
    },
    "启用此功能后，将根据本页中设置的内容构建翻译风格要求，并补充到基础提示词中（不支持本地类模型）": {
      "简中": "启用此功能后，将根据本页中设置的内容构建翻译风格要求，并补充到基础提示词中（不支持本地类模型）",
      "繁中": "啟用此功能後，將根據本頁中設定的內容構建翻譯風格要求，並補充到基礎提示詞中（不支援本地類模型）",
      "English": "When enabled, translation style requirement will be built based on the settings on this page and added to the basic prompt (local models are not supported)",
      "日本語": "この機能を有効にすると、このページの設定に基づいて翻訳スタイルの要求が構築され、基本プロンプトに追加されます（ローカルモデルはサポートされていません）"
    },
    "自定义润色风格": {
      "简中": "自定义润色风格",
      "繁中": "自訂潤飾風格",
      "English": "Custom Polishing Style",
      "日本語": "カスタム推敲スタイル"
    },
    "启用此功能后，将根据本页中设置的内容构建润色风格要求，并补充到基础提示词中": {
      "简中": "启用此功能后，将根据本页中设置的内容构建润色风格要求，并补充到基础提示词中",
      "繁中": "啟用此功能後，將根據本頁設定內容建構潤飾風格要求，並補充至基礎提示詞",
      "English": "When enabled, builds polishing style requirements based on this page's settings and appends to basic prompts",
      "日本語": "有効時、本ページの設定に基づき推敲スタイル要求を構築し、基本プロンプトに追加"
    },
    "自定义翻译示例": {
      "简中": "自定义翻译示例",
      "繁中": "自訂翻譯範例",
      "English": "Custom translation example",
      "日本語": "カスタム翻訳例"
    },
    "启用此功能后，将根据本页中设置的内容构建翻译示例，并补充到基础提示词中（不支持本地类模型）": {
      "简中": "启用此功能后，将根据本页中设置的内容构建翻译示例，并补充到基础提示词中（不支持本地类模型）",
      "繁中": "啟用此功能後，將根據本頁中設定的內容構建翻譯範例，並補充到基礎提示詞中（不支援本地類模型）",
      "English": "When enabled, translation example will be built based on the settings on this page and added to the basic prompt (local models are not supported)",
      "日本語": "この機能を有効にすると、このページの設定に基づいて翻訳例が構築され、基本プロンプトに追加されます（ローカルモデルはサポートされていません）"
    }
  }
}


================================================
FILE: Resource/Localization/StartupPage.json
================================================
{
"PART_1": { 
    "书籍": {
      "简中": "书籍",
      "繁中": "書籍",
      "English": "Books",
      "日本語": "書籍"
    },
    "文档": {
      "简中": "文档",
      "繁中": "文件",
      "English": "Documents",
      "日本語": "ドキュメント"
    },
    "字幕": {
      "简中": "字幕",
      "繁中": "字幕",
      "English": "Subtitles",
      "日本語": "字幕"
    },
    "游戏": {
      "简中": "游戏",
      "繁中": "遊戲",
      "English": "Games",
      "日本語": "ゲーム"
    },
    "数据文件": {
      "简中": "数据文件",
      "繁中": "資料檔案",
      "English": "Data Files",
      "日本語": "データファイル"
    },
    "复杂文档": {
      "简中": "复杂文档",
      "繁中": "複雜文件",
      "English": "Complex Documents",
      "日本語": "複雑文書"
    },
    "工程文件": {
      "简中": "工程文件",
      "繁中": "工程檔案",
      "English": "Project Files",
      "日本語": "プロジェクトファイル"
    },
    "当前路径": {
      "简中": "当前路径",
      "繁中": "當前路徑",
      "English": "Current Path",
      "日本語": "現在のパス"
    },
    "拖拽/选择输入文件夹": {
      "简中": "拖拽/选择输入文件夹",
      "繁中": "拖曳/選擇輸入資料夾",
      "English": "Drag & Drop / Select Input Folder",
      "日本語": "ドラッグ＆ドロップ/入力フォルダーを選択"
    },
    "直接读取": {
      "简中": "直接读取",
      "繁中": "直接讀取",
      "English": "Direct Read",
      "日本語": "ダイレクト読み取り"
    }
  },
"PART_2": { 
    "继续项目": {
      "简中": "继续项目",
      "繁中": "繼續專案",
      "English": "Continue Project",
      "日本語": "プロジェクトを続ける"
    },
    "加载上次的项目缓存并继续": {
      "简中": "加载上次的项目缓存并继续",
      "繁中": "載入上次的專案快取並繼續",
      "English": "Load Last Project Cache & Continue",
      "日本語": "前回のプロジェクトキャッシュを読み込み続行"
    },
    "文件/目录排除规则":{
      "简中": "文件/目录排除规则",
      "繁中": "檔案/目錄排除規則",
      "English": "Input file/directory exclusion rules",
      "日本語": "ファイル/ディレクトリ除外ルールを入力"
    },
    "*.log 表示排除所有结尾为 .log 的文件，aaa/* 表示排除输入文件夹下整个 aaa 目录，多个规则用英文逗号分隔":{
      "简中": "*.log 表示排除所有结尾为 .log 的文件，aaa/* 表示排除输入文件夹下整个 aaa 目录，多个规则用英文逗号分隔",
      "繁中": "*.log 表示排除所有結尾為 .log 的檔案，aaa/* 表示排除輸入資料夾下整個 aaa 目錄，多個規則用英文逗號分隔",
      "English": "*.log means excluding all files ending with .log. aaa/* means excluding the entire aaa directory under the input folder.\n Multiple rules should be separated by English commas.",
      "日本語": "*.log は .log で終わるすべてのファイルを除外し、aaa/* は入力フォルダ内の aaa ディレクトリ全体を除外します\n複数のルールは英語のカンマで区切ってください"
    },
    "项目类型": {
      "简中": "项目类型",
      "繁中": "專案類型",
      "English": "Project Type",
      "日本語": "プロジェクトタイプ"
    },
    "设置当前翻译项目所使用的原始文本的格式，注意，选择错误将不能进行翻译": {
      "简中": "设置当前翻译项目所使用的原始文本的格式，注意，选择错误将不能进行翻译",
      "繁中": "設定當前翻譯專案使用的原始文字格式，請注意：選擇錯誤將無法進行翻譯",
      "English": "Set source text format for current translation project.\nWarning: Incorrect selection will prevent translation.",
      "日本語": "現在の翻訳プロジェクトで使用する原文の形式を設定\n注意：誤った選択をすると翻訳できません"
    }
  },
  "project_pairs": {
    "Txt": {
      "简中": "Txt小说文件",
      "繁中": "Txt小說檔案",
      "English": "Txt Novel File",
      "日本語": "Txt小説ファイル"
    },
    "Epub": {
      "简中": "Epub小说文件",
      "繁中": "Epub小說檔案",
      "English": "Epub Novel File",
      "日本語": "Epub小説ファイル"
    },
    "Docx": {
      "简中": "Docx文档文件",
      "繁中": "Docx文件檔案",
      "English": "Docx Document File",
      "日本語": "Docxドキュメントファイル"
    },
    "Srt": {
      "简中": "Srt字幕文件",
      "繁中": "Srt字幕檔案",
      "English": "SRT Subtitle File",
      "日本語": "SRT字幕ファイル"
    },
    "Vtt": {
      "简中": "Vtt字幕文件",
      "繁中": "Vtt字幕檔案",
      "English": "VTT Subtitle File",
      "日本語": "VTT字幕ファイル"
    },
    "Ass": {
      "简中": "Ass字幕文件",
      "繁中": "Ass字幕檔案",
      "English": "ASS Subtitle File",
      "日本語": "ASS字幕ファイル"
    },
    "Lrc": {
      "简中": "Lrc音声文件",
      "繁中": "Lrc歌詞檔案",
      "English": "LRC Lyrics File",
      "日本語": "LRC歌詞ファイル"
    },
    "Md": {
      "简中": "Md文档文件",
      "繁中": "Md文件檔案",
      "English": "Md Document File",
      "日本語": "Mdドキュメントファイル"
    },
    "Tpp": {
      "简中": "T++导出文件",
      "繁中": "T++導出檔案",
      "English": "T++ Export File",
      "日本語": "T++エクスポートファイル"
    },
    "Trans": {
      "简中": "Trans工程文件",
      "繁中": "Trans工程檔案",
      "English": "Trans Project Files",
      "日本語": "Transプロジェクトファイル"
    },
    "Mtool": {
      "简中": "Mtool导出文件",
      "繁中": "Mtool導出檔案",
      "English": "Mtool Export File",
      "日本語": "Mtoolエクスポートファイル"
    },
    "Renpy": {
      "简中": "Renpy导出文件",
      "繁中": "Renpy導出檔案",
      "English": "Renpy Export File",
      "日本語": "Renpyエクスポートファイル"
    },
    "Vnt": {
      "简中": "VNText导出文件",
      "繁中": "VNText導出檔案",
      "English": "VNText Export File",
      "日本語": "VNTextエクスポートファイル"
    },
    "I18next": {
      "简中": "I18Next数据文件",
      "繁中": "I18Next數據文件",
      "English": "I18Next Data File",
      "日本語": "I18Nextデータファイル"
    },
    "Po": {
      "简中": "Po数据文件",
      "繁中": "Po數據文件",
      "English": "Po Data File",
      "日本語": "Poデータファイル"
    },
    "Paratranz": {
      "简中": "ParaTranz导出文件",
      "繁中": "ParaTranz導出檔案",
      "English": "ParaTranz Export File",
      "日本語": "ParaTranzエクスポートファイル"
    },
    "OfficeConversionDoc": {
      "简中": "Doc文档文件 (需要Microsoft Office)",
      "繁中": "Doc文件檔案 (需要Microsoft Office)",
      "English": "Doc Document File (requires Microsoft Office)",
      "日本語": "Docドキュメントファイル (Microsoft Officeが必要)"
    },
    "BabeldocPdf": {
      "简中": "Pdf文档文件 (pdf2zh/BabelDOC)",
      "繁中": "Pdf文件檔案 (pdf2zh/BabelDOC)",
      "English": "Pdf Document File (pdf2zh/BabelDOC)",
      "日本語": "Pdfドキュメントファイル (pdf2zh/BabelDOC)"
    },
    "AutoType": {
      "简中": "自动识别文件类型",
      "繁中": "自動識別檔案類型",
      "English": "Automatically identify file types",
      "日本語": "自動的にファイルタイプを識別する"
    }
  },
  "PART_3": { 
      "正在加载项目...": {
        "简中": "正在加载项目...",
        "繁中": "正在加載項目...",
        "English": "Loading project...",
        "日本語": "プロジェクトを読み込み中..."
      },
      "客官请耐心等待哦~~": {
        "简中": "客官请耐心等待哦~~",
        "繁中": "客倌請耐心等候唷~~",
        "English": "Please wait patiently~~",
        "日本語": "少々お待ちくださいね~~"
      },
      "项目加载成功！": {
        "简中": "项目加载成功！",
        "繁中": "項目載入成功！",
        "English": "Project loaded successfully!",
        "日本語": "プロジェクトの読み込みに成功しました！"
      },
      "加载失败...": {
        "简中": "加载失败...",
        "繁中": "載入失敗...",
        "English": "Loading failed...",
        "日本語": "読み込みに失敗しました..."
      },
      "错误": {
        "简中": "错误",
        "繁中": "錯誤",
        "English": "Error",
        "日本語": "エラー"
      }
    }
}


================================================
FILE: Resource/Localization/TableSettings.json
================================================
{
  "PART_1": {
    "术语表": {
      "简中": "术语表",
      "繁中": "術語表",
      "English": "Glossary",
      "日本語": "用語集"
    },
    "通过构建术语表来引导模型翻译，可实现统一翻译、补充信息等功能\n△触发机制: 文本含有原名  ◯填写示例:  ダリヤ  |  达莉雅  |  女性的名字": {
      "简中": "通过构建术语表来引导模型翻译，可实现统一翻译、补充信息等功能\n△触发机制: 文本含有原名  ◯填写示例:  ダリヤ  |  达莉雅  |  女性的名字",
      "繁中": "透過建立術語表來引導模型翻譯，可實現統一翻譯、補充資訊等功能。\n△觸發機制：文本含有來源術語。  ◯範例：ダリヤ  |  達莉雅  |  女性的名字",
      "English": "Use a glossary to guide model translation for consistent translations, supplementary info, etc.\n△Trigger: When the text contains the source term.  ◯Example: ダリヤ  |  Dahlia  |  Female name",
      "日本語": "用語集を構築してモデル翻訳を誘導し、翻訳の統一や情報補足などを実現します。\n△トリガー：テキストに元の用語が含まれている場合。  ◯例： 达莉雅  |  ダリヤ  |  女性の名前"
    },
    "原文": {
      "简中": "原文",
      "繁中": "原文",
      "English": "Original Text",
      "日本語": "原文"
    },
    "译文": {
      "简中": "译文",
      "繁中": "譯文",
      "English": "Translation",
      "日本語": "翻訳文"
    },
    "描述": {
      "简中": "描述",
      "繁中": "描述",
      "English": "Description",
      "日本語": "説明"
    },
    "导出_术语表": {
      "简中": "导出_术语表",
      "繁中": "導出_術語表",
      "English": "Export Glossary",
      "日本語": "用語集をエクスポート"
    },
    "角色提取": {
      "简中": "角色提取",
      "繁中": "角色提取",
      "English": "Role Extraction",
      "日本語": "役割抽出"
    },
    "简单翻译": {
      "简中": "简单翻译",
      "繁中": "簡單翻譯",
      "English": "Simple Translation",
      "日本語": "簡単翻訳"
    },
    "术语表内容为空": {
      "简中": "术语表内容为空",
      "繁中": "術語表內容為空",
      "English": "Glossary is Empty",
      "日本語": "用語集が空です"
    },    
    "术语信息已提取": {
      "简中": "术语信息已提取",
      "繁中": "術語信息已提取",
      "English": "Term Information Extracted",
      "日本語": "用語情報が抽出されました"
    },
    "术语表翻译失败": {
      "简中": "术语表翻译失败",
      "繁中": "術語表翻譯失敗",
      "English": "Glossary Translation Failed",
      "日本語": "用語集の翻訳に失敗しました"
    },
    "术语表翻译成功": {
      "简中": "术语表翻译成功",
      "繁中": "術語表翻譯成功",
      "English": "Glossary Translation Successful",
      "日本語": "用語集の翻訳に成功しました"
    },
    "全部": {
      "简中": "全部",
      "繁中": "全部",
      "English": "All",
      "日本語": "全て"
    },
    "提示": {
      "简中": "提示",
      "繁中": "提示",
      "English": "Notice",
      "日本語": "通知"
    },
    "全部行数": {
      "简中": "全部行数",
      "繁中": "全部行數",
      "English": "Total Lines",
      "日本語": "全行数"
    },
    "原文本": {
      "简中": "原文本",
      "繁中": "原文",
      "English": "Source Text",
      "日本語": "原文"
    },
    "目标文本": {
      "简中": "目标文本",
      "繁中": "目標文本",
      "English": "Target Text",
      "日本語": "訳文"
    },
    "搜索表格内容...": {
      "简中": "搜索表格内容...",
      "繁中": "搜尋表格內容...",
      "English": "Search table content...",
      "日本語": "表内を検索..."
    },
    "上一个结果": {
      "简中": "上一个结果",
      "繁中": "上一個結果",
      "English": "Previous result",
      "日本語": "前の結果"
    },
    "下一个结果": {
      "简中": "下一个结果",
      "繁中": "下一個結果",
      "English": "Next result",
      "日本語": "次の結果"
    },
    "在指定文件夹中未找到符合条件的角色名": {
      "简中": "在指定文件夹中未找到符合条件的角色名",
      "繁中": "在指定資料夾中未找到符合條件的角色名稱",
      "English": "No matching character names found in the specified folder",
      "日本語": "指定フォルダに該当するキャラクター名が見つかりません"
    },
    "均已存在于术语表中": {
      "简中": "均已存在于术语表中",
      "繁中": "均已存在於術語表中",
      "English": "All already exist in the glossary",
      "日本語": "全て用語集に既に存在しています"
    },
    "术语信息已提取并添加": {
      "简中": "术语信息已提取并添加",
      "繁中": "術語資訊已提取並添加",
      "English": "Term information has been extracted and added",
      "日本語": "用語情報を抽出し追加しました"
    },
    "提取失败": {
      "简中": "提取失败",
      "繁中": "提取失敗",
      "English": "Extraction failed",
      "日本語": "抽出に失敗しました"
    },
    "没有需要翻译的术语": {
      "简中": "没有需要翻译的术语",
      "繁中": "沒有需要翻譯的術語",
      "English": "No terms need translation",
      "日本語": "翻訳が必要な用語はありません"
    },
    "术语表翻译任务已开始...": {
      "简中": "术语表翻译任务已开始...",
      "繁中": "術語表翻譯任務已開始...",
      "English": "Glossary translation task has started...",
      "日本語": "用語集翻訳タスクを開始しました..."
    },
    "翻译完成，但没有数据被更新": {
      "简中": "翻译完成，但没有数据被更新",
      "繁中": "翻譯完成，但沒有資料被更新",
      "English": "Translation completed but no data was updated",
      "日本語": "翻訳は完了しましたが、データは更新されませんでした"
    }
  },

  "PART_2": {
    "禁翻表": {
      "简中": "禁翻表",
      "繁中": "禁譯表",
      "English": "Do Not Translate List",
      "日本語": "禁翻リスト"
    },
    "通过构建禁翻表来引导模型，禁止翻译文本中的特殊标记符，占位符，代码段等内容\n△触发机制: 文本含有标记符，或者正则表达式匹配生效  ◯填写示例:  //F[N1]  |  游戏文本标记符号  |  //[A-Z]\\[.*?\\]": {
      "简中": "通过构建禁翻表来引导模型，禁止翻译文本中的特殊标记符，占位符，代码段等内容\n△触发机制: 文本含有标记符，或者正则表达式匹配生效。  ◯填写示例:  //F[N1]  |  游戏文本标记符号  |  //[A-Z]\\[.*?\\]",
      "繁中": "透過構建禁翻表來引導模型，禁止翻譯文本中的特殊標記符、佔位符、代碼段等內容。\n△觸發機制：當文本含有指定標記符，或符合正則表達式時觸發。  ◯示例：//F[N1]  |  遊戲文本標記符  |  //[A-Z]\\[.*?\\] ",
      "English": "Build a 'Do Not Translate' list to guide the model, preventing translation of specific elements like special markers, placeholders, and code snippets.  ◯Trigger: Activates when text contains specified markers or matches a regular expression.\nExample: //F[N1]  |  Game text marker  |  //[A-Z]\\[.*?\\]",
      "日本語": "翻訳禁止リストを作成してモデルを誘導し、テキスト内の特殊マーカー、プレースホルダー、コード断片などの翻訳を防止します。\n△トリガー：テキストに指定マーカーが含まれるか、正規表現に一致した場合に作動。  ◯例：//F[N1]  |  ゲームテキストマーカー  |  //[A-Z]\\[.*?\\]"
    },
    "标记符": {
      "简中": "标记符",
      "繁中": "標記符",
      "English": "Marker",
      "日本語": "マーカー"
    },
    "备注": {
      "简中": "备注",
      "繁中": "備註",
      "English": "Notes",
      "日本語": "備考"
    },
    "正则": {
      "简中": "正则",
      "繁中": "正則",
      "English": "Regex",
      "日本語": "正規表現"
    },
    "导出_禁翻表": {
      "简中": "导出_禁翻表",
      "繁中": "導出_禁譯表",
      "English": "Export Do Not Translate List",
      "日本語": "禁翻リストをエクスポート"
    }
  },

  "PART_3": {
    "译前替换": {
      "简中": "译前替换",
      "繁中": "譯前替換",
      "English": "Pre-translation Replacement",
      "日本語": "翻訳前置換"
    },
    "在翻译开始前，将原文中匹配的部分替换为指定的文本，执行的顺序为从上到下依次替换": {
      "简中": "在翻译开始前，将原文中匹配的部分替换为指定的文本，执行的顺序为从上到下依次替换",
      "繁中": "在翻譯開始前，將原文中匹配的部分替換為指定的文本，執行的順序為從上到下依次替換",
      "English": "Before translation, replace matched text in the original with specified text, sequentially from top to bottom.",
      "日本語": "翻訳開始前に、原文の一致箇所を指定テキストに置換します。上から順に実行されます。"
    },
    "导出_译前替换": {
      "简中": "导出_译前替换",
      "繁中": "導出_譯前替換",
      "English": "Export Pre-translation Replacement",
      "日本語": "翻訳前置換をエクスポート"
    },
    "译后替换": {
      "简中": "译后替换",
      "繁中": "譯後替換",
      "English": "Post-translation Replacement",
      "日本語": "翻訳後置換"
    },
    "在翻译完成后，将译文中匹配的部分替换为指定的文本，执行的顺序为从上到下依次替换": {
      "简中": "在翻译完成后，将译文中匹配的部分替换为指定的文本，执行的顺序为从上到下依次替换",
      "繁中": "在翻譯完成後，將譯文中匹配的部分替換為指定的文本，執行的順序為從上到下依次替換",
      "English": "After translation, replace matched text in the translation with specified text, sequentially from top to bottom.",
      "日本語": "翻訳完了後、訳文の一致箇所を指定テキストに置換します。上から順に実行されます。"
    },
    "导出_译后替换": {
      "简中": "导出_译后替换",
      "繁中": "導出_譯後替換",
      "English": "Export Post-translation Replacement",
      "日本語": "翻訳後置換をエクスポート"
    }
  }
}


================================================
FILE: Resource/Localization/TaskSettings.json
================================================
[Binary file]


================================================
FILE: Resource/Localization/TranslationChecker.json
================================================
{
  "PART_1": {
    "润色后文本": {
      "简中": "润色后文本",
      "繁中": "潤色後文本",
      "English": "polished text",
      "日本語": "リライトされたテキスト"
    },
    "翻译后文本": {
      "简中": "翻译后文本",
      "繁中": "翻譯後文本",
      "English": "translated text",
      "日本語": "翻訳されたテキスト"
    },
    "旧标记已清除。现在开始新的检查...": {
      "简中": "旧标记已清除。现在开始新的检查...",
      "繁中": "舊標記已清除。現在開始新的檢查...",
      "English": "Old markers cleared. Now starting a new check...",
      "日本語": "古いマーカーをクリアしました。新しいチェックを開始します..."
    },
    "正在清除旧的语言检查标记...": {
      "简中": "正在清除旧的语言检查标记...",
      "繁中": "正在清除舊的語言檢查標記...",
      "English": "Clearing old language check markers...",
      "日本語": "古い言語チェックマーカーをクリアしています..."
    },
    "开始检查项目的{}...": {
      "简中": "开始检查项目的{}...",
      "繁中": "開始檢查專案的{}...",
      "English": "Starting to check the project's {}...",
      "日本語": "プロジェクトの{}のチェックを開始しています..."
    },
    "模式: 精准判断，目标语言: {} ({})": {
      "简中": "模式: 精准判断，目标语言: {} ({})",
      "繁中": "模式：精準判斷，目標語言：{} ({})",
      "English": "Mode: Precise Judgment, Target Language: {} ({})",
      "日本語": "モード：精密判断、ターゲット言語：{} ({})"
    },
    "检测块大小: {}行, 块语言比例阈值: {:.0%}": {
      "简中": "检测块大小: {}行, 块语言比例阈值: {:.0%}",
      "繁中": "檢測塊大小：{}行，塊語言比例閾值：{:.0%}",
      "English": "Chunk Size: {} lines, Block Language Ratio Threshold: {:.0%}",
      "日本語": "チャンクサイズ：{}行、ブロック言語比率しきい値：{:.0%}"
    },
    "模式: 宏观统计【将报告每个文件的整体语言组成】": {
      "简中": "模式: 宏观统计【将报告每个文件的整体语言组成】",
      "繁中": "模式：宏觀統計【將報告每個檔案的整體語言組成】",
      "English": "Mode: Macro Statistics [Will report the overall language composition of each file]",
      "日本語": "モード：マクロ統計【各ファイルの全体的な言語構成を報告します】"
    },
    "语言检查完成，耗时 {:.2f} 秒": {
      "简中": "语言检查完成，耗时 {:.2f} 秒",
      "繁中": "語言檢查完成，耗時 {:.2f} 秒",
      "English": "Language check completed in {:.2f} seconds",
      "日本語": "言語チェック完了、所要時間 {:.2f} 秒"
    }
  },
  "PART_2": {
    "检查失败：无法将目标语言名称 '{}' 转换为有效的语言代码。请检查您的配置。": {
      "简中": "检查失败：无法将目标语言名称 '{}' 转换为有效的语言代码。请检查您的配置。",
      "繁中": "檢查失敗：無法將目標語言名稱 '{}' 轉換為有效的語言代碼。請檢查您的設定。",
      "English": "Check failed: Could not convert target language name '{}' to a valid language code. Please check your configuration.",
      "日本語": "チェック失敗：ターゲット言語名「{}」を有効な言語コードに変換できませんでした。設定を確認してください。"
    },
    "检查失败，请检查项目文件夹缓存是否正常": {
      "简中": "检查失败，请检查项目文件夹缓存是否正常",
      "繁中": "檢查失敗，請檢查專案資料夾快取是否正常",
      "English": "Check failed, please verify the project folder cache is valid.",
      "日本語": "チェックに失敗しました。プロジェクトフォルダのキャッシュが正常か確認してください。"
    },
    "检查失败，请先执行润色流程": {
      "简中": "检查失败，请先执行润色流程",
      "繁中": "檢查失敗，請先執行潤色流程",
      "English": "Check failed, please run the polishing process first.",
      "日本語": "チェックに失敗しました。先にリライト処理を実行してください。"
    },
    "检查失败，请先执行翻译流程": {
      "简中": "检查失败，请先执行翻译流程",
      "繁中": "檢查失敗，請先執行翻譯流程",
      "English": "Check failed, please run the translation process first.",
      "日本語": "チェックに失敗しました。先に翻訳処理を実行してください。"
    }
  },
  "PART_3": {
    "行 {}-{}": {
      "简中": "行 {}-{}",
      "繁中": "行 {}-{}",
      "English": "Lines {}-{}",
      "日本語": "行 {}-{}"
    },
    "检查通过：项目的所有文件 {} 均符合预期.": {
      "简中": "检查通过：项目的所有文件 {} 均符合预期.",
      "繁中": "檢查通過：專案的所有檔案 {} 均符合預期。",
      "English": "Check passed: All project files' {} meet expectations.",
      "日本語": "チェック合格：プロジェクトの全ファイルの {} は期待どおりです。"
    },
    "未在项目的 {} 中找到可供分析的文本内容.": {
      "简中": "未在项目的 {} 中找到可供分析的文本内容.",
      "繁中": "未在專案的 {} 中找到可供分析的文本內容。",
      "English": "No analyzable text content found in the project's {}.",
      "日本語": "プロジェクトの {} 内に分析可能なテキスト内容が見つかりませんでした。"
    },
    "检测到 {} 个文件的 {} 中存在语言比例异常的文本块.": {
      "简中": "检测到 {} 个文件的 {} 中存在语言比例异常的文本块.",
      "繁中": "偵測到 {} 個檔案的 {} 中存在語言比例異常的文本塊。",
      "English": "Detected text blocks with abnormal language ratios in the {} of {} file(s).",
      "日本語": "{}個のファイルの {} 内に、言語比率が異常なテキストブロックが検出されました。"
    },
    "目标语言 '{}' 占比低于 {:.0%} 的块将被列出.": {
      "简中": "目标语言 '{}' 占比低于 {:.0%} 的块将被列出.",
      "繁中": "目標語言 '{}' 佔比低於 {:.0%} 的塊將被列出。",
      "English": "Blocks where the target language '{}' ratio is below {:.0%} will be listed.",
      "日本語": "ターゲット言語「{}」の比率が {:.0%} 未満のブロックがリストアップされます。"
    },
    "以下是各文件的 {} 语言组成统计报告:": {
      "简中": "以下是各文件的 {} 语言组成统计报告:",
      "繁中": "以下是各檔案的 {} 語言組成統計報告：",
      "English": "The following is the language composition statistics report for each file's {}:",
      "日本語": "以下は各ファイルの {} の言語構成統計レポートです："
    },
    "▼ 文件: {} (类型: {}, 编码: {})": {
      "简中": "▼ 文件: {} (类型: {}, 编码: {})",
      "繁中": "▼ 檔案：{} (類型：{}, 編碼：{})",
      "English": "▼ File: {} (Type: {}, Encoding: {})",
      "日本語": "▼ ファイル：{} (タイプ：{}、エンコーディング：{})"
    },
    "  └─ 问题区块: {} (目标语言占比: {:.2%})": {
      "简中": "  └─ 问题区块: {} (目标语言占比: {:.2%})",
      "繁中": "  └─ 問題區塊：{} (目標語言佔比：{:.2%})",
      "English": "  └─ Problematic Block: {} (Target Language Ratio: {:.2%})",
      "日本語": "  └─ 問題のあるブロック：{} (ターゲット言語の割合：{:.2%})"
    },
    "    ├─ 行 {}: 检测为 [{}] (置信度: {:.2f}) -> \"{}...\"": {
      "简中": "    ├─ 行 {}: 检测为 [{}] (置信度: {:.2f}) -> \"{}...\"",
      "繁中": "    ├─ 行 {}: 檢測為 [{}] (信賴度: {:.2f}) -> \"{}...\"",
      "English": "    ├─ Line {}: Detected as [{}] (Confidence: {:.2f}) -> \"{}...\"",
      "日本語": "    ├─ 行 {}: 検出結果 [{}] (信頼度: {:.2f}) -> 「{}...」"
    },
    "文件: {}": {
      "简中": "文件: {}",
      "繁中": "檔案：{}",
      "English": "File: {}",
      "日本語": "ファイル：{}"
    },
    "  ├─ 类型: {}": {
      "简中": "  ├─ 类型: {}",
      "繁中": "  ├─ 類型：{}",
      "English": "  ├─ Type: {}",
      "日本語": "  ├─ タイプ：{}"
    },
    "  ├─ 编码: {}": {
      "简中": "  ├─ 编码: {}",
      "繁中": "  ├─ 編碼：{}",
      "English": "  ├─ Encoding: {}",
      "日本語": "  ├─ エンコーディング：{}"
    },
    "  └─ 语言统计: {}": {
      "简中": "  └─ 语言统计: {}",
      "繁中": "  └─ 語言統計：{}",
      "English": "  └─ Language Stats: {}",
      "日本語": "  └─ 言語統計：{}"
    }
  },
  "GENERAL_MESSAGES": {
    "开始语言检查": {
      "简中": "开始语言检查",
      "繁中": "開始語言檢查",
      "English": "Starting language check",
      "日本語": "言語チェックを開始"
    },
    "检查结果": {
      "简中": "检查结果",
      "繁中": "檢查結果",
      "English": "Check Result",
      "日本語": "チェック結果"
    },
    "检查失败，请检查项目文件夹缓存是否正常": {
      "简中": "检查失败，请检查项目文件夹缓存是否正常",
      "繁中": "檢查失敗，請檢查專案資料夾快取是否正常",
      "English": "Check failed. Please verify the project folder cache.",
      "日本語": "チェック失敗。プロジェクトフォルダのキャッシュが正常か確認してください。"
    },
    "检查失败，请先执行翻译流程": {
      "简中": "检查失败，请先执行翻译流程",
      "繁中": "檢查失敗，請先執行翻譯流程",
      "English": "Check failed. Please run the translation process first.",
      "日本語": "チェック失敗。先に翻訳プロセスを実行してください。"
    },
    "检查失败，请先执行润色流程": {
      "简中": "检查失败，请先执行润色流程",
      "繁中": "檢查失敗，請先執行潤色流程",
      "English": "Check failed. Please run the polishing process first.",
      "日本語": "チェック失敗。先に推敲プロセスを実行してください。"
    },
    "检测完成，请查看控制台输出": {
      "简中": "检测完成，请查看控制台输出",
      "繁中": "檢測完成，請查看控制臺輸出",
      "English": "Detection complete. Please check the console output.",
      "日本語": "検出完了。コンソールの出力を確認してください。"
    },
    "检查通过：项目的所有文件均符合设定译文预期": {
      "简中": "检查通过：项目的所有文件均符合设定译文预期",
      "繁中": "檢查通過：專案的所有檔案均符合設定譯文預期",
      "English": "Check passed: The translations in all project files meet the specified expectations.",
      "日本語": "チェック合格：プロジェクト内の全ファイルの翻訳が、設定された期待値を満たしています。"
    },
    "项目的所有文件译文语言占比不正常，请检查标记行和控制台输出": {
      "简中": "项目的所有文件译文语言占比不正常，请检查标记行和控制台输出",
      "繁中": "專案的所有檔案譯文語言佔比不正常，請檢查標記行和控制台輸出",
      "English": "The language distribution of translations in the project is abnormal. Please check the token lines and console output",
      "日本語": "プロジェクトの全ファイルにおける翻訳言語の比率が異常です。トークン行とコンソール出力を確認してください"
    },
    "标记已成功保存到缓存文件": {
      "简中": "标记已成功保存到缓存文件",
      "繁中": "標記已成功保存到快取檔案",
      "English": "Tokens saved to cache file successfully",
      "日本語": "トークンは正常にキャッシュファイルに保存されました"
    },
    "无法保存标记：输出路径 '{}' 未配置或无效": {
      "简中": "无法保存标记：输出路径 '{}' 未配置或无效",
      "繁中": "無法保存標記：輸出路徑 '{}' 未設定或無效",
      "English": "Failed to save tokens: output path '{}' is not configured or invalid",
      "日本語": "トークンの保存に失敗しました：出力パス '{}' が設定されていないか、無効です"
    },
    "保存标记到缓存时发生错误: {}": {
      "简中": "保存标记到缓存时发生错误: {}",
      "繁中": "保存標記到快取時發生錯誤: {}",
      "English": "Error while saving tokens to cache: {}",
      "日本語": "トークンをキャッシュに保存中にエラーが発生しました: {}"
    },
    "检测到语言不匹配项，正在将标记保存到磁盘": {
      "简中": "检测到语言不匹配项，正在将标记保存到磁盘",
      "繁中": "偵測到語言不符項，正在將標記保存到磁碟",
      "English": "Language mismatch detected, saving tokens to disk",
      "日本語": "言語の不一致が検出されたため、トークンをディスクに保存しています"
    },
      "开始执行规则检查...": {
      "简中": "开始执行规则检查...",
      "繁中": "開始執行規則檢查...",
      "English": "Starting rule check...",
      "日本語": "ルールチェックを開始しています..."
    },
    "规则检查完成，发现 {} 个问题。": {
      "简中": "规则检查完成，发现 {} 个问题。",
      "繁中": "規則檢查完成，發現 {} 個問題。",
      "English": "Rule check completed, found {} issues.",
      "日本語": "ルールチェックが完了しました。{} 個の問題が見つかりました。"
    },
    "语言比例异常": {
      "简中": "语言比例异常",
      "繁中": "語言比例異常",
      "English": "Abnormal language ratio",
      "日本語": "言語比率の異常"
    },
    "术语缺失: {}": {
      "简中": "术语缺失: {}",
      "繁中": "術語缺失: {}",
      "English": "Missing terminology: {}",
      "日本語": "用語の欠落: {}"
    },
    "禁翻表错误": {
      "简中": "禁翻表错误",
      "繁中": "禁翻表錯誤",
      "English": "Exclusion list error",
      "日本語": "除外リストエラー"
    },
    "自动处理错误": {
      "简中": "自动处理错误",
      "繁中": "自動處理錯誤",
      "English": "Auto-process error",
      "日本語": "自動処理エラー"
    },
    "占位符残留": {
      "简中": "占位符残留",
      "繁中": "佔位符殘留",
      "English": "Placeholder residue",
      "日本語": "プレースホルダーの残留"
    },
    "数字序号残留": {
      "简中": "数字序号残留",
      "繁中": "數字序號殘留",
      "English": "Number sequence residue",
      "日本語": "数字シーケンスの残留"
    },
    "示例文本复读": {
      "简中": "示例文本复读",
      "繁中": "範例文本複讀",
      "English": "Example text repetition",
      "日本語": "例文テキストの繰り返し"
    },
    "换行符错误": {
      "简中": "换行符错误",
      "繁中": "換行符錯誤",
      "English": "Newline character error",
      "日本語": "改行文字エラー"
    }
  }
}


================================================
FILE: Resource/Localization/TranslationSettings.json
================================================
{
  "PART_1": { 
    "原文语言": {
      "简中": "原文语言",
      "繁中": "原文語言",
      "English": "Source Language",
      "日本語": "原文言語"
    },
    "设置当前项目所使用的原始文本的语言": {
      "简中": "设置当前项目所使用的原始文本的语言",
      "繁中": "設定當前專案使用的原始文字語言",
      "English": "Set source text language for current project",
      "日本語": "現在のプロジェクトで使用する原文の言語を設定"
    },
    "译文语言": {
      "简中": "译文语言",
      "繁中": "譯文語言",
      "English": "Target Language",
      "日本語": "訳文言語"
    },
    "设置当前项目所期望的译文文本的语言": {
      "简中": "设置当前项目所期望的译文文本的语言",
      "繁中": "設定當前專案所期望的譯文文字語言",
      "English": "Set target text language for current project",
      "日本語": "現在のプロジェクトで使用する訳文の言語を設定"
    },
    "动态示例和预回复功能": {
      "简中": "动态示例和预回复功能",
      "繁中": "動態範例與預回覆功能",
      "English": "Dynamic Few-shot & Pre-reply",
      "日本語": "動的Few-shotと事前返答機能"
    },
    "将在构建整体的翻译提示词时，自动生成动态Few-shot和构建模型预回复内容，不支持本地接口": {
      "简中": "将在构建整体的翻译提示词时，自动生成动态Few-shot和构建模型预回复内容，不支持本地接口",
      "繁中": "建構整體翻譯提示詞時，將自動產生動態Few-shot及模型預回覆內容，不支援本地介面",
      "English": "Automatically generates dynamic Few-shot examples and model pre-replies when constructing translation prompts.\nNot supported for local APIs.",
      "日本語": "翻訳プロンプト構築時に動的Few-shotと事前返答を自動生成\nローカルインターフェースには非対応"
    },
    "参考上文行数": {
      "简中": "参考上文行数",
      "繁中": "參考上文行數", 
      "English": "Context Lines (lines above)", 
      "日本語": "コンテキスト行数 (上文)" 
    },
    "行数不宜设置过大，建议10行以内 (不支持本地类接口)": {
      "简中": "行数不宜设置过大，建议10行以内 (不支持本地类接口)",
      "繁中": "行數不宜設定過大，建議 10 行以內 (不支援本地類介面)", 
      "English": "Keep line count low, recommended ≤10 (Local APIs not supported)", 
      "日本語": "行数は大きく設定しないでください。10行以内を推奨 (ローカルAPIは非対応)"
    },
    "自动预处理文本": {
        "简中": "自动预处理文本",
        "繁中": "自動預處理文本",
        "English": "Automatic Text Preprocessing",
        "日本語": "テキスト自動前処理"
    },
    "启用此功能后，根据正则库与禁翻表，将在翻译前移除文本首尾的非翻译内容，占位文本中间的非翻译内容，并在翻译后还原": {
        "简中": "启用此功能后，根据正则库与禁翻表，将在翻译前移除文本首尾的非翻译内容，占位文本中间的非翻译内容，并在翻译后还原",
        "繁中": "啟用此功能後，根據正規表示式庫與禁譯表，將在翻譯前移除文字首尾的非翻譯內容、佔位符中間的非翻譯內容，並在翻譯後復原",
        "English": "When enabled, non-translatable content at text boundaries and within placeholders will be temporarily removed during translation based on regex library and exclusion list, then restored after translation",
        "日本語": "有効化すると、正規表現ライブラリと翻訳禁止リストに基づき、翻訳前後でテキストの前後端およびプレースホルダ内の非翻訳コンテンツを一時削除・復元します"
    },
    "模型退化检查": {
      "简中": "模型退化检查",
      "繁中": "模型退化檢查",
      "English": "Model Degradation Check",
      "日本語": "モデル劣化チェック"
    },
    "原文返回检查": {
      "简中": "原文返回检查",
      "繁中": "原文返回檢查",
      "English": "Original Text Check",
      "日本語": "原文チェック"
    },
    "翻译残留检查": {
      "简中": "翻译残留检查",
      "繁中": "翻譯殘留檢查",
      "English": "Translation Artifact Check",
      "日本語": "翻訳アーティファクト チェック"
    },
    "换行符数检查": {
      "简中": "换行符数检查",
      "繁中": "換行符數檢查",
      "English": "Newline Character Count Check",
      "日本語": "改行文字数チェック"
    },
    "翻译结果检查": {
      "简中": "翻译结果检查",
      "繁中": "翻譯結果檢查",
      "English": "Translation Result Check",
      "日本語": "翻訳結果チェック"
    },
    "回复格式强检查": {
      "简中": "回复格式强检查",
      "繁中": "回覆格式強檢查",
      "English": "Strict Response Format Validation",
      "日本語": "厳格な応答フォーマット検証"
    },
    "将在翻译结果中检查激活的规则（点亮按钮为激活）：如检测到对应情况，则视为任务执行失败": {
      "简中": "将在翻译结果中检查激活的规则（点亮按钮为激活）：如检测到对应情况，则视为任务执行失败",
      "繁中": "將在翻譯結果中檢查已啟用的規則（點亮的按鈕表示已啟用）：如偵測到符合規則的情況，則視為任務執行失敗。",
      "English": "Checks enabled rules in translation results (lit buttons = enabled). Task fails if rules are triggered.",
      "日本語": "翻訳結果で有効ルールをチェック (点灯ボタン＝有効)。ルール違反時タスク失敗。"
    }
  },

  "PART_2": {
    "自动检测": {
      "简中": "自动检测",
      "繁中": "自動檢測",
      "English": "Auto-detect",
      "日本語": "自動検出"
    },
    "简中": {
      "简中": "简中",
      "繁中": "簡中",
      "English": "Simplified Chinese",
      "日本語": "簡体中国語"
    },
    "繁中": {
      "简中": "繁中",
      "繁中": "繁中",
      "English": "Traditional Chinese",
      "日本語": "繁体中国語"
    },
    "日语": {
      "简中": "日语",
      "繁中": "日語",
      "English": "Japanese",
      "日本語": "日本語"
    },
    "英语": {
      "简中": "英语",
      "繁中": "英語",
      "English": "English",
      "日本語": "英語"
    },
    "韩语": {
      "简中": "韩语",
      "繁中": "韓語",
      "English": "Korean",
      "日本語": "韓国語"
    },
    "俄语": {
      "简中": "俄语",
      "繁中": "俄語",
      "English": "Russian",
      "日本語": "ロシア語"
    },
    "德语": {
      "简中": "德语",
      "繁中": "德語",
      "English": "German",
      "日本語": "ドイツ語"
    },
    "法语": {
      "简中": "法语",
      "繁中": "法語",
      "English": "French",
      "日本語": "フランス語"
    },
    "西班牙语": {
      "简中": "西班牙语",
      "繁中": "西班牙語",
      "English": "Spanish",
      "日本語": "スペイン語"
    }
  }
}


================================================
FILE: Resource/Localization/VersionManager.json
================================================
{
    "PART_1": {
      "开始更新": {
        "简中": "开始更新",
        "繁中": "開始更新",
        "English": "Start Update",
        "日本語": "更新を開始"
      },
      "取消": {
        "简中": "取消",
        "繁中": "取消",
        "English": "Cancel",
        "日本語": "キャンセル"
      },
      "暂停": {
        "简中": "暂停",
        "繁中": "暫停",
        "English": "Pause",
        "日本語": "一時停止"
      },
      "继续": {
        "简中": "继续",
        "繁中": "繼續",
        "English": "Resume",
        "日本語": "再開"
      },
      "查看发布页": {
        "简中": "查看发布页",
        "繁中": "查看發布頁",
        "English": "View Release Page",
        "日本語": "リリースページを表示"
      },
      "软件更新": {
        "简中": "软件更新",
        "繁中": "軟體更新",
        "English": "Software Update",
        "日本語": "ソフトウェア更新"
      },
      "当前版本": {
        "简中": "当前版本",
        "繁中": "當前版本",
        "English": "Current Version",
        "日本語": "現在のバージョン"
      },
      "最新版本": {
        "简中": "最新版本",
        "繁中": "最新版本",
        "English": "Latest Version",
        "日本語": "最新バージョン"
      },
      "检查错误": {
        "简中": "检查错误",
        "繁中": "檢查錯誤",
        "English": "Check Error",
        "日本語": "チェックエラー"
      },
      "新版本包含了重要的更新和功能改进": {
        "简中": "新版本包含了重要的更新和功能改进",
        "繁中": "新版本包含了重要的更新和功能改進",
        "English": "The new version contains important updates and improvements",
        "日本語": "新バージョンには重要な更新と機能改善が含まれています"
      },
      "无法检查更新，请稍后再试": {
        "简中": "无法检查更新，请稍后再试",
        "繁中": "無法檢查更新，請稍後再試",
        "English": "Unable to check for updates, please try again later",
        "日本語": "更新を確認できません。後でもう一度お試しください"
      },
      "检查失败": {
        "简中": "检查失败",
        "繁中": "檢查失敗",
        "English": "Check Failed",
        "日本語": "チェック失敗"
      },
      "您已经使用最新版本": {
        "简中": "您已经使用最新版本",
        "繁中": "您已經使用最新版本",
        "English": "You are already using the latest version",
        "日本語": "すでに最新バージョンを使用しています"
      },
      "无需更新": {
        "简中": "无需更新",
        "繁中": "無需更新",
        "English": "No update needed",
        "日本語": "更新の必要はありません"
      },
      "正在下载更新...": {
        "简中": "正在下载更新...",
        "繁中": "正在下載更新...",
        "English": "Downloading update...",
        "日本語": "更新をダウンロード中..."
      },
      "正在获取下载链接...": {
        "简中": "正在获取下载链接...",
        "繁中": "正在獲取下載鏈接...",
        "English": "Getting download link...",
        "日本語": "ダウンロードリンクを取得中..."
      },
      "未找到下载文件": {
        "简中": "未找到下载文件",
        "繁中": "未找到下載文件",
        "English": "Download file not found",
        "日本語": "ダウンロードファイルが見つかりません"
      },
      "下载错误": {
        "简中": "下载错误",
        "繁中": "下載錯誤",
        "English": "Download Error",
        "日本語": "ダウンロードエラー"
      },
      "未找到可下载的更新文件": {
        "简中": "未找到可下载的更新文件",
        "繁中": "未找到可下載的更新文件",
        "English": "No downloadable update file found",
        "日本語": "ダウンロード可能な更新ファイルが見つかりません"
      },
      "获取下载链接失败": {
        "简中": "获取下载链接失败",
        "繁中": "獲取下載鏈接失敗",
        "English": "Failed to get download link",
        "日本語": "ダウンロードリンクの取得に失敗しました"
      },
      "连接错误": {
        "简中": "连接错误",
        "繁中": "連接錯誤",
        "English": "Connection Error",
        "日本語": "接続エラー"
      },
      "HTTP错误":{
        "简中": "HTTP错误",
        "繁中": "HTTP錯誤",
        "English": "HTTP Error",
        "日本語": "HTTPエラー"
      },
      "无法连接到更新服务器": {
        "简中": "无法连接到更新服务器",
        "繁中": "無法連接到更新服務器",
        "English": "Cannot connect to update server",
        "日本語": "更新サーバーに接続できません"
      },
      "更新失败": {
        "简中": "更新失败",
        "繁中": "更新失敗",
        "English": "Update Failed",
        "日本語": "更新失敗"
      },
      "更新错误": {
        "简中": "更新错误",
        "繁中": "更新錯誤",
        "English": "Update Error",
        "日本語": "更新エラー"
      },
      "下载完成，准备安装...": {
        "简中": "下载完成，准备安装...",
        "繁中": "下載完成，準備安裝...",
        "English": "Download complete, preparing to install...",
        "日本語": "ダウンロード完了、インストールの準備中..."
      },
      "更新确认": {
        "简中": "更新确认",
        "繁中": "更新確認",
        "English": "Update Confirmation",
        "日本語": "更新確認"
      },
      "下载完成，是否立即安装更新？\n\n安装过程中应用将会关闭。\n如果选择'稍后安装'，可以通过更新按钮重新安装。": {
        "简中": "下载完成，是否立即安装更新？\n\n安装过程中应用将会关闭。\n如果选择'稍后安装'，可以通过更新按钮重新安装。",
        "繁中": "下載完成，是否立即安裝更新？\n\n安裝過程中應用將會關閉。\n如果選擇'稍後安裝'，可以通過更新按鈕重新安裝。",
        "English": "Download complete. Install update now?\n\nThe application will close during installation.\nIf you choose 'Install Later', you can reinstall through the update button.",
        "日本語": "ダウンロードが完了しました。今すぐ更新をインストールしますか？\n\nインストール中にアプリケーションは閉じられます。\n「後でインストール」を選択した場合、更新ボタンから再インストールできます。"
      },
      "立即安装": {
        "简中": "立即安装",
        "繁中": "立即安裝",
        "English": "Install Now",
        "日本語": "今すぐインストール"
      },
      "稍后安装": {
        "简中": "稍后安装",
        "繁中": "稍後安裝",
        "English": "Install Later",
        "日本語": "後でインストール"
      },
      "更新已下载": {
        "简中": "更新已下载",
        "繁中": "更新已下載",
        "English": "Update Downloaded",
        "日本語": "更新がダウンロードされました"
      },
      "更新已下载，可以通过更新按钮重新安装": {
        "简中": "更新已下载，可以通过更新按钮重新安装",
        "繁中": "更新已下載，可以通過更新按鈕重新安裝",
        "English": "Update downloaded, you can reinstall through the update button",
        "日本語": "更新がダウンロードされました。更新ボタンから再インストールできます"
      },
      "下载失败": {
        "简中": "下载失败",
        "繁中": "下載失敗",
        "English": "Download Failed",
        "日本語": "ダウンロード失敗"
      },
      "下载已暂停": {
        "简中": "下载已暂停",
        "繁中": "下載已暫停",
        "English": "Download Paused",
        "日本語": "ダウンロードが一時停止されました"
      },
      "下载取消": {
        "简中": "下载取消",
        "繁中": "下載取消",
        "English": "Download Canceled",
        "日本語": "ダウンロードがキャンセルされました"
      },
      "正在取消下载，请稍候...": {
        "简中": "正在取消下载，请稍候...",
        "繁中": "正在取消下載，請稍候...",
        "English": "Canceling download, please wait...",
        "日本語": "ダウンロードをキャンセルしています。お待ちください..."
      },
      "更新程序未找到": {
        "简中": "更新程序未找到",
        "繁中": "更新程序未找到",
        "English": "Updater Not Found",
        "日本語": "更新プログラムが見つかりません"
      },
      "找不到更新程序，请手动下载安装最新版本": {
        "简中": "找不到更新程序，请手动下载安装最新版本",
        "繁中": "找不到更新程序，請手動下載安裝最新版本",
        "English": "Updater not found, please manually download and install the latest version",
        "日本語": "更新プログラムが見つかりません。手動で最新バージョンをダウンロードしてインストールしてください"
      },
      "启动更新程序失败": {
        "简中": "启动更新程序失败",
        "繁中": "啟動更新程序失敗",
        "English": "Failed to start updater",
        "日本語": "更新プログラムの起動に失敗しました"
      },
      "安装更新": {
        "简中": "安装更新",
        "繁中": "安裝更新",
        "English": "Install Update",
        "日本語": "更新をインストール"
      },
      "发现已下载完成的更新文件，是否立即安装？\n\n安装过程中应用将会关闭。": {
        "简中": "发现已下载完成的更新文件，是否立即安装？\n\n安装过程中应用将会关闭。",
        "繁中": "發現已下載完成的更新文件，是否立即安裝？\n\n安裝過程中應用將會關閉。",
        "English": "Found a completed update file. Install now?\n\nThe application will close during installation.",
        "日本語": "ダウンロード済みの更新ファイルが見つかりました。今すぐインストールしますか？\n\nインストール中にアプリケーションは閉じられます。"
      },
      "下载已取消": {
        "简中": "下载已取消",
        "繁中": "下載已取消",
        "English": "Download Canceled",
        "日本語": "ダウンロードがキャンセルされました"
      },
      "正在检查更新...": {
        "简中": "正在检查更新...",
        "繁中": "正在檢查更新...",
        "English": "Checking for updates...",
        "日本語": "更新を確認中..."
      },
      "正在恢复下载...": {
        "简中": "正在恢复下载...",
        "繁中": "正在恢復下載...",
        "English": "Resuming download...",
        "日本語": "ダウンロードを再開中..."
      }
    }
  }
  


================================================
FILE: Resource/Models/language_detection-ONNX/.gitkeep
================================================
[Empty file]


================================================
FILE: Resource/Models/ner/ja_core_news_md/README.md
================================================
### Details: https://spacy.io/models/ja#ja_core_news_md

Japanese pipeline optimized for CPU. Components: tok2vec, morphologizer, parser, senter, ner, attribute_ruler.

| Feature | Description |
| --- | --- |
| **Name** | `ja_core_news_md` |
| **Version** | `3.8.0` |
| **spaCy** | `>=3.8.0,<3.9.0` |
| **Default Pipeline** | `tok2vec`, `morphologizer`, `parser`, `attribute_ruler`, `ner` |
| **Components** | `tok2vec`, `morphologizer`, `parser`, `senter`, `attribute_ruler`, `ner` |
| **Vectors** | 480443 keys, 20000 unique vectors (300 dimensions) |
| **Sources** | [UD Japanese GSD v2.8](https://github.com/UniversalDependencies/UD_Japanese-GSD) (Omura, Mai; Miyao, Yusuke; Kanayama, Hiroshi; Matsuda, Hiroshi; Wakasa, Aya; Yamashita, Kayo; Asahara, Masayuki; Tanaka, Takaaki; Murawaki, Yugo; Matsumoto, Yuji; Mori, Shinsuke; Uematsu, Sumire; McDonald, Ryan; Nivre, Joakim; Zeman, Daniel)<br />[UD Japanese GSD v2.8 NER](https://github.com/megagonlabs/UD_Japanese-GSD) (Megagon Labs Tokyo)<br />[chiVe: Japanese Word Embedding with Sudachi & NWJC (chive-1.1-mc90-500k)](https://github.com/WorksApplications/chiVe) (Works Applications) |
| **License** | `CC BY-SA 4.0` |
| **Author** | [Explosion](https://explosion.ai) |

### Label Scheme

<details>

<summary>View label scheme (65 labels for 3 components)</summary>

| Component | Labels |
| --- | --- |
| **`morphologizer`** | `POS=NOUN`, `POS=ADP`, `POS=VERB`, `POS=SCONJ`, `POS=AUX`, `POS=PUNCT`, `POS=PART`, `POS=DET`, `POS=NUM`, `POS=ADV`, `POS=PRON`, `POS=ADJ`, `POS=PROPN`, `POS=CCONJ`, `POS=SYM`, `POS=NOUN\|Polarity=Neg`, `POS=AUX\|Polarity=Neg`, `POS=SPACE`, `POS=INTJ`, `POS=SCONJ\|Polarity=Neg` |
| **`parser`** | `ROOT`, `acl`, `advcl`, `advmod`, `amod`, `aux`, `case`, `cc`, `ccomp`, `compound`, `cop`, `csubj`, `dep`, `det`, `dislocated`, `fixed`, `mark`, `nmod`, `nsubj`, `nummod`, `obj`, `obl`, `punct` |
| **`ner`** | `CARDINAL`, `DATE`, `EVENT`, `FAC`, `GPE`, `LANGUAGE`, `LAW`, `LOC`, `MONEY`, `MOVEMENT`, `NORP`, `ORDINAL`, `ORG`, `PERCENT`, `PERSON`, `PET_NAME`, `PHONE`, `PRODUCT`, `QUANTITY`, `TIME`, `TITLE_AFFIX`, `WORK_OF_ART` |

</details>

### Accuracy

| Type | Score |
| --- | --- |
| `TOKEN_ACC` | 99.37 |
| `TOKEN_P` | 97.61 |
| `TOKEN_R` | 97.87 |
| `TOKEN_F` | 97.74 |
| `POS_ACC` | 97.23 |
| `MORPH_ACC` | 0.00 |
| `MORPH_MICRO_P` | 34.01 |
| `MORPH_MICRO_R` | 98.04 |
| `MORPH_MICRO_F` | 50.51 |
| `SENTS_P` | 98.43 |
| `SENTS_R` | 98.82 |
| `SENTS_F` | 98.62 |
| `DEP_UAS` | 91.86 |
| `DEP_LAS` | 90.52 |
| `TAG_ACC` | 97.12 |
| `LEMMA_ACC` | 96.68 |
| `ENTS_P` | 73.56 |
| `ENTS_R` | 67.55 |
| `ENTS_F` | 70.43 |


================================================
FILE: Resource/Models/ner/ja_core_news_md/accuracy.json
================================================
{
  "token_acc": 0.9936688312,
  "token_p": 0.9760551948,
  "token_r": 0.9786766501,
  "token_f": 0.9773641647,
  "pos_acc": 0.9723051749,
  "morph_acc": 0.0,
  "morph_micro_p": 0.3401360544,
  "morph_micro_r": 0.9803921569,
  "morph_micro_f": 0.5050505051,
  "morph_per_feat": {
    "Polarity": {
      "p": 1.0,
      "r": 0.9803921569,
      "f": 0.9900990099
    },
    "Inflection": {
      "p": 0.0,
      "r": 0.0,
      "f": 0.0
    },
    "Reading": {
      "p": 0.0,
      "r": 0.0,
      "f": 0.0
    }
  },
  "sents_p": 0.9842829077,
  "sents_r": 0.9881656805,
  "sents_f": 0.9862204724,
  "dep_uas": 0.918629261,
  "dep_las": 0.9052053808,
  "dep_las_per_type": {
    "cc": {
      "p": 0.8260869565,
      "r": 0.7916666667,
      "f": 0.8085106383
    },
    "compound": {
      "p": 0.940151075,
      "r": 0.9120631342,
      "f": 0.9258941345
    },
    "obl": {
      "p": 0.7925925926,
      "r": 0.8014981273,
      "f": 0.7970204842
    },
    "case": {
      "p": 0.9896193772,
      "r": 0.9779635258,
      "f": 0.9837569272
    },
    "dislocated": {
      "p": 0.4166666667,
      "r": 0.3846153846,
      "f": 0.4
    },
    "nsubj": {
      "p": 0.7984644914,
      "r": 0.7984644914,
      "f": 0.7984644914
    },
    "nmod": {
      "p": 0.8991060026,
      "r": 0.8233918129,
      "f": 0.8595848596
    },
    "root": {
      "p": 0.9741035857,
      "r": 0.9644970414,
      "f": 0.9692765114
    },
    "aux": {
      "p": 0.9796107507,
      "r": 0.9814298979,
      "f": 0.9805194805
    },
    "advcl": {
      "p": 0.6772009029,
      "r": 0.6741573034,
      "f": 0.6756756757
    },
    "mark": {
      "p": 0.9698189135,
      "r": 0.964,
      "f": 0.9669007021
    },
    "fixed": {
      "p": 0.946332737,
      "r": 0.9618181818,
      "f": 0.954012624
    },
    "acl": {
      "p": 0.8289473684,
      "r": 0.8307692308,
      "f": 0.8298572997
    },
    "obj": {
      "p": 0.972392638,
      "r": 0.9577039275,
      "f": 0.9649923896
    },
    "nummod": {
      "p": 0.9805194805,
      "r": 0.8934911243,
      "f": 0.9349845201
    },
    "advmod": {
      "p": 0.6642335766,
      "r": 0.65,
      "f": 0.6570397112
    },
    "amod": {
      "p": 0.9,
      "r": 0.7297297297,
      "f": 0.8059701493
    },
    "cop": {
      "p": 0.9476744186,
      "r": 0.9476744186,
      "f": 0.9476744186
    },
    "ccomp": {
      "p": 0.9523809524,
      "r": 0.9090909091,
      "f": 0.9302325581
    },
    "det": {
      "p": 0.9803921569,
      "r": 0.9433962264,
      "f": 0.9615384615
    },
    "csubj": {
      "p": 0.6923076923,
      "r": 0.75,
      "f": 0.72
    },
    "dep": {
      "p": 0.0,
      "r": 0.0,
      "f": 0.0
    }
  },
  "tag_acc": 0.9712488769,
  "lemma_acc": 0.9668080248,
  "ents_p": 0.7356164384,
  "ents_r": 0.6754716981,
  "ents_f": 0.7042622951,
  "ents_per_type": {
    "DATE": {
      "p": 0.9633027523,
      "r": 0.9633027523,
      "f": 0.9633027523
    },
    "PERSON": {
      "p": 0.726618705,
      "r": 0.726618705,
      "f": 0.726618705
    },
    "ORG": {
      "p": 0.6115702479,
      "r": 0.5401459854,
      "f": 0.5736434109
    },
    "GPE": {
      "p": 0.6847826087,
      "r": 0.670212766,
      "f": 0.6774193548
    },
    "PRODUCT": {
      "p": 0.4482758621,
      "r": 0.3095238095,
      "f": 0.3661971831
    },
    "TIME": {
      "p": 0.5,
      "r": 1.0,
      "f": 0.6666666667
    },
    "QUANTITY": {
      "p": 0.8823529412,
      "r": 0.9090909091,
      "f": 0.8955223881
    },
    "NORP": {
      "p": 0.7307692308,
      "r": 0.59375,
      "f": 0.6551724138
    },
    "ORDINAL": {
      "p": 0.6363636364,
      "r": 0.6363636364,
      "f": 0.6363636364
    },
    "TITLE_AFFIX": {
      "p": 0.8181818182,
      "r": 0.6,
      "f": 0.6923076923
    },
    "WORK_OF_ART": {
      "p": 0.7857142857,
      "r": 0.6470588235,
      "f": 0.7096774194
    },
    "FAC": {
      "p": 0.5625,
      "r": 0.4864864865,
      "f": 0.5217391304
    },
    "CARDINAL": {
      "p": 0.0,
      "r": 0.0,
      "f": 0.0
    },
    "PERCENT": {
      "p": 1.0,
      "r": 0.2857142857,
      "f": 0.4444444444
    },
    "EVENT": {
      "p": 0.7777777778,
      "r": 0.5384615385,
      "f": 0.6363636364
    },
    "LOC": {
      "p": 0.5384615385,
      "r": 0.7,
      "f": 0.6086956522
    },
    "MOVEMENT": {
      "p": 0.0,
      "r": 0.0,
      "f": 0.0
    },
    "LAW": {
      "p": 1.0,
      "r": 0.3333333333,
      "f": 0.5
    },
    "MONEY": {
      "p": 1.0,
      "r": 1.0,
      "f": 1.0
    },
    "LANGUAGE": {
      "p": 1.0,
      "r": 1.0,
      "f": 1.0
    }
  },
  "speed": 7308.3421311499
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/config.cfg
================================================
[paths]
train = null
dev = null
vectors = null
init_tok2vec = null

[system]
gpu_allocator = null
seed = 0

[nlp]
lang = "ja"
pipeline = ["tok2vec","morphologizer","parser","senter","attribute_ruler","ner"]
disabled = ["senter"]
before_creation = null
after_creation = null
after_pipeline_creation = null
batch_size = 256
vectors = {"@vectors":"spacy.Vectors.v1"}

[nlp.tokenizer]
@tokenizers = "spacy.ja.JapaneseTokenizer"
split_mode = null

[components]

[components.attribute_ruler]
factory = "attribute_ruler"
scorer = {"@scorers":"spacy.attribute_ruler_scorer.v1"}
validate = false

[components.morphologizer]
factory = "morphologizer"
extend = true
overwrite = true
scorer = {"@scorers":"spacy.morphologizer_scorer.v1"}

[components.morphologizer.model]
@architectures = "spacy.Tagger.v2"
nO = null
normalize = false

[components.morphologizer.model.tok2vec]
@architectures = "spacy.Tok2VecListener.v1"
width = ${components.tok2vec.model.encode:width}
upstream = "tok2vec"

[components.ner]
factory = "ner"
incorrect_spans_key = null
moves = null
scorer = {"@scorers":"spacy.ner_scorer.v1"}
update_with_oracle_cut_size = 100

[components.ner.model]
@architectures = "spacy.TransitionBasedParser.v2"
state_type = "ner"
extra_state_tokens = false
hidden_width = 64
maxout_pieces = 2
use_upper = true
nO = null

[components.ner.model.tok2vec]
@architectures = "spacy.Tok2Vec.v2"

[components.ner.model.tok2vec.embed]
@architectures = "spacy.MultiHashEmbed.v2"
width = 96
attrs = ["NORM","PREFIX","SUFFIX","SHAPE"]
rows = [5000,1000,2500,2500]
include_static_vectors = true

[components.ner.model.tok2vec.encode]
@architectures = "spacy.MaxoutWindowEncoder.v2"
width = 96
depth = 4
window_size = 1
maxout_pieces = 3

[components.parser]
factory = "parser"
learn_tokens = false
min_action_freq = 30
moves = null
scorer = {"@scorers":"spacy.parser_scorer.v1"}
update_with_oracle_cut_size = 100

[components.parser.model]
@architectures = "spacy.TransitionBasedParser.v2"
state_type = "parser"
extra_state_tokens = false
hidden_width = 64
maxout_pieces = 2
use_upper = true
nO = null

[components.parser.model.tok2vec]
@architectures = "spacy.Tok2VecListener.v1"
width = ${components.tok2vec.model.encode:width}
upstream = "tok2vec"

[components.senter]
factory = "senter"
overwrite = false
scorer = {"@scorers":"spacy.senter_scorer.v1"}

[components.senter.model]
@architectures = "spacy.Tagger.v2"
nO = null
normalize = false

[components.senter.model.tok2vec]
@architectures = "spacy.Tok2Vec.v2"

[components.senter.model.tok2vec.embed]
@architectures = "spacy.MultiHashEmbed.v2"
width = 16
attrs = ["NORM","PREFIX","SUFFIX","SHAPE"]
rows = [1000,500,500,500]
include_static_vectors = true

[components.senter.model.tok2vec.encode]
@architectures = "spacy.MaxoutWindowEncoder.v2"
width = 16
depth = 2
window_size = 1
maxout_pieces = 2

[components.tok2vec]
factory = "tok2vec"

[components.tok2vec.model]
@architectures = "spacy.Tok2Vec.v2"

[components.tok2vec.model.embed]
@architectures = "spacy.MultiHashEmbed.v2"
width = ${components.tok2vec.model.encode:width}
attrs = ["NORM","PREFIX","SUFFIX","SHAPE","IS_SPACE"]
rows = [5000,1000,2500,2500,50]
include_static_vectors = true

[components.tok2vec.model.encode]
@architectures = "spacy.MaxoutWindowEncoder.v2"
width = 96
depth = 4
window_size = 1
maxout_pieces = 3

[corpora]

[corpora.dev]
@readers = "spacy.Corpus.v1"
path = ${paths.dev}
gold_preproc = false
max_length = 0
limit = 0
augmenter = null

[corpora.train]
@readers = "spacy.Corpus.v1"
path = ${paths.train}
gold_preproc = false
max_length = 0
limit = 0
augmenter = null

[training]
train_corpus = "corpora.train"
dev_corpus = "corpora.dev"
seed = ${system:seed}
gpu_allocator = ${system:gpu_allocator}
dropout = 0.1
accumulate_gradient = 1
patience = 5000
max_epochs = 0
max_steps = 100000
eval_frequency = 1000
frozen_components = []
before_to_disk = null
annotating_components = []
before_update = null

[training.batcher]
@batchers = "spacy.batch_by_words.v1"
discard_oversize = false
tolerance = 0.2
get_length = null

[training.batcher.size]
@schedules = "compounding.v1"
start = 100
stop = 1000
compound = 1.001
t = 0.0

[training.logger]
@loggers = "spacy.ConsoleLogger.v1"
progress_bar = false

[training.optimizer]
@optimizers = "Adam.v1"
beta1 = 0.9
beta2 = 0.999
L2_is_weight_decay = true
L2 = 0.01
grad_clip = 1.0
use_averages = true
eps = 0.00000001
learn_rate = 0.001

[training.score_weights]
pos_acc = 0.11
morph_micro_f = 0.33
morph_per_feat = null
dep_uas = 0.0
dep_las = 0.21
dep_las_per_type = null
sents_p = null
sents_r = null
sents_f = 0.03
ents_f = 0.21
ents_p = 0.0
ents_r = 0.0
ents_per_type = null
morph_acc = 0.11
speed = 0.0

[pretraining]

[initialize]
vocab_data = null
vectors = ${paths.vectors}
init_tok2vec = ${paths.init_tok2vec}
before_init = null
after_init = null

[initialize.components]

[initialize.components.morphologizer]

[initialize.components.morphologizer.labels]
@readers = "spacy.read_labels.v1"
path = "corpus/labels/morphologizer.json"
require = false

[initialize.components.ner]

[initialize.components.ner.labels]
@readers = "spacy.read_labels.v1"
path = "corpus/labels/ner.json"
require = false

[initialize.components.parser]

[initialize.components.parser.labels]
@readers = "spacy.read_labels.v1"
path = "corpus/labels/parser.json"
require = false

[initialize.lookups]
@misc = "spacy.LookupsDataLoader.v1"
lang = ${nlp.lang}
tables = []

[initialize.tokenizer]


================================================
FILE: Resource/Models/ner/ja_core_news_md/LICENSE
================================================
Attribution-ShareAlike 4.0 International

=======================================================================

Creative Commons Corporation ("Creative Commons") is not a law firm and
does not provide legal services or legal advice. Distribution of
Creative Commons public licenses does not create a lawyer-client or
other relationship. Creative Commons makes its licenses and related
information available on an "as-is" basis. Creative Commons gives no
warranties regarding its licenses, any material licensed under their
terms and conditions, or any related information. Creative Commons
disclaims all liability for damages resulting from their use to the
fullest extent possible.

Using Creative Commons Public Licenses

Creative Commons public licenses provide a standard set of terms and
conditions that creators and other rights holders may use to share
original works of authorship and other material subject to copyright
and certain other rights specified in the public license below. The
following considerations are for informational purposes only, are not
exhaustive, and do not form part of our licenses.

     Considerations for licensors: Our public licenses are
     intended for use by those authorized to give the public
     permission to use material in ways otherwise restricted by
     copyright and certain other rights. Our licenses are
     irrevocable. Licensors should read and understand the terms
     and conditions of the license they choose before applying it.
     Licensors should also secure all rights necessary before
     applying our licenses so that the public can reuse the
     material as expected. Licensors should clearly mark any
     material not subject to the license. This includes other CC-
     licensed material, or material used under an exception or
     limitation to copyright. More considerations for licensors:
    wiki.creativecommons.org/Considerations_for_licensors

     Considerations for the public: By using one of our public
     licenses, a licensor grants the public permission to use the
     licensed material under specified terms and conditions. If
     the licensor's permission is not necessary for any reason--for
     example, because of any applicable exception or limitation to
     copyright--then that use is not regulated by the license. Our
     licenses grant only permissions under copyright and certain
     other rights that a licensor has authority to grant. Use of
     the licensed material may still be restricted for other
     reasons, including because others have copyright or other
     rights in the material. A licensor may make special requests,
     such as asking that all changes be marked or described.
     Although not required by our licenses, you are encouraged to
     respect those requests where reasonable. More considerations
     for the public:
    wiki.creativecommons.org/Considerations_for_licensees

=======================================================================

Creative Commons Attribution-ShareAlike 4.0 International Public
License

By exercising the Licensed Rights (defined below), You accept and agree
to be bound by the terms and conditions of this Creative Commons
Attribution-ShareAlike 4.0 International Public License ("Public
License"). To the extent this Public License may be interpreted as a
contract, You are granted the Licensed Rights in consideration of Your
acceptance of these terms and conditions, and the Licensor grants You
such rights in consideration of benefits the Licensor receives from
making the Licensed Material available under these terms and
conditions.


Section 1 -- Definitions.

  a. Adapted Material means material subject to Copyright and Similar
     Rights that is derived from or based upon the Licensed Material
     and in which the Licensed Material is translated, altered,
     arranged, transformed, or otherwise modified in a manner requiring
     permission under the Copyright and Similar Rights held by the
     Licensor. For purposes of this Public License, where the Licensed
     Material is a musical work, performance, or sound recording,
     Adapted Material is always produced where the Licensed Material is
     synched in timed relation with a moving image.

  b. Adapter's License means the license You apply to Your Copyright
     and Similar Rights in Your contributions to Adapted Material in
     accordance with the terms and conditions of this Public License.

  c. BY-SA Compatible License means a license listed at
     creativecommons.org/compatiblelicenses, approved by Creative
     Commons as essentially the equivalent of this Public License.

  d. Copyright and Similar Rights means copyright and/or similar rights
     closely related to copyright including, without limitation,
     performance, broadcast, sound recording, and Sui Generis Database
     Rights, without regard to how the rights are labeled or
     categorized. For purposes of this Public License, the rights
     specified in Section 2(b)(1)-(2) are not Copyright and Similar
     Rights.

  e. Effective Technological Measures means those measures that, in the
     absence of proper authority, may not be circumvented under laws
     fulfilling obligations under Article 11 of the WIPO Copyright
     Treaty adopted on December 20, 1996, and/or similar international
     agreements.

  f. Exceptions and Limitations means fair use, fair dealing, and/or
     any other exception or limitation to Copyright and Similar Rights
     that applies to Your use of the Licensed Material.

  g. License Elements means the license attributes listed in the name
     of a Creative Commons Public License. The License Elements of this
     Public License are Attribution and ShareAlike.

  h. Licensed Material means the artistic or literary work, database,
     or other material to which the Licensor applied this Public
     License.

  i. Licensed Rights means the rights granted to You subject to the
     terms and conditions of this Public License, which are limited to
     all Copyright and Similar Rights that apply to Your use of the
     Licensed Material and that the Licensor has authority to license.

  j. Licensor means the individual(s) or entity(ies) granting rights
     under this Public License.

  k. Share means to provide material to the public by any means or
     process that requires permission under the Licensed Rights, such
     as reproduction, public display, public performance, distribution,
     dissemination, communication, or importation, and to make material
     available to the public including in ways that members of the
     public may access the material from a place and at a time
     individually chosen by them.

  l. Sui Generis Database Rights means rights other than copyright
     resulting from Directive 96/9/EC of the European Parliament and of
     the Council of 11 March 1996 on the legal protection of databases,
     as amended and/or succeeded, as well as other essentially
     equivalent rights anywhere in the world.

  m. You means the individual or entity exercising the Licensed Rights
     under this Public License. Your has a corresponding meaning.


Section 2 -- Scope.

  a. License grant.

       1. Subject to the terms and conditions of this Public License,
          the Licensor hereby grants You a worldwide, royalty-free,
          non-sublicensable, non-exclusive, irrevocable license to
          exercise the Licensed Rights in the Licensed Material to:

            a. reproduce and Share the Licensed Material, in whole or
               in part; and

            b. produce, reproduce, and Share Adapted Material.

       2. Exceptions and Limitations. For the avoidance of doubt, where
          Exceptions and Limitations apply to Your use, this Public
          License does not apply, and You do not need to comply with
          its terms and conditions.

       3. Term. The term of this Public License is specified in Section
          6(a).

       4. Media and formats; technical modifications allowed. The
          Licensor authorizes You to exercise the Licensed Rights in
          all media and formats whether now known or hereafter created,
          and to make technical modifications necessary to do so. The
          Licensor waives and/or agrees not to assert any right or
          authority to forbid You from making technical modifications
          necessary to exercise the Licensed Rights, including
          technical modifications necessary to circumvent Effective
          Technological Measures. For purposes of this Public License,
          simply making modifications authorized by this Section 2(a)
          (4) never produces Adapted Material.

       5. Downstream recipients.

            a. Offer from the Licensor -- Licensed Material. Every
               recipient of the Licensed Material automatically
               receives an offer from the Licensor to exercise the
               Licensed Rights under the terms and conditions of this
               Public License.

            b. Additional offer from the Licensor -- Adapted Material.
               Every recipient of Adapted Material from You
               automatically receives an offer from the Licensor to
               exercise the Licensed Rights in the Adapted Material
               under the conditions of the Adapter's License You apply.

            c. No downstream restrictions. You may not offer or impose
               any additional or different terms or conditions on, or
               apply any Effective Technological Measures to, the
               Licensed Material if doing so restricts exercise of the
               Licensed Rights by any recipient of the Licensed
               Material.

       6. No endorsement. Nothing in this Public License constitutes or
          may be construed as permission to assert or imply that You
          are, or that Your use of the Licensed Material is, connected
          with, or sponsored, endorsed, or granted official status by,
          the Licensor or others designated to receive attribution as
          provided in Section 3(a)(1)(A)(i).

  b. Other rights.

       1. Moral rights, such as the right of integrity, are not
          licensed under this Public License, nor are publicity,
          privacy, and/or other similar personality rights; however, to
          the extent possible, the Licensor waives and/or agrees not to
          assert any such rights held by the Licensor to the limited
          extent necessary to allow You to exercise the Licensed
          Rights, but not otherwise.

       2. Patent and trademark rights are not licensed under this
          Public License.

       3. To the extent possible, the Licensor waives any right to
          collect royalties from You for the exercise of the Licensed
          Rights, whether directly or through a collecting society
          under any voluntary or waivable statutory or compulsory
          licensing scheme. In all other cases the Licensor expressly
          reserves any right to collect such royalties.


Section 3 -- License Conditions.

Your exercise of the Licensed Rights is expressly made subject to the
following conditions.

  a. Attribution.

       1. If You Share the Licensed Material (including in modified
          form), You must:

            a. retain the following if it is supplied by the Licensor
               with the Licensed Material:

                 i. identification of the creator(s) of the Licensed
                    Material and any others designated to receive
                    attribution, in any reasonable manner requested by
                    the Licensor (including by pseudonym if
                    designated);

                ii. a copyright notice;

               iii. a notice that refers to this Public License;

                iv. a notice that refers to the disclaimer of
                    warranties;

                 v. a URI or hyperlink to the Licensed Material to the
                    extent reasonably practicable;

            b. indicate if You modified the Licensed Material and
               retain an indication of any previous modifications; and

            c. indicate the Licensed Material is licensed under this
               Public License, and include the text of, or the URI or
               hyperlink to, this Public License.

       2. You may satisfy the conditions in Section 3(a)(1) in any
          reasonable manner based on the medium, means, and context in
          which You Share the Licensed Material. For example, it may be
          reasonable to satisfy the conditions by providing a URI or
          hyperlink to a resource that includes the required
          information.

       3. If requested by the Licensor, You must remove any of the
          information required by Section 3(a)(1)(A) to the extent
          reasonably practicable.

  b. ShareAlike.

     In addition to the conditions in Section 3(a), if You Share
     Adapted Material You produce, the following conditions also apply.

       1. The Adapter's License You apply must be a Creative Commons
          license with the same License Elements, this version or
          later, or a BY-SA Compatible License.

       2. You must include the text of, or the URI or hyperlink to, the
          Adapter's License You apply. You may satisfy this condition
          in any reasonable manner based on the medium, means, and
          context in which You Share Adapted Material.

       3. You may not offer or impose any additional or different terms
          or conditions on, or apply any Effective Technological
          Measures to, Adapted Material that restrict exercise of the
          rights granted under the Adapter's License You apply.


Section 4 -- Sui Generis Database Rights.

Where the Licensed Rights include Sui Generis Database Rights that
apply to Your use of the Licensed Material:

  a. for the avoidance of doubt, Section 2(a)(1) grants You the right
     to extract, reuse, reproduce, and Share all or a substantial
     portion of the contents of the database;

  b. if You include all or a substantial portion of the database
     contents in a database in which You have Sui Generis Database
     Rights, then the database in which You have Sui Generis Database
     Rights (but not its individual contents) is Adapted Material,

     including for purposes of Section 3(b); and
  c. You must comply with the conditions in Section 3(a) if You Share
     all or a substantial portion of the contents of the database.

For the avoidance of doubt, this Section 4 supplements and does not
replace Your obligations under this Public License where the Licensed
Rights include other Copyright and Similar Rights.


Section 5 -- Disclaimer of Warranties and Limitation of Liability.

  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE
     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS
     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,
     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,
     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR
     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,
     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT
     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT
     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.

  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE
     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,
     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,
     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR
     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR
     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR
     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.

  c. The disclaimer of warranties and limitation of liability provided
     above shall be interpreted in a manner that, to the extent
     possible, most closely approximates an absolute disclaimer and
     waiver of all liability.


Section 6 -- Term and Termination.

  a. This Public License applies for the term of the Copyright and
     Similar Rights licensed here. However, if You fail to comply with
     this Public License, then Your rights under this Public License
     terminate automatically.

  b. Where Your right to use the Licensed Material has terminated under
     Section 6(a), it reinstates:

       1. automatically as of the date the violation is cured, provided
          it is cured within 30 days of Your discovery of the
          violation; or

       2. upon express reinstatement by the Licensor.

     For the avoidance of doubt, this Section 6(b) does not affect any
     right the Licensor may have to seek remedies for Your violations
     of this Public License.

  c. For the avoidance of doubt, the Licensor may also offer the
     Licensed Material under separate terms or conditions or stop
     distributing the Licensed Material at any time; however, doing so
     will not terminate this Public License.

  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public
     License.


Section 7 -- Other Terms and Conditions.

  a. The Licensor shall not be bound by any additional or different
     terms or conditions communicated by You unless expressly agreed.

  b. Any arrangements, understandings, or agreements regarding the
     Licensed Material not stated herein are separate from and
     independent of the terms and conditions of this Public License.


Section 8 -- Interpretation.

  a. For the avoidance of doubt, this Public License does not, and
     shall not be interpreted to, reduce, limit, restrict, or impose
     conditions on any use of the Licensed Material that could lawfully
     be made without permission under this Public License.

  b. To the extent possible, if any provision of this Public License is
     deemed unenforceable, it shall be automatically reformed to the
     minimum extent necessary to make it enforceable. If the provision
     cannot be reformed, it shall be severed from this Public License
     without affecting the enforceability of the remaining terms and
     conditions.

  c. No term or condition of this Public License will be waived and no
     failure to comply consented to unless expressly agreed to by the
     Licensor.

  d. Nothing in this Public License constitutes or may be interpreted
     as a limitation upon, or waiver of, any privileges and immunities
     that apply to the Licensor or You, including from the legal
     processes of any jurisdiction or authority.


=======================================================================

Creative Commons is not a party to its public
licenses. Notwithstanding, Creative Commons may elect to apply one of
its public licenses to material it publishes and in those instances
will be considered the “Licensor.” The text of the Creative Commons
public licenses is dedicated to the public domain under the CC0 Public
Domain Dedication. Except for the limited purpose of indicating that
material is shared under a Creative Commons public license or as
otherwise permitted by the Creative Commons policies published at
creativecommons.org/policies, Creative Commons does not authorize the
use of the trademark "Creative Commons" or any other trademark or logo
of Creative Commons without its prior written consent including,
without limitation, in connection with any unauthorized modifications
to any of its public licenses or any other arrangements,
understandings, or agreements concerning use of licensed material. For
the avoidance of doubt, this paragraph does not form part of the
public licenses.

Creative Commons may be contacted at creativecommons.org.




================================================
FILE: Resource/Models/ner/ja_core_news_md/meta.json
================================================
{
  "lang":"ja",
  "name":"core_news_md",
  "version":"3.8.0",
  "description":"Japanese pipeline optimized for CPU. Components: tok2vec, morphologizer, parser, senter, ner, attribute_ruler.",
  "author":"Explosion",
  "email":"contact@explosion.ai",
  "url":"https://explosion.ai",
  "license":"CC BY-SA 4.0",
  "spacy_version":">=3.8.0,<3.9.0",
  "spacy_git_version":"5010fcbd3",
  "vectors":{
    "width":300,
    "vectors":20000,
    "keys":480443,
    "name":"ja_vectors"
  },
  "labels":{
    "tok2vec":[

    ],
    "morphologizer":[
      "POS=NOUN",
      "POS=ADP",
      "POS=VERB",
      "POS=SCONJ",
      "POS=AUX",
      "POS=PUNCT",
      "POS=PART",
      "POS=DET",
      "POS=NUM",
      "POS=ADV",
      "POS=PRON",
      "POS=ADJ",
      "POS=PROPN",
      "POS=CCONJ",
      "POS=SYM",
      "POS=NOUN|Polarity=Neg",
      "POS=AUX|Polarity=Neg",
      "POS=SPACE",
      "POS=INTJ",
      "POS=SCONJ|Polarity=Neg"
    ],
    "parser":[
      "ROOT",
      "acl",
      "advcl",
      "advmod",
      "amod",
      "aux",
      "case",
      "cc",
      "ccomp",
      "compound",
      "cop",
      "csubj",
      "dep",
      "det",
      "dislocated",
      "fixed",
      "mark",
      "nmod",
      "nsubj",
      "nummod",
      "obj",
      "obl",
      "punct"
    ],
    "attribute_ruler":[

    ],
    "ner":[
      "CARDINAL",
      "DATE",
      "EVENT",
      "FAC",
      "GPE",
      "LANGUAGE",
      "LAW",
      "LOC",
      "MONEY",
      "MOVEMENT",
      "NORP",
      "ORDINAL",
      "ORG",
      "PERCENT",
      "PERSON",
      "PET_NAME",
      "PHONE",
      "PRODUCT",
      "QUANTITY",
      "TIME",
      "TITLE_AFFIX",
      "WORK_OF_ART"
    ]
  },
  "pipeline":[
    "tok2vec",
    "morphologizer",
    "parser",
    "attribute_ruler",
    "ner"
  ],
  "components":[
    "tok2vec",
    "morphologizer",
    "parser",
    "senter",
    "attribute_ruler",
    "ner"
  ],
  "disabled":[
    "senter"
  ],
  "performance":{
    "token_acc":0.9936688312,
    "token_p":0.9760551948,
    "token_r":0.9786766501,
    "token_f":0.9773641647,
    "pos_acc":0.9723051749,
    "morph_acc":0.0,
    "morph_micro_p":0.3401360544,
    "morph_micro_r":0.9803921569,
    "morph_micro_f":0.5050505051,
    "morph_per_feat":{
      "Polarity":{
        "p":1.0,
        "r":0.9803921569,
        "f":0.9900990099
      },
      "Inflection":{
        "p":0.0,
        "r":0.0,
        "f":0.0
      },
      "Reading":{
        "p":0.0,
        "r":0.0,
        "f":0.0
      }
    },
    "sents_p":0.9842829077,
    "sents_r":0.9881656805,
    "sents_f":0.9862204724,
    "dep_uas":0.918629261,
    "dep_las":0.9052053808,
    "dep_las_per_type":{
      "cc":{
        "p":0.8260869565,
        "r":0.7916666667,
        "f":0.8085106383
      },
      "compound":{
        "p":0.940151075,
        "r":0.9120631342,
        "f":0.9258941345
      },
      "obl":{
        "p":0.7925925926,
        "r":0.8014981273,
        "f":0.7970204842
      },
      "case":{
        "p":0.9896193772,
        "r":0.9779635258,
        "f":0.9837569272
      },
      "dislocated":{
        "p":0.4166666667,
        "r":0.3846153846,
        "f":0.4
      },
      "nsubj":{
        "p":0.7984644914,
        "r":0.7984644914,
        "f":0.7984644914
      },
      "nmod":{
        "p":0.8991060026,
        "r":0.8233918129,
        "f":0.8595848596
      },
      "root":{
        "p":0.9741035857,
        "r":0.9644970414,
        "f":0.9692765114
      },
      "aux":{
        "p":0.9796107507,
        "r":0.9814298979,
        "f":0.9805194805
      },
      "advcl":{
        "p":0.6772009029,
        "r":0.6741573034,
        "f":0.6756756757
      },
      "mark":{
        "p":0.9698189135,
        "r":0.964,
        "f":0.9669007021
      },
      "fixed":{
        "p":0.946332737,
        "r":0.9618181818,
        "f":0.954012624
      },
      "acl":{
        "p":0.8289473684,
        "r":0.8307692308,
        "f":0.8298572997
      },
      "obj":{
        "p":0.972392638,
        "r":0.9577039275,
        "f":0.9649923896
      },
      "nummod":{
        "p":0.9805194805,
        "r":0.8934911243,
        "f":0.9349845201
      },
      "advmod":{
        "p":0.6642335766,
        "r":0.65,
        "f":0.6570397112
      },
      "amod":{
        "p":0.9,
        "r":0.7297297297,
        "f":0.8059701493
      },
      "cop":{
        "p":0.9476744186,
        "r":0.9476744186,
        "f":0.9476744186
      },
      "ccomp":{
        "p":0.9523809524,
        "r":0.9090909091,
        "f":0.9302325581
      },
      "det":{
        "p":0.9803921569,
        "r":0.9433962264,
        "f":0.9615384615
      },
      "csubj":{
        "p":0.6923076923,
        "r":0.75,
        "f":0.72
      },
      "dep":{
        "p":0.0,
        "r":0.0,
        "f":0.0
      }
    },
    "tag_acc":0.9712488769,
    "lemma_acc":0.9668080248,
    "ents_p":0.7356164384,
    "ents_r":0.6754716981,
    "ents_f":0.7042622951,
    "ents_per_type":{
      "DATE":{
        "p":0.9633027523,
        "r":0.9633027523,
        "f":0.9633027523
      },
      "PERSON":{
        "p":0.726618705,
        "r":0.726618705,
        "f":0.726618705
      },
      "ORG":{
        "p":0.6115702479,
        "r":0.5401459854,
        "f":0.5736434109
      },
      "GPE":{
        "p":0.6847826087,
        "r":0.670212766,
        "f":0.6774193548
      },
      "PRODUCT":{
        "p":0.4482758621,
        "r":0.3095238095,
        "f":0.3661971831
      },
      "TIME":{
        "p":0.5,
        "r":1.0,
        "f":0.6666666667
      },
      "QUANTITY":{
        "p":0.8823529412,
        "r":0.9090909091,
        "f":0.8955223881
      },
      "NORP":{
        "p":0.7307692308,
        "r":0.59375,
        "f":0.6551724138
      },
      "ORDINAL":{
        "p":0.6363636364,
        "r":0.6363636364,
        "f":0.6363636364
      },
      "TITLE_AFFIX":{
        "p":0.8181818182,
        "r":0.6,
        "f":0.6923076923
      },
      "WORK_OF_ART":{
        "p":0.7857142857,
        "r":0.6470588235,
        "f":0.7096774194
      },
      "FAC":{
        "p":0.5625,
        "r":0.4864864865,
        "f":0.5217391304
      },
      "CARDINAL":{
        "p":0.0,
        "r":0.0,
        "f":0.0
      },
      "PERCENT":{
        "p":1.0,
        "r":0.2857142857,
        "f":0.4444444444
      },
      "EVENT":{
        "p":0.7777777778,
        "r":0.5384615385,
        "f":0.6363636364
      },
      "LOC":{
        "p":0.5384615385,
        "r":0.7,
        "f":0.6086956522
      },
      "MOVEMENT":{
        "p":0.0,
        "r":0.0,
        "f":0.0
      },
      "LAW":{
        "p":1.0,
        "r":0.3333333333,
        "f":0.5
      },
      "MONEY":{
        "p":1.0,
        "r":1.0,
        "f":1.0
      },
      "LANGUAGE":{
        "p":1.0,
        "r":1.0,
        "f":1.0
      }
    },
    "speed":7308.3421311499
  },
  "sources":[
    {
      "name":"UD Japanese GSD v2.8",
      "url":"https://github.com/UniversalDependencies/UD_Japanese-GSD",
      "license":"CC BY-SA 4.0",
      "author":"Omura, Mai; Miyao, Yusuke; Kanayama, Hiroshi; Matsuda, Hiroshi; Wakasa, Aya; Yamashita, Kayo; Asahara, Masayuki; Tanaka, Takaaki; Murawaki, Yugo; Matsumoto, Yuji; Mori, Shinsuke; Uematsu, Sumire; McDonald, Ryan; Nivre, Joakim; Zeman, Daniel"
    },
    {
      "name":"UD Japanese GSD v2.8 NER",
      "url":"https://github.com/megagonlabs/UD_Japanese-GSD",
      "license":"CC BY-SA 4.0",
      "author":"Megagon Labs Tokyo"
    },
    {
      "name":"chiVe: Japanese Word Embedding with Sudachi & NWJC (chive-1.1-mc90-500k)",
      "url":"https://github.com/WorksApplications/chiVe",
      "license":"Apache-2.0",
      "author":"Works Applications"
    }
  ],
  "requirements":[
    "sudachipy>=0.5.2,!=0.6.1",
    "sudachidict-core>=20211220"
  ]
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/attribute_ruler/patterns
================================================
[Binary file]


================================================
FILE: Resource/Models/ner/ja_core_news_md/morphologizer/cfg
================================================
{
  "extend":true,
  "label_smoothing":0.0,
  "labels_morph":{
    "POS=NOUN":"",
    "POS=ADP":"",
    "POS=VERB":"",
    "POS=SCONJ":"",
    "POS=AUX":"",
    "POS=PUNCT":"",
    "POS=PART":"",
    "POS=DET":"",
    "POS=NUM":"",
    "POS=ADV":"",
    "POS=PRON":"",
    "POS=ADJ":"",
    "POS=PROPN":"",
    "POS=CCONJ":"",
    "POS=SYM":"",
    "POS=NOUN|Polarity=Neg":"Polarity=Neg",
    "POS=AUX|Polarity=Neg":"Polarity=Neg",
    "POS=SPACE":"",
    "POS=INTJ":"",
    "POS=SCONJ|Polarity=Neg":"Polarity=Neg"
  },
  "labels_pos":{
    "POS=NOUN":92,
    "POS=ADP":85,
    "POS=VERB":100,
    "POS=SCONJ":98,
    "POS=AUX":87,
    "POS=PUNCT":97,
    "POS=PART":94,
    "POS=DET":90,
    "POS=NUM":93,
    "POS=ADV":86,
    "POS=PRON":95,
    "POS=ADJ":84,
    "POS=PROPN":96,
    "POS=CCONJ":89,
    "POS=SYM":99,
    "POS=NOUN|Polarity=Neg":92,
    "POS=AUX|Polarity=Neg":87,
    "POS=SPACE":103,
    "POS=INTJ":91,
    "POS=SCONJ|Polarity=Neg":98
  },
  "overwrite":true
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/morphologizer/model
================================================
[Binary file]


================================================
FILE: Resource/Models/ner/ja_core_news_md/ner/cfg
================================================
{
  "moves":null,
  "update_with_oracle_cut_size":100,
  "multitasks":[

  ],
  "min_action_freq":1,
  "learn_tokens":false,
  "beam_width":1,
  "beam_density":0.0,
  "beam_update_prob":0.0,
  "incorrect_spans_key":null
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/ner/moves
================================================
[Binary file]


================================================
FILE: Resource/Models/ner/ja_core_news_md/parser/cfg
================================================
{
  "moves":null,
  "update_with_oracle_cut_size":100,
  "multitasks":[

  ],
  "min_action_freq":30,
  "learn_tokens":false,
  "beam_width":1,
  "beam_density":0.0,
  "beam_update_prob":0.0,
  "incorrect_spans_key":null
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/parser/moves
================================================
[Binary file]


================================================
FILE: Resource/Models/ner/ja_core_news_md/senter/cfg
================================================
{
  "overwrite":false
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/tokenizer/cfg
================================================
{
  "split_mode":null
}


================================================
FILE: Resource/Models/ner/ja_core_news_md/vocab/vectors.cfg
================================================
{
  "mode":"default"
}


================================================
FILE: Resource/platforms/preset.json
================================================
{
    "platforms": {
        "sakura": {
            "tag": "sakura",
            "group": "local",
            "name": "SakuraLLM",
            "api_url": "http://127.0.0.1:8080",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "sakura",
            "rpm_limit": 2000,
            "tpm_limit": 100000000,
            "model": "Sakura-v1.0",
            "top_p": 0.3,
            "temperature": 0.1,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "Sakura-v1.0"
            ],
            "key_in_settings": [
                "api_url",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "frequency_penalty"
            ]
        },
        "LocalLLM": {
            "tag": "LocalLLM",
            "group": "local",
            "name": "本地小模型",
            "api_url": "http://127.0.0.1:8080",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "LocalLLM",
            "rpm_limit": 2000,
            "tpm_limit": 100000000,
            "model": "Qwen2.5-7B",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "Qwen2.5-7B"
            ],
            "key_in_settings": [
                "api_url",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "frequency_penalty",
                "think_switch"
            ]
        },
        "cohere": {
            "tag": "cohere",
            "group": "online",
            "name": "Cohere",
            "api_url": "https://api.cohere.com",
            "api_key": "",
            "api_format": "Cohere",
            "icon": "cohere",
            "rpm_limit": 10,
            "tpm_limit": 9999999,
            "model": "command-r-plus",
            "top_p": 0.95,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "command-r-plus",
                "c4ai-aya-expanse-32b"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "temperature",
                "top_p",
                "presence_penalty",
                "frequency_penalty"
            ]
        },
        "google": {
            "tag": "google",
            "group": "online",
            "name": "Google",
            "api_url": "",
            "api_key": "",
            "api_format": "Google",
            "icon": "google",
            "rpm_limit": 15,
            "tpm_limit": 320000,
            "model": "gemini-2.5-flash",
            "top_p": 0.95,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "gemini-2.0-flash",
                "gemini-2.0-flash-exp",
                "gemini-2.5-flash-lite",
                "gemini-2.5-flash",
                "gemini-2.5-pro"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "temperature",
                "top_p",
                "think_switch",
                "thinking_budget",
                "presence_penalty",
                "frequency_penalty"
            ]
        },
        "openai": {
            "tag": "openai",
            "group": "online",
            "name": "OpenAI",
            "api_url": "https://api.openai.com/v1",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "openai",
            "rpm_limit": 3500,
            "tpm_limit": 600000,
            "model": "gpt-3.5-turbo",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "gpt-3.5-turbo",
                "gpt-4",
                "gpt-4o",
                "gpt-4o-mini",
                "gpt-4-turbo"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty",
                "think_switch",
                "think_depth"
            ]
        },
        "deepseek": {
            "tag": "deepseek",
            "group": "online",
            "name": "DeepSeek",
            "api_url": "https://api.deepseek.com/v1",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "deepseek",
            "rpm_limit": 4096,
            "tpm_limit": 10000000,
            "model": "deepseek-chat",
            "top_p": 1.0,
            "temperature": 1.3,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "deepseek-chat",
                "deepseek-reasoner"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty"
            ]
        },
        "anthropic": {
            "tag": "anthropic",
            "group": "online",
            "name": "Anthropic",
            "api_url": "https://api.anthropic.com",
            "api_key": "",
            "api_format": "Anthropic",
            "icon": "anthropic",
            "rpm_limit": 2000,
            "tpm_limit": 100000000,
            "model": "claude-3-haiku",
            "top_p": 0.95,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "claude-3-5-haiku",
                "claude-sonnet-4",
                "claude-opus-4"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "temperature",
                "top_p"
            ]
        },
        "amazonbedrock": {
            "tag": "amazonbedrock",
            "group": "online",
            "name": "Amazon Bedrock",
            "region": "us-east-1",
            "access_key": "",
            "secret_key": "",
            "api_key": "",
            "api_url": "",
            "api_format": "Amazon Bedrock",
            "icon": "amazonbedrock",
            "rpm_limit": 2000,
            "tpm_limit": 100000000,
            "model": "claude-3-haiku",
            "top_p": 0.95,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "region_datas": [
                "us-east-1",
                "us-east-2",
                "us-west-2",
                "eu-west-1"
            ],
            "model_datas": [
                "anthropic.claude-3-haiku-20240307-v1:0",
                "anthropic.claude-3-sonnet-20240229-v1:0",
                "us.anthropic.claude-3-5-haiku-20241022-v1:0",
                "us.anthropic.claude-3-5-sonnet-20241022-v2:0",
                "us.anthropic.claude-3-7-sonnet-20250219-v1:0",
                "amazon.nova-lite-v1:0",
                "amazon.nova-micro-v1:0",
                "amazon.nova-pro-v1:0",
                "us.deepseek.r1-v1:0"
            ],
            "key_in_settings": [
                "region",
                "access_key",
                "secret_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "temperature",
                "top_p"
            ]
        },
        "xai": {
            "tag": "xai",
            "group": "online",
            "name": "xAI",
            "api_url": "https://api.x.ai/v1",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "xai",
            "rpm_limit": 600,
            "tpm_limit": 1000000,
            "model": "grok-3-fast-beta",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "grok-3-fast-beta",
                "grok-3-mini-beta",
                "grok-3-beta"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "think_switch",
                "think_depth"
            ]
        },
        "volcengine": {
            "tag": "volcengine",
            "group": "online",
            "name": "火山引擎",
            "api_url": "https://ark.cn-beijing.volces.com/api/v3",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "volcengine",
            "rpm_limit": 10000,
            "tpm_limit": 8000000,
            "model": "doubao-seed-1-6-flash-250615",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "doubao-seed-1-6-flash-250615",
                "doubao-seed-1-6-250615",
                "deepseek-v3-250324",
                "deepseek-r1-250528"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty"
            ]
        },
        "dashscope": {
            "tag": "dashscope",
            "group": "online",
            "name": "阿里云百炼",
            "api_url": "https://dashscope.aliyuncs.com/compatible-mode/v1",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "dashscope",
            "rpm_limit": 150,
            "tpm_limit": 1500000,
            "model": "qwen-turbo",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "qwen-turbo",
                "qwen-plus",
                "qwen-max",
                "qwen-long"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty",
                "think_switch"
            ]
        },
        "zhipu": {
            "tag": "zhipu",
            "group": "online",
            "name": "智谱清言",
            "api_url": "https://open.bigmodel.cn/api/paas/v4",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "zhipu",
            "rpm_limit": 30,
            "tpm_limit": 100000,
            "model": "glm-4-flash",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "glm-4.5-flash",
                "glm-4.5-airx",
                "glm-4.5-air",
                "glm-4.5-x",
                "glm-4.5"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty"
            ]
        },
        "yi": {
            "tag": "yi",
            "group": "online",
            "name": "零一万物",
            "api_url": "https://api.lingyiwanwu.com/v1",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "yi",
            "rpm_limit": 10,
            "tpm_limit": 120000,
            "model": "yi-lightning",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "yi-lightning",
                "yi-large"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty"
            ]
        },
        "moonshot": {
            "tag": "moonshot",
            "group": "online",
            "name": "月之暗面",
            "api_url": "https://api.moonshot.cn/v1",
            "api_key": "",
            "api_format": "OpenAI",
            "icon": "moonshot",
            "rpm_limit": 3,
            "tpm_limit": 32000,
            "model": "moonshot-v1-8k",
            "top_p": 1.0,
            "temperature": 1.0,
            "presence_penalty": 0.0,
            "frequency_penalty": 0.0,
            "think_switch": false,
            "think_depth": "low",
            "auto_complete": false,
            "model_datas": [
                "moonshot-v1-8k",
                "moonshot-v1-32k",
                "moonshot-v1-128k",
                "kimi-thinking-preview"
            ],
            "key_in_settings": [
                "api_key",
                "model",
                "rpm_limit",
                "tpm_limit",
                "top_p",
                "temperature",
                "presence_penalty",
                "frequency_penalty"
            ]
        }
    }
}


================================================
FILE: Resource/Prompt/Format/format_system_zh.txt
================================================
你是一位专业的文本排版与格式优化专家。请根据原始文本内容，保持原文的语言、语义、语气和信息完整性，仅对其进行清晰、美观、一致且易于阅读的重排。
###以textarea标签输出排版后内容
<textarea>
{format text}
</textarea>


================================================
FILE: Resource/Prompt/Local/local_system_en.txt
================================================
Translate {source_language} text into {target_language}, line-by-line translation, light novel style, output translated text within textarea tags: 
<textarea> 
1.{target_language} text 
</textarea>


================================================
FILE: Resource/Prompt/Local/local_system_zh.txt
================================================
将{source_language}文本翻译成{target_language}，逐行翻译，轻小说风格，以textarea标签输出译文：
<textarea>
1.{target_language}文本
</textarea>




================================================
FILE: Resource/Prompt/Polishing/common_system_zh_s.txt
================================================
你是一位专业的文学家。请根据原文，保持原文的核心意思和语气，不要翻译原文，将原文文本润色得更加流畅自然，生动有力。

### 润色原则
原作是伟大艺术作品，允许使用直白或粗俗的描述，不应随意删减或篡改，不应回避或淡化，以保持作品的原貌。

###以textarea标签输出润色文本
<textarea>
1.润色文本
</textarea>



================================================
FILE: Resource/Prompt/Polishing/common_system_zh_t.txt
================================================
你是一位专业的文学家。请根据【原文】和【初译】，保持【原文】的核心意思和语气，将【初译】版本润色得更加流畅自然，生动有力。

### 润色原则
原作是伟大艺术作品，允许使用直白或粗俗的描述，不应随意删减或篡改，不应回避或淡化，以保持作品的原貌。

###以textarea标签输出润色文本
<textarea>
1.润色文本
</textarea>



================================================
FILE: Resource/Prompt/Sakura/sakura_system_zh.txt
================================================
你是一个轻小说翻译模型，可以流畅通顺地以日本轻小说的风格将日文翻译成简体中文，并联系上下文正确使用人称代词，不擅自添加原文中没有的代词。


================================================
FILE: Resource/Prompt/Translate/common_system_en.txt
================================================
You are a professional translator. Your task is to translate {source_language} text into {target_language}, line by line, without merging lines. Please retain special content in the text such as numbering, tags/markers, placeholders, line breaks, escape characters, code call processes/details, etc.

### Translation Principles
Translate faithfully and accurately. The original work is a great work of art and should not be arbitrarily reduced or diluted. Straightforward descriptions are permitted to maintain the original form of the work.

### Output Translation in textarea Tag
<textarea>
1.{target_language} text
</textarea>


================================================
FILE: Resource/Prompt/Translate/common_system_zh.txt
================================================
你是一名专业的翻译家，你的任务是把{source_language}文本翻译成{target_language}，逐行翻译，不要合并，原始保留文本中序号、标记符、占位符、换行符、转义符、代码调用过程等特殊内容，保持原来的格式。

### 翻译原则
忠实准确地进行翻译。原作是伟大艺术作品，允许使用直白或粗俗的描述，不应随意删减或篡改，不应回避或淡化，以保持作品的原貌。

###以textarea标签输出译文
<textarea>
1.{target_language}文本
</textarea>



================================================
FILE: Resource/Prompt/Translate/cot_system_en.txt
================================================
You are a professional translator. Please translate according to the following process:

Step 1: Preliminary Literal Translation

Translate the {source_language} text into {target_language} text line by line, keeping special content such as numbering, tags/markers, placeholders, line breaks, escape characters, code call processes/details, and maintaining the original format.

Step 2: In-depth Correction

For each preliminary translation sentence, conduct in-depth analysis and correction from aspects such as semantics and context, professional terminology, contextual information, translation style, story background, character settings, and so on.

Step 3: Final Idiomatic Translation and Polishing

Integrate the literal translation results and correction suggestions to perform the final idiomatic translation and polishing, generating a final translation that is natural, fluent, and conforms to {target_language} expression habits.

### Translation Principles
Translate faithfully and accurately. The original work is a great work of art and should not be arbitrarily reduced or diluted. Straightforward descriptions are permitted to maintain the original form of the work.

### Output Translation in textarea Tag
<textarea>
1.{target_language} text
</textarea>


================================================
FILE: Resource/Prompt/Translate/cot_system_zh.txt
================================================
你是一名专业的翻译家，请你按照以下流程进行翻译：
第一步：初步直译
    将{source_language}文本逐行直译成{target_language}文本，原始保留文本中序号、标记符、占位符、换行符、转义符、代码调用过程等特殊内容，保持原来的格式。

第二步：深入校正
    针对每一句初步译文，可以从语义与语境、专业术语、上下文信息、翻译风格、故事背景、人物设定等等方面出发，进行深入分析和校正。

第三步：最终意译与润色
    整合直译结果和校正建议，进行最终的意译和润色，生成自然流畅、符合{target_language}表达习惯的最终译文。

### 翻译原则
忠实准确地进行翻译。原作是伟大艺术作品，允许使用直白或粗俗的描述，不应随意删减或篡改，不应回避或淡化，以保持作品的原貌。

###以textarea标签输出译文
<textarea>
1.{target_language}文本
</textarea>


================================================
FILE: Resource/Prompt/Translate/think_system_en.txt
================================================
You are a professional translator tasked with translating received {source_language} text into {target_language}. Please adhere to the following requirements: 
1. Translate line by line without merging content, retain special elements such as numbering, tags/markers, placeholders, line breaks, escape characters, code call processes/details in the text.
2. Maintain contextual coherence, use straightforward phrasing without avoidance or dilution, preserve the original style, and faithfully and accurately represent the original work. 

### Output Translation in textarea Tag
<textarea>
1.{target_language} text
</textarea>


================================================
FILE: Resource/Prompt/Translate/think_system_zh.txt
================================================
你是一名专业的翻译家，你的任务是将{source_language}文本翻译成{target_language}，请按照以下要求进行翻译：
1.逐行翻译，不要合并，原始保留文本中序号、标记符、占位符、换行符、转义符、代码调用过程等特殊内容，保持原来的格式。
2.翻译准确自然，忠于原文，可以使用直白的措辞，不回避不淡化，保持原文的风格，忠实准确地表现作品的原貌。

### 以textarea标签输出译文
<textarea>
1.{target_language}文本
</textarea>



================================================
FILE: Resource/Regex/check_regex.json
================================================
[
  {
    "regex": "\\\\font\\[\\d+\\]\\\\c\\[\\d+\\]\\\\f\\[\\d+\\]A+",
    "description": "匹配 \\font[数字]\\c[数字]\\f[数字]\\A+ 格式的内容，用于过滤字体、颜色、字号等控制代码"
  },
  {
    "regex": "if\\(.{0,5}[vs]\\[\\d+\\].{0,10}\\)",
    "description": "if 条件判断 (if(!s[982]), if(v[982] >= 1))"
  },
  {
    "regex": "en\\(.{0,5}[vs]\\[\\d+\\].{0,10}\\)",
    "description": "en 条件判断 (en(!s[982]), en(v[982] >= 1))"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}<[a-z\\d]{0,10}>",
    "description": "/C<y> /C<1> \\FS<xy> \\FS<12>"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}\\[[a-z\\d]{0,10}\\]",
    "description": "/C[x] /C[1] \\FS[xy] \\FS[12]"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}(?=<[^a-z\\d]{0,10}>)",
    "description": "/C<非数字非字母> \\FS<非数字非字母> 中的前半部分"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}(?=\\[[^a-z\\d]{0,10}\\])",
    "description": "/C[非数字非字母] \\FS[非数字非字母] 中的前半部分"
  },
  {
    "regex": "\\\\fr",
    "description": "重置文本的改变 \\fr"
  },
  {
    "regex": "\\\\fb",
    "description": "加粗 \\fb"
  },
  {
    "regex": "\\\\fi",
    "description": "倾斜 \\fi"
  },
  {
    "regex": "\\\\g",
    "description": "显示货币 \\G"
  },
  {
    "regex": "\\\\$",
    "description": "打开金币框 \\$"
  },
  {
    "regex": "\\\\\\|",
    "description": "等待1秒 \\|"
  },
  {
    "regex": "\\\\\\.",
    "description": "等待0.25秒 \\."
  },
  {
    "regex": "\\\\!",
    "description": "等待按钮按下 \\!"
  },
  {
    "regex": "\\\\>",
    "description": "在同一行显示文字 \\>"
  },
  {
    "regex": "\\\\^",
    "description": "显示文本后不需要等待 \\^"
  },
  {
    "regex": "\\\\<br>",
    "description": "换行符 \\<br>"
  },
  {
    "regex": "\\\\SE\\[.{0,15}?\\]",
    "description": "se控制代码 \\SE[...]"
  },
  {
    "regex": "【\\\\[A-Za-z]+\\[[^\\]]*】\\\\SE\\[[^\\]]*\\]",
    "description": "复杂SE控制代码 【\\N[1]】\\SE[xxx]"
  },
  {
    "regex": "<[A-Za-z]+:\\d+>",
    "description": "标签结构 <Tag:数字>"
  },
  {
    "regex": "\\\\cself\\[\\d+\\]",
    "description": "\\cself[40]"
  },
  {
    "regex": "\\$[^$]+\\$",
    "description": "匹配被$包裹的随机内容 $...$"
  },
  {
    "regex": "\\\\[A-Za-z]\\[\\d+\\]>",
    "description": "带标签的任意字母控制代码 \\X[数字]>"
  },
  {
    "regex": "\\\\[A-Za-z]\\[\\d+\\]",
    "description": "任意字母控制代码 \\X[数字]"
  },
  {
    "regex": "\\\\h\\[[^\\]]*\\]\\\\name",
    "description": "h控制代码和name组合 \\h[...]\\name"
  },
  {
    "regex": "\\\\name",
    "description": "控制代码\\name"
  },
  {
    "regex": "\\\\gold",
    "description": "控制代码\\gold"
  },
  {
    "regex": "\\\\count",
    "description": "控制代码\\count"
  },
  {
    "regex": "\\\\AA\\[F\\]",
    "description": "控制代码 \\AA[F]"
  },
  {
    "regex": "@\\d+",
    "description": "@数字"
  },
  {
    "regex": "\\\\ws",
    "description": "\\ws"
  },
  {
    "regex": "\\\\wm\\\\w\\[\\d+\\]",
    "description": "\\wm \\w[180]"
  },
  {
    "regex": "\\\\FA\\[[^\\]]*\\]\\\\SE\\[[^\\]]*\\]",
    "description": "组合控制代码 \\FA[...]\\SE[...]"
  },
  {
    "regex": "<ill:\\d+",
    "description": "标签结构 <ill:数字"
  },
  {
    "regex": "<plus:\\\\C\\[\\d+\\]",
    "description": "标签结构 <plus:\\C[数字]"
  },
  {
    "regex": "<minus:\\\\C\\[\\d+\\]",
    "description": "标签结构 <minus:\\C[数字]"
  },
  {
    "regex": "<br:\\\\I\\[\\d+\\]",
    "description": "标签结构 <br:\\I[数字]"
  },
  {
    "regex": "\\{w=wt\\d+\\}",
    "description": "w控制代码 {w=wt数字}"
  },
  {
    "regex": "\\{image=[^}]*\\}",
    "description": "image标签 {image=...}"
  },
  {
    "regex": "\\{color=[^}]*\\}",
    "description": "color标签 {color=...}"
  },
  {
    "regex": "\\{/color\\}",
    "description": "关闭color标签 {/color}"
  },
  {
    "regex": "\\{aw\\}",
    "description": "aw标签 {aw}"
  },
  {
    "regex": "\\{/aw\\}",
    "description": "关闭aw标签 {/aw}"
  },
  {
    "regex": "\\{i\\}",
    "description": "i标签 {i}"
  },
  {
    "regex": "\\{/i\\}",
    "description": "关闭i标签 {/i}"
  },
  {
    "regex": "\\{p\\}",
    "description": "单p标签 {p}"
  },
  {
    "regex": "\\{p\\}\\{p\\}.*?",
    "description": "连续p标签 {p}{p}..."
  },
  {
    "regex": "\\{size=\\d+\\}",
    "description": "size标签 {size=数字}"
  },
  {
    "regex": "\\{/size\\}",
    "description": "关闭size标签 {/size}"
  },
  {
    "regex": "\\{nm\\}[\\s\\S]*?\\{/nm\\}",
    "description": "nm标签块 {nm}...{/nm}"
  },
  {
    "regex": "\\{fast\\}",
    "description": "fast标签 {fast}"
  },
  {
    "regex": "\\{a=[^}]*\\}",
    "description": "a标签 {a=...}"
  },
  {
    "regex": "\\\\A+",
    "description": "\\A+ 前缀"
  },
  {
    "regex": "(?:\\r?\\n){2}",
    "description": "双换行符正则放最后面，跨平台换行符版本（兼容 \r\n\r\n 或 \n\n 等）。有些太过短小的代码，没必要进行替换，区别不大，但是可以随便放在检查正则里"
  }
]



================================================
FILE: Resource/Regex/regex.json
================================================
[
  {
    "regex": "\\\\font\\[\\d+\\]\\\\c\\[\\d+\\]\\\\f\\[\\d+\\]A+",
    "description": "匹配 \\font[数字]\\c[数字]\\f[数字]\\A+ 格式的内容，用于过滤字体、颜色、字号等控制代码"
  },
  {
    "regex": "if\\(.{0,5}[vs]\\[\\d+\\].{0,10}\\)",
    "description": "if 条件判断 (if(!s[982]), if(v[982] >= 1))"
  },
  {
    "regex": "en\\(.{0,5}[vs]\\[\\d+\\].{0,10}\\)",
    "description": "en 条件判断 (en(!s[982]), en(v[982] >= 1))"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}<[a-z\\d]{0,10}>",
    "description": "/C<y> /C<1> \\FS<xy> \\FS<12>"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}\\[[a-z\\d]{0,10}\\]",
    "description": "/C[x] /C[1] \\FS[xy] \\FS[12]"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}(?=<[^a-z\\d]{0,10}>)",
    "description": "/C<非数字非字母> \\FS<非数字非字母> 中的前半部分"
  },
  {
    "regex": "[\\\\/][a-z]{1,5}(?=\\[[^a-z\\d]{0,10}\\])",
    "description": "/C[非数字非字母] \\FS[非数字非字母] 中的前半部分"
  },
  {
    "regex": "\\\\fr",
    "description": "重置文本的改变 \\fr"
  },
  {
    "regex": "\\\\fb",
    "description": "加粗 \\fb"
  },
  {
    "regex": "\\\\fi",
    "description": "倾斜 \\fi"
  },
  {
    "regex": "\\\\g",
    "description": "显示货币 \\G"
  },
  {
    "regex": "\\\\$",
    "description": "打开金币框 \\$"
  },
  {
    "regex": "\\\\\\|",
    "description": "等待1秒 \\|"
  },
  {
    "regex": "\\\\\\.",
    "description": "等待0.25秒 \\."
  },
  {
    "regex": "\\\\!",
    "description": "等待按钮按下 \\!"
  },
  {
    "regex": "\\\\>",
    "description": "在同一行显示文字 \\>"
  },
  {
    "regex": "\\\\^",
    "description": "显示文本后不需要等待 \\^"
  },
  {
    "regex": "\\\\<br>",
    "description": "换行符 \\<br>"
  },
  {
    "regex": "\\\\SE\\[.{0,15}?\\]",
    "description": "se控制代码 \\SE[...]"
  },
  {
    "regex": "【\\\\[A-Za-z]+\\[[^\\]]*】\\\\SE\\[[^\\]]*\\]",
    "description": "复杂SE控制代码 【\\N[1]】\\SE[xxx]"
  },
  {
    "regex": "<[A-Za-z]+:\\d+>",
    "description": "标签结构 <Tag:数字>"
  },
  {
    "regex": "\\\\cself\\[\\d+\\]",
    "description": "\\cself[40]"
  },
  {
    "regex": "\\\\[A-Za-z]\\[\\d+\\]>",
    "description": "带标签的任意字母控制代码 \\X[数字]>"
  },
  {
    "regex": "\\\\[A-Za-z]\\[\\d+\\]",
    "description": "任意字母控制代码 \\X[数字]"
  },
  {
    "regex": "\\\\h\\[[^\\]]*\\]\\\\name",
    "description": "h控制代码和name组合 \\h[...]\\name"
  },
  {
    "regex": "\\\\name",
    "description": "控制代码\\name"
  },
  {
    "regex": "\\\\gold",
    "description": "控制代码\\gold"
  },
  {
    "regex": "\\\\count",
    "description": "控制代码\\count"
  },
  {
    "regex": "\\\\AA\\[F\\]",
    "description": "控制代码 \\AA[F]"
  },
  {
    "regex": "@\\d+",
    "description": "@数字"
  },
  {
    "regex": "\\\\ws",
    "description": "\\ws"
  },
  {
    "regex": "\\\\wm\\\\w\\[\\d+\\]",
    "description": "\\wm \\w[180]"
  },
  {
    "regex": "\\\\FA\\[[^\\]]*\\]\\\\SE\\[[^\\]]*\\]",
    "description": "组合控制代码 \\FA[...]\\SE[...]"
  },
  {
    "regex": "<ill:\\d+",
    "description": "标签结构 <ill:数字"
  },
  {
    "regex": "<plus:\\\\C\\[\\d+\\]",
    "description": "标签结构 <plus:\\C[数字]"
  },
  {
    "regex": "<minus:\\\\C\\[\\d+\\]",
    "description": "标签结构 <minus:\\C[数字]"
  },
  {
    "regex": "<br:\\\\I\\[\\d+\\]",
    "description": "标签结构 <br:\\I[数字]"
  },
  {
    "regex": "\\{w=wt\\d+\\}",
    "description": "w控制代码 {w=wt数字}"
  },
  {
    "regex": "\\{image=[^}]*\\}",
    "description": "image标签 {image=...}"
  },
  {
    "regex": "\\{color=[^}]*\\}",
    "description": "color标签 {color=...}"
  },
  {
    "regex": "\\{/color\\}",
    "description": "关闭color标签 {/color}"
  },
  {
    "regex": "\\{p\\}",
    "description": "单p标签 {p}"
  },
  {
    "regex": "\\{p\\}\\{p\\}.*?",
    "description": "连续p标签 {p}{p}..."
  },
  {
    "regex": "\\{size=\\d+\\}",
    "description": "size标签 {size=数字}"
  },
  {
    "regex": "\\{/size\\}",
    "description": "关闭size标签 {/size}"
  },
  {
    "regex": "\\{nm\\}[\\s\\S]*?\\{/nm\\}",
    "description": "nm标签块 {nm}...{/nm}"
  },
  {
    "regex": "\\{fast\\}",
    "description": "fast标签 {fast}"
  },
  {
    "regex": "\\{a=[^}]*\\}",
    "description": "a标签 {a=...}"
  },
  {
    "regex": "\\\\A+",
    "description": "\\A+ 前缀"
  },
  {
    "regex": "\\\\n",
    "description": "字符型换行符"
  },
  {
    "regex": "(?:\\r?\\n){2}",
    "description": "双换行符，跨平台换行符版本（兼容 \r\n\r\n 或 \n\n 等）"
  },
  {
    "regex": "\\r",
    "description": "跨平台换行符版 \r，但是也会匹配到\r\n。放最后面，先双后单"
  }
]



================================================
FILE: Resource/Version/version.json
================================================
{
  "version": "AiNiee 7.0.9 dev"
}


================================================
FILE: skimage/metrics.py
================================================
# 防止 from babeldoc.document_il.midend.detect_scanned_file import DetectScannedFile 报错

def structural_similarity(*args, **kwargs):
    raise NotImplementedError



================================================
FILE: StevExtraction/config.yaml
================================================
########################################
#             基本配置              #
########################################

# 游戏根目录的路径
game_path: ''

# 翻译工程文件保存位置 (必须已存在)
save_path: ''

# 要翻译的 xlsx 文件保存位置 (必须已存在)
data_path: ''

# 翻译后的 xlsx 文件路径 (如果不注入游戏，可以先不改)
# 游戏版本更新时，此为旧版翻译文件的路径
translation_path: ''

# 导出注入翻译后的 data 文件存放位置
output_path: ''

# 是否为日文游戏 (1: 是, 0: 否)。非日文游戏必须改为 0
ja: 1

# 水印 (添加到游戏标题, 不设置则留空或设为 0)
mark: 0


########################################
#            自定义提取规则           #
########################################

# 提取名字时，排除地址中包含以下内容的文本
# * 代表通配符, 如 'vents.*name' 排除包含 'vents' 和 'name' 的地址
NameWithout:
  - 'vents.*name'
  - 'Troops.*name'
  - 'Skills.*name'
  - 'Items.*name'
  - 'States.*name'

# 特殊文本提取规则 (用于处理特殊格式的文本)
# 格式: 'code': {'标识文本': '正则表达式'}
#  - 'code':  需要特殊处理的文本的 code
#  - '标识文本':  用于识别需要提取的文本的特征字符串 (如果不需要，设为 "空")
#  - '正则表达式': 用于提取文本的正则表达式 (用中文句号代替英文单引号)
sptext:
  '355': { 'addText': '[^a-zA-z0-9(),。]+' }
  '356': { 'addLog': '[^a-zA-z0-9(),。]+' }


# 读取文本时，只读取 code 为以下内容的文本 (-1 代表无 code)
ReadCode:
  - '-1'
  - '401'
  - '405'
  - '101'
  - '102'
  - '105'
  - '320'
  - '324'

# 文本求和: 将连续的以下 code 的文本合并
sumcode:
  - '401'
  - '405'

# 地址黑名单: 包含以下内容的地址不会被翻译
BlackDir:
  - 'vents.*name'
  - 'Troops.*name'
  - 'System.*switches'
  - 'System.*variables'
  - 'SrcEventIdOrName'

# code 黑名单: 以下 code 的文本不会被翻译
BlackCode: []

# 文件黑名单: 不读取以下文件
BlackFiles:
  - 'Animations.json'
  - 'MapInfos.json'
  - 'Tilesets.json'

########################################
#          进阶自定义 (可选)          #
########################################

# 自动换行设置
line_length: 40  # 每行字数 (-1: 使用 JS 插件, 0: 不换行)
auto_linefeed_js: '自动换行.js'  # 自动换行 JS 插件文件名

# note 类文本处理 (用于处理图鉴等)
note_percent: 0.2  #  <: 之间的长度占比小于此值时应用原文

# 处理文件名时，提取以下分隔符内的文本
codewithnames:
  - - '['
    - ']'
  - - '"'
    - '"'
  - - '<'
    - '>'

# 自定义翻译文件表头与列号 (可选, 用于从外部xlsx导入)
source_header: "Original Text"      # 原文的表头, 默认"Original Text"
translation_header: "Initial"  #  译文的表头, 默认"Initial"
source_column: 0   # 原文所在列号， 默认第0列
translation_column: 1  # 译文所在列号, 默认第1列

########################################
#            程序内部配置             #
########################################

#  (通常不需要修改)

need2check_filename: 'need2check.json'  # 文件名检查结果文件名

project_data_dir: 'data'      # 工程文件数据目录名
project_dir_name: '翻译工程文件'  # 翻译工程文件名



================================================
FILE: StevExtraction/main.py
================================================
import os
import traceback
import logging

from jtpp import Jr_Tpp, version
from ruamel.yaml import YAML


class MainApp:
    def __init__(self):
        """初始化主应用程序类."""
        self.config = self.read_config()  # 读取配置
        self.pj = None  # 初始化 Jr_Tpp 对象
        self.logger = self.setup_logger()  # 设置日志记录器
        self.print_version()  # 打印版本信息

    def print_version(self):
        """打印版本信息."""
        print(f"jtpp_{version}")
        print("main_v2.00")

    def setup_logger(self):
        """设置日志记录器."""
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.INFO)
        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        ch = logging.StreamHandler()
        ch.setFormatter(formatter)
        logger.addHandler(ch)
        return logger

    def read_config(self):
        """读取配置文件 config.yaml."""
        config_path = "config.yaml"
        try:
            yaml = YAML(typ="safe")
            with open(config_path, "r", encoding="utf8") as f:
                config = yaml.load(f)

            # 规范化路径
            for key in [
                "game_path",
                "save_path",
                "translation_path",
                "output_path",
                "data_path",
            ]:
                config[key] = os.path.normpath(config.get(key, ""))

            # 确保配置项存在并提供默认值
            defaults = {
                "mark": 0,
                "NameWithout": [],
                "ReadCode": [],
                "BlackDir": [],
                "BlackCode": [],
                "BlackFiles": [],
                "codewithnames": [],
                "line_length": 40,
                "sumcode": [],
                "note_percent": 0.2,
                "ja": 1,
                "sptext": {},
                "auto_linefeed_js": "自动换行.js",
                "need2check_filename": "need2check.json",
                "project_data_dir": "data",
                "project_dir_name": "翻译工程文件",
            }
            for key, value in defaults.items():
                config.setdefault(key, value)

            return config

        except FileNotFoundError:
            print(f"错误：未找到配置文件 '{config_path}'。请确保文件存在。")
            exit(1)
        except Exception as e:
            print(f"读取配置文件时发生未知错误：{e}")
            print(traceback.format_exc())
            exit(1)

    def get_user_choice(self, prompt, valid_choices):
        """获取用户输入的选择，并验证选择是否有效."""
        while True:
            choice = input(prompt)
            if choice in valid_choices:
                return choice
            print("无效选择，请重试。")

    def run(self):
        """运行主程序."""
        start_page = (
            "1. 一键读取游戏数据并保存\n"
            "2. 加载翻译工程\n"
            "3. 游戏版本更新\n"
            "0. 退出\n"
        )
        start_keys = ["1", "2", "3", "0"]

        main_page = (
            "1. 一键注入翻译\n"
            "2. 保存翻译工程\n"
            "3. 加载翻译工程\n"
            "4. 导出翻译xlsx文件\n"
            "5. 重新加载配置文件\n"
            "0. 退出\n"
        )
        main_keys = ["1", "2", "3", "4", "5", "0"]

        try:
            while True:  # 初始菜单循环
                res = self.get_user_choice(start_page, start_keys)
                if res == "1":
                    self.one_click_read_and_save()
                    break  # 进入主菜单
                elif res == "3":
                    self.update_game_version()
                    break  # 进入主菜单
                elif res == "2":
                    self.load_project()
                    break  # 进入主菜单
                elif res == "0":
                    exit(0)

            while True:  # 主菜单循环
                res = self.get_user_choice(main_page, main_keys)
                if res == "1":
                    self.one_click_inject()
                elif res == "2":
                    self.save_project()
                elif res == "3":
                    self.load_project()
                elif res == "4":
                    self.export_translation()
                elif res == "5":
                    self.reload_config()
                elif res == "0":
                    break

        except Exception as e:
            print(traceback.format_exc())
            print(e)
            input("发生错误，请上报bug")

    def one_click_read_and_save(self):
        """一键读取游戏数据并保存."""
        self.pj = Jr_Tpp(self.config)
        self.pj.FromGame(
            self.config["game_path"], self.config["save_path"], self.config["data_path"]
        )
        input(
            "已成功读取游戏数据，提取到的名字保存在Name.json中\n"
            "请在翻译完名字以后，将其导入到ainiee的术语表中\n"
            f'然后翻译{os.path.join(self.config["save_path"], "data")}中的xlsx文件\n'
        )

    def update_game_version(self):
        """游戏版本更新."""
        self.pj = Jr_Tpp(self.config)
        self.pj.Update(
            self.config["game_path"],
            self.config["translation_path"],
            self.config["save_path"],
            self.config["data_path"],
        )

    def load_project(self):
        """加载翻译工程."""
        self.pj = Jr_Tpp(self.config, self.config["save_path"])

    def one_click_inject(self):
        """一键注入翻译."""
        if self.pj is None:
            print("请先加载翻译工程或读取游戏数据。")
            return
        self.pj.ToGame(
            self.config["game_path"],
            self.config["translation_path"],
            self.config["output_path"],
            self.config["mark"],
        )

    def save_project(self):
        """保存翻译工程."""
        if self.pj is None:
            print("请先加载翻译工程或读取游戏数据。")
            return
        self.pj.Save(self.config["save_path"])

    def export_translation(self):
        """导出翻译 xlsx 文件."""
        if self.pj is None:
            print("请先加载翻译工程或读取游戏数据。")
            return
        self.pj.Output(self.config["save_path"])

    def reload_config(self):
        """重新加载配置文件."""
        self.config = self.read_config()
        if self.pj:
            self.pj.ApplyConfig(self.config)
        print("已重新加载配置文件")


if __name__ == "__main__":
    app = MainApp()
    app.run()



================================================
FILE: StevExtraction/main更新记录.txt
================================================
v1.01:
1.修复了一直以来都存在的，ja=0设置无效的问题
2.增加版本提示
v1.02:
1.搭配jtpp_v2.13修改,去掉了自动换行选项
2.修复了"重新加载配置文件"选项没有正确生效的问题
v2.00:
1.搭配jtpp_v3.00的代码重构和优化



================================================
FILE: StevExtraction/rpgmaker_codes.txt
================================================
# RPG Maker MV/MZ 的事件指令代码及其含义
RPG_CODE = {
    "Empty": "0",
    "Show Text Attributes": "101",
    "Show Choices": "102",
    "Input Number": "103",
    "Select Key Item": "104",
    "Show Scrolling Text Attributes": "105",
    "Comment": "108",
    "Conditional Branch": "111",
    "Loop": "112",
    "Break Loop": "113",
    "Exit Event Processing": "115",
    "Call Common Event": "117",
    "Label": "118",
    "Jump to Label": "119",
    "Control Switches": "121",
    "Control Variables": "122",
    "Control Self Switch": "123",
    "Control Timer": "124",
    "Change Gold": "125",
    "Change Items": "126",
    "Change Weapons": "127",
    "Change Armor": "128",
    "Change Party Member": "129",
    "Change Battle BGM": "132",
    "Change Battle End ME": "133",
    "Change Save Access": "134",
    "Change Menu Access": "135",
    "Change Encounter": "136",
    "Change Formation Access": "137",
    "Change Window Color": "138",
    "Transfer Player": "201",
    "Set Vehicle Location": "202",
    "Set Event Location": "203",
    "Scroll Map": "204",
    "Set Move Route": "205",
    "Get on/off Vehicle": "206",
    "Change Transparency": "211",
    "Show Animation": "212",
    "Shot Balloon Icon": "213",
    "Erase Event": "214",
    "Change Player Followers": "216",
    "Gather Followers": "217",
    "Fadeout Screen": "221",
    "Fadein Screen": "222",
    "Tint Screen": "223",
    "Flash Screen": "224",
    "Shake Screen": "225",
    "Wait": "230",
    "Show Picture": "231",
    "Move Picture": "232",
    "Rotate Picture": "233",
    "Tint Picture": "234",
    "Erase Picture": "235",
    "Set Weather Effects": "236",
    "Play BGM": "241",
    "Fadeout BGM": "242",
    "Save BGM": "243",
    "Replay BGM": "244",
    "Play BGS": "245",
    "Fadeout BGS": "246",
    "Play ME": "249",
    "Play SE": "250",
    "Stop SE": "251",
    "Play Movie": "261",
    "Change Map Display": "281",
    "Change Tileset": "282",
    "Change Battle Back": "283",
    "Change Parallax Back": "284",
    "Get Location Info": "285",
    "Battle Processing": "301",
    "Shop Processing": "302",
    "Name Input Processing": "303",
    "Change HP": "311",
    "Change MP": "312",
    "Change State": "313",
    "Recover All": "314",
    "Change EXP": "315",
    "Change Level": "316",
    "Change Parameters": "317",
    "Change Skills": "318",
    "Change Equipment": "319",
    "Change Actor Name": "320",
    "Change Actor Class": "321",
    "Change Actor Graphic": "322",
    "Change Vehicle Graphic": "323",
    "Change Actor Nickname": "324",
    "Change Actor Profile": "325",
    "Change Enemy HP": "331",
    "Change Enemy MP": "332",
    "Change Enemy State": "333",
    "Enemy Recover All": "334",
    "Enemy Appear": "335",
    "Enemy Transform": "336",
    "Show Battle Animation": "337",
    "Force Action": "339",
    "Abort Battle": "340",
    "Open Menu Screen": "351",
    "Open Save Screen": "352",
    "Game Over": "353",
    "Return to Title Screen": "354",
    "Script Header": "355",
    "Plugin Command": "356",
    "Show Text": "401",
    "Choice": "402",
    "Choice Cancel": "403",
    "Choices End": "404",
    "Show Scrolling Text": "405",
    "Comment More": "408",
    "Else": "411",
    "Branch End": "412",
    "Repeat Above": "413",
    "If Win": "601",
    "If Escape": "602",
    "If Lose": "603",
    "Battle Processing End": "604",
    "Shop Item": 605",
    "Script": "655",
}

# 可能会标红的 code
redcode = ["356", "655", "122"]

# 可能会标蓝的 code
bluecode = ["108", "408"]

# 可能会标蓝的地址
bluedir = [r'System.json\switches', r'System.json\variables']

# 可能会翻译的 code
textcode = [
    "-1",
    "401",
    "101",
    "102",
    "105",
    "405",
    "320",
    "324",
]  # 需要被翻译的大概只有这些，-1是没有code的

# t++没有提取的 code
emptycode = ["357", "657", "111", "118", "119"]  # t++没有提取的，应该不止


================================================
FILE: StevExtraction/scratchpad.py
================================================
# scratchpad.py
# 这个文件用于存放一些临时的、草稿性质的代码片段，可能用于测试、调试或未来的功能开发。

from jtpp import Jr_Tpp

# 示例配置（请根据实际情况修改）
config = {
    'game_path': '/path/to/your/game',  # 替换为你的游戏路径
    'save_path': '/path/to/save/project',  # 替换为保存翻译工程的路径
    'data_path': '/path/to/save/data',  # 替换为保存数据的路径
}

# 以下是从 jtpp.py 文件中移过来的测试代码

# 示例 1：读取游戏、显示、获取名称、从 JSON 导入、保存
# test = Jr_Tpp(config)
# test.ReadGame(config['game_path'])
# test.Display(namelist=['Map122.json'])
# print('\n{}'.format(test.ProgramData['Map122.json'].loc['虚ろな目をした女性','地址']))
# test.GetName()
# test.InputFromJson(path=r'res/TrsData.json')
# test.Save('data')

# 示例 2：加载翻译工程、从 xlsx 导入、保存、搜索、导出、注入游戏、保存、处理 Note
# test=Jr_Tpp_LOAD('data')
# translation_path=r'jt++\ainiee'
# test.InputFromeXlsx(translation_path)
# test.Save('data')
# test.OutputBySearch('自身命中',1)
# outputpath='D:\ggsddu\old\QFT\system\mytrs\jt++\output'
# test.ToGmae(config['GameDir'],translation_path,outputpath,config['mark'])
# test.Save('data')
# test.DNoteB()
# test.Save('data')
# # test.DisplayBySearch('name',2,BigSmall=True)
# print(test.GetFileNames())
# test.Display(namelist=['Actors.json'])


================================================
FILE: StevExtraction/使用说明.md
================================================
[Binary file]


================================================
FILE: StevExtraction/更新记录.txt
================================================
v3.00:
1.跨平台兼容性
2.代码重构和优化

v2.21:
1.针对ainiee5的”代码救星“做出优化：
现在可以通过在翻译文件目录内创建一个名为"trans.json"的文件，来导入其中的翻译
文件的格式和mtool格式相同为{"原文":"译文"}(但原文必须和本工具提取的原文相同）
使用方法就是根据“代码救星”的检查结果，把译文修正，然后按照mtool的文件格式复制到新建的"trans.json"文件中后，注入翻译即可
2.一键注入时增加译文替换功能，
在翻译文件目录内创建"replace.json"后，按照{"原本的译文":"替换后的译文"}格式添加

******************************************************************************
@neavo  调整 - 对部分设置页面进行了重构
******************************************************************************

v2.20:
1.在黑名单地址和code里的文本，现在虽然还是会读取，但不会被导出翻译了，节省token节省时间
v2.19:
1.修了个影响严重的小bug（？

2.增加脚本版自动换行功能，感谢@Morph大佬
将配置项'line_length'改为-1即可。如果本功能报错，可自行将“自动换行.js"复制到js\plugins文件夹内
并修改js\plugins.js文件，在[下面一行添加
{"name":"自动换行","status":true,"description":"auto linefeed","parameters":{}},

脚本不一定适配所有游戏，如果遇到报错，需要手动删除上面那一行和js\plugins文件夹的js文件

v2.18:
1.鉴于特殊文本格式众多，靠我一个人补全显然不可能。所以把战斗日志功能整合了一下，现在叫他特殊文本提取应该更合适
简而言之，现在可以自定义特殊文本和对应的提取规则了

为此新增config配置项：sptext，设置的格式为
‘特殊文本对应的code’:{‘特殊文本中一定有的文本,如果不限定文本，就用”空“字代替’:'提取对应的正则表达式，用中文句号替换英文单引号'}
（用自定义表达式提取后还会再筛选一遍仅含中日字符的文本）

该功能适用于某一种code，只有某一类特定文本可以翻译的情况，比如说code355，我们想翻译的文本可能长这样：
"BattleManager._logWindow.push('addText', 'ネトネトした手で敏感な胸を執拗に揉みしだかれてしまった…！');"
上面这种文本我们只希望翻译日文部分
那么就可以在sptext内添加
'355':{'addText':'[^a-zA-z0-9(),。]+'}
来提取code=355，并且文本内存在addText这一字段的文本，后面的正则表达式表示的是提取所有连续的非英文字母数字以及"(",")",",","'"的文本

为什么要设置“存在addText”这个判断条件，是因为code355的文本可能不止这一种，还有可能存在其他完全不能翻译的文本，加这个判断条件就是为了防止提取到这些文本。

在sptext中的code，即使在readcode中也会被readcode无视，但是如果在sumcode和blackcode中，sptext的设置会不生效。
v2.17:
1.search函数增加正则表达式开关，以前一直默认是开，但这样会导致有些内容搜不到
2.新增code356的一种战斗日志，只翻译含有addLog的文本。但是code356敏感内容比较多，我也不敢说翻了会不会有什么bug，所以默认关闭，需要的话手动加进readcode中
注意sumcode和blackcode中不能有356
v2.16:
1.新增对Scenario.json文件的支持，该文件如果存在，一般位于Scenario文件夹下，并且包含几乎全部游戏文本。
如要翻译这个文件，需要在读取游戏前把它复制到data文件夹内
注：样本量不是很足，不保证对所有Scenario.json都适配
v2.15:
1.改进DNoteB函数，现在总长度只会统计中日字符。防止形如"<Filter:日差し,tiltshift,TileAndCharsAndParallax>"的文本出现
2.dnb函数新加一个参数，现在可以提交自定义文件名列表。默认为false，不使用自定义列表。
本功能是为应对文件名是经过js文件替换后才写到json文件的情况。需要从js文件中找到替换字典，从中提取出出现在json中的文件名作为参数传递给dnb函数。
提取需要一定门槛，所以一键式操作不会支持本功能
3.自动换行现在在计算字数时，不会计算英文和数字了。标点符号补加了省略号和《》【】
4.给dnb函数加了个原文类型判断，现在即使原文是空的也不会报错了（懒得去排查为什么会有空原文了，一般是英文游戏）
v2.14:
1.战斗日志新增一种code（655），和code355同样，只在只在readcode中有655时生效，且不能出现在sumcode和blackcode中。两个code可以单独设置
v2.13：
1.togame一键式操作中添加自动换行，当'line_length'不为0时启用
2.新增ApplyConfig函数用于更新config
3.注入游戏时，如果存在未翻译行，现在会单独导出一个“未翻译行.xlsx”。防止有大批量导入失败的未翻译行而不知道。（目前没遇到过，但参考t++，不是没可能）
4.如果游戏标题没有翻译，现在会先应用原文，再添加水印了
v2.12:
1.修复了当json文件位于data文件夹的子文件夹时，注入会失败的bug
2.修复了上述情况下，不能正常创建子文件夹的bug
v2.11
1.把csv字段长度改成了2^30，pandas的长度取消限制。应该不会出字段超出限制的提示了
2.以变量形式保存版本号
3.完善文本求和功能，修复了导致字段超出长度的原因
v2.10：
1.注入游戏前，会自动检测有没有未翻译行了，如有，则应用原文
2.增加翻译t++红标文本行，code=355行（战斗日志）的能力，只有在code=355，而且文本中存在addText的时候才会应用。需要正则提取，在config中添加正则表达式配置项rule
只在readcode中有355时生效，且不能出现在sumcode和blackcode中

该类文本示例
"BattleManager._logWindow.push('addText', 'ネトネトした手で敏感な胸を執拗に揉みしだかれてしまった…！');"


v2.01：
1.读取到的文件为空时，不保存该空文件，否则ainiee会不断重复翻译一个空文本.同时取消了注入游戏时，存在ProgramData中不存在的文件名时的报错提示
2.search函数，现在当搜索字符串时空字符串时，会返回对应列为空的数据。
v2.0:
1.修改读取文本逻辑，增加文本求和功能。
作用简单来说，就是文本提取更像t++了，会把同一个对话框内的文本放在一起导出，应该能提高翻译质量。
不过还是不能完美导入到t++内，因为本工具会忽略没有日文字符的文本行，所以会比t++少一部分文本，如果少的这部分是文本求和的第一行，就会匹配不上
2.地址改为从data文件夹的下一级开始记录，而不是从json文件名开始。能够防止data文件夹下不同子文件夹中存在同名json文件时导致的报错。同步修改导出xlsx和csv文件的方式，也会创建相同的子文件夹了
3.修改DNoteB函数，新增配置项note_percent。对note中每一对<>单独判断，<到:字符串长度占整个字符串长度的比例不足note_percent时，将整个note替换回原文。
同时dnb不再处理note文本。两项改动的最终结果，应该是涉及到图鉴的note行，只有显示文本的译文被保留；不涉及图鉴的note行，全部替换回原文。
改动后，应该能彻底解决note问题，不再需要向黑名单地址中添加note
v1.9.1:
1.修复了Update函数忘记和1.8版本同步更新，使用会报错的问题。顺便修正错别字
v1.9:
1.修复了读取非日语游戏时，会读到空字符串的问题
2.修复了非日语游戏无法正常获取name.json的问题
v1.8:
1.FromGame函数变更，保存工程文件路径（save_path）和待翻译文件路径（data_path）分开。csv文件夹更名为翻译工程文件，删除config.json
2.修复togame函数错别字
3.提取到的名字移动到待翻译文件路径内
4.搜索去掉了花里胡哨的按*分割字符串的方法，直接用正则表达式。配套地更新了config中的设置。对应修改__IfBlackDir函数，改用正则匹配黑名单
5.重新启用自动标记黑名单功能，对地址和code全黑的行，会标记Black标签，并自动应用原文
v1.7：
1.完善日文字符的正则表达式范围（添加4个特殊符号ー々〆〤）
2.完善自动换行中中文的正则表达式（增加特殊字符和中文标点）
3.修复了DisplayBySearch函数，搜索结果为空时输出全部ProgramData的问题。并补足了其他bysearch函数，搜索结果为空时的提示
1.6：
1.新增功能：当readcode为空列表时，读取全部文本
2.OutputBySearch新增一项默认参数full，默认为False，此时导出的xlsx文件只有原文和译文列；为True时，包含全部列
3.删掉导出名字时总会有的一行"":""
4.现在注入游戏时，黑名单文件也会被复制到输出文件夹内了
5.拆分成两个py文件，jt++是主程序
1.5：
1.发现并解决了一些游戏，System.json\gameTitle是空时，程序会报错的问题
2.写xlsx文件也改用openpyxl，因为pandas的写入有字符长度限制，openpyxl的限制更长（虽然解决了长度问题，但经常导致地址保存不完整，原因未知，不能解决，所以有了更新4）
3.Name.json改为自动导入到name文件夹，如果不存在，会自动创建这个文件夹。获取到的名字会自动按照非中日字符拆分开
4.保存工程改用csv，以\uFFFC（ ）为分隔符。导出翻译文件还是xlsx，但是只导出原文和译文列。1.4版本以前的翻译工程不再支持读取，需要重新从游戏读取
# 不建议用excel打开工程的csv文件，可能会出现问题
5.config.yaml默认配置修改：
（1）读取名字时的默认排除项（'NameWithout'）增加技能名（'Skills*name'），道具名（'Items*name'）和状态名（'States*name'）
（2）黑名单地址（'BlackDir'）新增'SrcEventIdOrName'。
# 在翻译ACT游戏时，建议把'note'也加入黑名单地址，否则大概率无法攻击或攻击没有效果
6.根据搜索结果导出json文件函数，json文件从{原文：原文}变为{原文：译文}
7.一键式操作新增游戏版本更新功能，此时'translation_path'为旧版翻译文件的路径。运行逻辑是，把旧版翻译文件导入到新版游戏，导出后ainiee会自动忽略已翻译的文本
8.一键式操作新增导出翻译文件（xlsx）功能。
1.4:
1.utf8读取json文件失败时，尝试用chardet自适应编码，chardet返回none的情况下，默认用ansi打开。还打不开就跳过
2.读取json文件和xlsx文件时，不会读取名字含有xlsx和json的文件夹了
3.去掉了Jr_Tpp类外的，一个没什么用的函数
4.添加了是否为日文游戏的开关，config配置项ja，翻译非日文游戏时，必须将其设为0（没有经过测试，不能保证像日文游戏一样不出bug）
1.3:
1.对data文件夹更加精准地定位，从判断'data'是否在路径内变为判断'\\data\\'，从而防止读取到不必要的json文件，以及防止注入时创建路径报错
2.修复了一个不为人知的bug（__CheckNAN函数）
3.改用openpyxl读xlsx，因为用pandas会把'=xxx'的字符串当成excel的错误函数表达式，读成NaN，而且解决不了
4.主函数整体用try包裹，现在出bug也不会闪退了。并且一键读取游戏后，可以直接进入注入的操作界面，不再需要读取翻译工程
5.地址不再按照英文逗号分隔，而是按照“☆↑↓”分割（谁能想到他还真有在地址里加逗号的）
1.2：
1.修复了搜索反选的逻辑错误，以前搜索反选"A*B"时，会返回不含A的数据中，不含B的数据；现在会返回，不含A且不含B的数据。并且现在搜索结果会返回没有经过大小写转化的原数据
2.现在保存会自动在保存路径下创建一个data文件夹，xlsx放在data里，config放在外面
3.增加新功能DNoteB，自动处理note类问题。
4.运行主体函数


================================================
FILE: StevExtraction/自动换行.js
================================================
// 此脚本用于在 RPG Maker MZ 和 MV 游戏中实现自动换行功能。
// 它会检查文本是否超出当前行的宽度，如果超出，则自动换行。

// 检查 RPG Maker 的版本 (MZ 或 MV)
if (Utils.RPGMAKER_NAME === "MZ") {

    // 重写 Window_Base.prototype.processCharacter 方法 (MZ 版本)
    Window_Base.prototype.processCharacter = function (textState) {
        const c = textState.text[textState.index++];  // 获取当前字符
        if (c.charCodeAt(0) < 0x20) {
            // 如果是控制字符（例如换行符、颜色代码等）
            this.flushTextState(textState);  // 刷新文本状态
            this.processControlCharacter(textState, c);  // 处理控制字符
        } else {
            // 如果是普通字符
            textState.buffer += c;  // 将字符添加到缓冲区
            if (textState.x + this.textWidth(c) >= this.innerWidth) {
                // 如果当前行的宽度加上当前字符的宽度超出了窗口的内部宽度
                this.processNewLine(textState);  // 换行
            }
        }
    };

} else {  // 如果是 MV

    // 重写 Window_Base.prototype.processNormalCharacter 方法 (MV 版本)
    Window_Base.prototype.processNormalCharacter = function(textState) {
        var c = textState.text[textState.index];  // 获取当前字符
        var w = this.textWidth(c);  // 获取当前字符的宽度
        if (this.width - 2 * this.standardPadding() - textState.x >= w){
            // 如果当前行的剩余宽度大于等于当前字符的宽度
            this.contents.drawText(c, textState.x, textState.y, w * 2, textState.height);  // 绘制字符
            textState.index++;  // 索引加 1
            textState.x += w;  // 更新当前行的 x 坐标
        } else {
            // 如果当前行的剩余宽度小于当前字符的宽度
            this.processNewLine(textState);  // 换行
            // 递归调用前增加出口条件, 避免无限循环
            if (textState.index < textState.text.length - 1) {
                textState.index--;  // 索引减1, 因为换行后，processNewLine方法已经把index加1了。
                this.processNormalCharacter(textState);  // 递归调用，处理换行后的字符
            }
        }
    };
    
}



================================================
FILE: Tools/pyinstall.py
================================================
import os
import PyInstaller.__main__

cmd = [
    "./AiNiee.py",
    "--icon=./Resource/Logo/Avatar.png",  # FILE.ico: apply the icon to a Windows executable.
    "--clean",  # Clean PyInstaller cache and remove temporary files before building.
    #"--onefile",  # Create a one-file bundled executable.
    "--noconfirm",  # Replace output directory (default: SPECPATH/dist/SPECNAME) without asking for confirmation
    "--hidden-import=babeldoc",
    "--hidden-import=sklearn",
    "--collect-all=babeldoc",
    "--collect-all=sklearn",
    # "--distpath=./dist/AiNiee" #指定输出目录
]

# 需要排除的软件包
# 由mediapipe导入，但不需要这些任务，会增加很多大小
MODULES_TO_EXCLUDE = [
    "jaxlib",
]

# 添加显式排除参数
for module_name in MODULES_TO_EXCLUDE:
    cmd.append(f"--exclude-module={module_name}")
    print(f"[INFO] Explicitly excluding module: {module_name}")

if os.path.exists("./requirements.txt"):
    with open("./requirements.txt", "r", encoding="utf-8") as reader:
        for line in reader:
            if "#" not in line:
                cmd.append("--hidden-import=" + line.strip())

    with open("./requirements_no_deps.txt", "r", encoding="utf-8") as reader:
        for line in reader:
            if "#" not in line:
                cmd.append("--hidden-import=" + line.strip())

    PyInstaller.__main__.run(cmd)



================================================
FILE: Tools/rust_updater/Cargo.toml
================================================
[package]
name = "updater"
version = "0.1.0"
edition = "2021"

[dependencies]
zip = "0.6"
anyhow = "1.0"
thiserror = "1.0"
log = "0.4"
simple_logger = "4.2"
clap = { version = "4.3", features = ["derive"] }



================================================
FILE: Tools/rust_updater/src/main.rs
================================================
[Binary file]


================================================
FILE: UserInterface/AppFluentWindow.py
================================================
import os
from PyQt5.QtCore import QUrl, QTimer, QThread, pyqtSignal
from PyQt5.QtGui import QDesktopServices,QIcon
from PyQt5.QtWidgets import QApplication
import requests
import threading

from qfluentwidgets import Theme
from qfluentwidgets import setTheme
from qfluentwidgets import isDarkTheme
from qfluentwidgets import setThemeColor
from qfluentwidgets import FluentIcon
from qfluentwidgets import MessageBox
from qfluentwidgets import FluentWindow
from qfluentwidgets import NavigationPushButton
from qfluentwidgets import NavigationItemPosition
from qfluentwidgets import NavigationAvatarWidget

from Base.Base import Base
from UserInterface.BaseNavigationItem import BaseNavigationItem

from UserInterface.VersionManager.VersionManager import VersionManager
from UserInterface.Settings.AppSettingsPage import AppSettingsPage

from UserInterface.Platform.PlatformPage import PlatformPage
from UserInterface.EditView.EditViewPage import EditViewPage

from UserInterface.Settings.TaskSettingsPage import TaskSettingsPage
from UserInterface.Settings.PluginsSettingsPage import PluginsSettingsPage
from UserInterface.Settings.OutputSettingsPage import OutputSettingsPage

from UserInterface.TranslationSettings.TranslationSettingsPage import TranslationSettingsPage
from UserInterface.PolishingSettings.PolishingBasicSettingsPage import PolishingBasicSettingsPage

from UserInterface.TranslationSettings.SystemPromptPage import SystemPromptPage
from UserInterface.TranslationSettings.WritingStylePromptPage import WritingStylePromptPage
from UserInterface.TranslationSettings.WorldBuildingPromptPage import WorldBuildingPromptPage
from UserInterface.TranslationSettings.CharacterizationPromptPage import CharacterizationPromptPage
from UserInterface.TranslationSettings.TranslationExamplePromptPage import TranslationExamplePromptPage

from UserInterface.PolishingSettings.PolishingSystemPromptPage import PolishingSystemPromptPage
from UserInterface.PolishingSettings.PolishingStylePromptPage import PolishingStylePromptPage

from UserInterface.Table.TextReplaceAPage import TextReplaceAPage
from UserInterface.Table.TextReplaceBPage import TextReplaceBPage
from UserInterface.Table.PromptDictionaryPage import PromptDictionaryPage
from UserInterface.Table.ExclusionListPage import ExclusionListPage

from StevExtraction import jtpp
from UserInterface.Extraction_Tool.Export_Source_Text import Widget_export_source_text
from UserInterface.Extraction_Tool.Import_Translated_Text import Widget_import_translated_text
from UserInterface.Extraction_Tool.Export_Update_Text import Widget_update_text



class UpdateCheckerThread(QThread):
    """自动检查更新线程"""
    update_available_signal = pyqtSignal(bool, str, bool)

    def __init__(self, version_manager):
        super().__init__()
        self.version_manager = version_manager

    def run(self):
        """在子线程中运行更新检查逻辑"""
        # 初始化错误状态
        self.version_manager.check_error = None

        # 检查更新
        has_update, latest_version = self.version_manager.check_for_updates()

        # 检查是否有错误
        check_failed = hasattr(self.version_manager, 'check_error') and self.version_manager.check_error is not None

        # 发送信号，包含检查是否失败的状态
        self.update_available_signal.emit(has_update, latest_version, check_failed)


class AppFluentWindow(FluentWindow, Base): #主窗口

    APP_WIDTH = 1600
    APP_HEIGHT = 900
    THEME_COLOR = "#808b9d"


    def __init__(self, version: str, plugin_manager, cache_manager, file_reader) -> None:
        super().__init__()

        # 启动后台线程发送日活统计，不阻塞 UI
        def report_activity():
            try:
                # Vercel 域名
                target_url = "https://ai-niee-vercel.vercel.app/api/track"
                requests.get(target_url, timeout=5)
            except Exception as e:
                # 统计失败不应该影响程序运行，直接忽略
                print(f"Activity report failed: {e}") if self.is_debug() else None

        # 设置 daemon=True 确保主程序退出时线程也会自动关闭
        threading.Thread(target=report_activity, daemon=True).start()


        # 默认配置
        self.default = {
            "theme": "light",
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 更换界面显示的语言
        Base.multilingual_interface_dict = self.load_translations(Base.translation_json_file) # 读取多语言文本
        current_language = config.get("interface_language_setting","简中") # 读取界面语言设置
        Base.current_interface_language = current_language  # 根据配置改变全局界面语言设定
        self.info(f"Current Interface Language: {Base.current_interface_language}") # 打印当前语言，方便调试

        # 打印日志
        if self.is_debug():
            self.info("Debug mode is enabled ...")

        # 设置主题颜色
        setThemeColor(self.THEME_COLOR)

        # 设置主题
        setTheme(Theme.DARK if config.get("theme") == "dark" else Theme.LIGHT)

        # 设置窗口属性
        desktop = QApplication.desktop().availableGeometry()
        initial_width = int(desktop.width() * 0.8)
        initial_height = int(desktop.height() * 0.8)
        self.resize(initial_width, initial_height)

        # 设置窗口属性
        #self.resize(self.APP_WIDTH, self.APP_HEIGHT)
        #self.setMinimumSize(self.APP_WIDTH, self.APP_HEIGHT)
        self.setWindowTitle(version)
        # 解决任务栏图标不显示问题
        self.setWindowIcon(QIcon(os.path.join(".", "Resource", "Logo", "Avatar.png")))
        self.titleBar.iconLabel.hide()

        # 初始化版本管理器
        self.version_manager = VersionManager(self, version)

        # 设置定时器检查更新（在应用加载完成后）
        # 使用子线程进行更新检查，避免冻结界面
        QTimer.singleShot(3000, self.check_for_updates)

        # 设置启动位置
        desktop = QApplication.desktop().availableGeometry()
        self.move(desktop.width()//2 - self.width()//2, desktop.height()//2 - self.height()//2)

        # 设置侧边栏宽度
        self.navigationInterface.setExpandWidth(226)

        # 侧边栏默认展开
        #self.navigationInterface.setMinimumExpandWidth(self.APP_WIDTH)
        self.navigationInterface.expand(useAni = False)

        # 隐藏返回按钮
        self.navigationInterface.panel.setReturnButtonVisible(False)

        # 添加页面
        self.add_pages(plugin_manager, cache_manager, file_reader)

    # 窗口关闭函数
    def closeEvent(self, event) -> None:
        info_cont = self.tra("确定是否退出程序") + " ... ？"
        message_box = MessageBox("Warning", info_cont, self)
        message_box.yesButton.setText(self.tra("确认"))
        message_box.cancelButton.setText(self.tra("取消"))

        if message_box.exec():
            self.emit(Base.EVENT.APP_SHUT_DOWN, {})
            info_cont = self.tra("主窗口已关闭，稍后应用将自动退出") + " ... "
            self.info(info_cont)
            event.accept()
        else:
            event.ignore()

    # 切换主题
    def toggle_theme(self) -> None:
        config = self.load_config()

        if not isDarkTheme():
            setTheme(Theme.DARK)
            config["theme"] = "dark"
        else:
            setTheme(Theme.LIGHT)
            config["theme"] = "light"

        config = self.save_config(config)

    # 打开主页
    def open_project_page(self) -> None:
        url = QUrl("https://github.com/NEKOparapa/AiNiee")
        QDesktopServices.openUrl(url)

    # 显示更新对话框
    def show_update_dialog(self) -> None:
        # 更新按钮文本，提示正在检查
        original_text = self.update_button.text()
        self.update_button.setText(self.tra("正在检查更新..."))
        self.update_button.setEnabled(False)

        # 显示更新对话框
        self.version_manager.show_update_dialog()

        # 恢复按钮文本和状态
        QTimer.singleShot(1000, lambda: self._restore_update_button(original_text))

    # 恢复更新按钮状态
    def _restore_update_button(self, original_text: str) -> None:
        self.update_button.setText(original_text)
        self.update_button.setEnabled(True)

    # 检查更新
    def check_for_updates(self) -> None:
        # 检查是否开启了自动检查更新
        config = self.load_config()
        if config.get("auto_check_update", True):
            # 创建并启动更新检查线程
            self.update_checker_thread = UpdateCheckerThread(self.version_manager)
            self.update_checker_thread.update_available_signal.connect(self._on_update_check_completed)
            self.update_checker_thread.start()

    # 更新检查完成的回调
    def _on_update_check_completed(self, has_update: bool, latest_version: str, check_failed: bool) -> None:
        if check_failed:
            # 检查失败时显示错误提示
            self.warning_toast(
                self.tra("更新检查失败"),
                self.tra("请检查报错信息")
            )
        elif has_update:
            # 发现新版本
            self.success_toast(
                self.tra("发现新版本"),
                self.tra("当前版本: {0}, 最新版本: {1}, 点击更新按钮进行更新").format(
                    self.version_manager.current_version, latest_version
                )
            )
        else:
            # 已是最新版本
            self.info_toast(
                self.tra("更新检查"),
                self.tra("当前已是最新版本")
            )

    # 开始添加页面
    def add_pages(self, plugin_manager, cache_manager, file_reader) -> None:
        self.add_project_pages(plugin_manager, cache_manager, file_reader)
        self.navigationInterface.addSeparator(NavigationItemPosition.SCROLL)
        self.add_task_setting_pages(plugin_manager)
        self.navigationInterface.addSeparator(NavigationItemPosition.SCROLL)
        self.add_settings_pages(plugin_manager)
        self.navigationInterface.addSeparator(NavigationItemPosition.SCROLL)
        self.add_prompt_setting_pages(plugin_manager)
        self.navigationInterface.addSeparator(NavigationItemPosition.SCROLL)
        self.add_table_pages(plugin_manager)
        self.navigationInterface.addSeparator(NavigationItemPosition.SCROLL)
        self.add_stev_extraction_pages()

        # 设置默认页面
        self.switchTo(self.edit_view_page)

        # 主题切换按钮
        self.navigationInterface.addWidget(
            routeKey = "theme_navigation_button",
            widget = NavigationPushButton(
                FluentIcon.CONSTRACT,
                self.tra("主题切换"),
                False
            ),
            onClick = self.toggle_theme,
            position = NavigationItemPosition.BOTTOM
        )

        # 更新按钮
        self.update_button = NavigationPushButton(
            FluentIcon.UPDATE,
            self.tra("检查更新"),
            False
        )
        self.navigationInterface.addWidget(
            routeKey = "update_navigation_button",
            widget = self.update_button,
            onClick = self.show_update_dialog,
            position = NavigationItemPosition.BOTTOM
        )

        # 应用设置按钮
        self.app_settings_page = AppSettingsPage("app_settings_page", self)
        self.addSubInterface(self.app_settings_page, FluentIcon.SETTING, self.tra("应用设置"), NavigationItemPosition.BOTTOM)

        # 项目主页按钮
        Avatar_path = os.path.join(".", "Resource", "Logo", "Avatar.png")
        self.navigationInterface.addWidget(
            routeKey = "avatar_navigation_widget",
            widget = NavigationAvatarWidget(
                "NEKOparapa",
                Avatar_path,
            ),
            onClick = self.open_project_page,
            position = NavigationItemPosition.BOTTOM
        )

    # 添加快速开始
    def add_project_pages(self, plugin_manager, cache_manager, file_reader) -> None:
        self.platform_page = PlatformPage("platform_page", self)
        self.addSubInterface(self.platform_page, FluentIcon.IOT, self.tra("接口管理"), NavigationItemPosition.SCROLL)

        self.edit_view_page = EditViewPage("edit_view_page", self, plugin_manager, cache_manager, file_reader)
        self.addSubInterface(self.edit_view_page, FluentIcon.PLAY, self.tra("开始翻译"), NavigationItemPosition.SCROLL)  


    # 添加项目设置
    def add_task_setting_pages(self, plugin_manager) -> None:
        self.task_settings_page = TaskSettingsPage("task_settings_page", self)
        self.addSubInterface(self.task_settings_page, FluentIcon.ZOOM, self.tra("任务设置"), NavigationItemPosition.SCROLL)
        self.output_settings_page = OutputSettingsPage("output_settings_page", self)
        self.addSubInterface(self.output_settings_page, FluentIcon.ALBUM, self.tra("输出设置"), NavigationItemPosition.SCROLL)

    # 添加翻译设置
    def add_settings_pages(self, plugin_manager) -> None:
        self.TranslationSettings = TranslationSettingsPage("TranslationSettings", self)
        self.addSubInterface(self.TranslationSettings, FluentIcon.EXPRESSIVE_INPUT_ENTRY, self.tra("翻译设置"), NavigationItemPosition.SCROLL)

        self.PolishingBasicSettingsPage = PolishingBasicSettingsPage("PolishingBasicSettingsPage", self)
        self.addSubInterface(self.PolishingBasicSettingsPage, FluentIcon.BRUSH, self.tra("润色设置"), NavigationItemPosition.SCROLL)

        self.plugins_settings_page = PluginsSettingsPage("plugins_settings_page", self, plugin_manager)
        self.addSubInterface(self.plugins_settings_page, FluentIcon.APPLICATION, self.tra("插件设置"), NavigationItemPosition.SCROLL)

    # 添加润色设置
    def add_prompt_setting_pages(self, plugin_manager) -> None:
        self.prompt_optimization_navigation_item = BaseNavigationItem("prompt_optimization_navigation_item", self)
        self.addSubInterface(self.prompt_optimization_navigation_item, FluentIcon.BOOK_SHELF, self.tra("翻译提示词"), NavigationItemPosition.SCROLL)
        self.system_prompt_page = SystemPromptPage("system_prompt_page", self)
        self.addSubInterface(self.system_prompt_page, FluentIcon.LABEL, self.tra("基础提示"), parent = self.prompt_optimization_navigation_item)
        self.characterization_prompt_page = CharacterizationPromptPage("characterization_prompt_page", self)
        self.addSubInterface(self.characterization_prompt_page, FluentIcon.PEOPLE, self.tra("角色介绍"), parent = self.prompt_optimization_navigation_item)
        self.world_building_prompt_page = WorldBuildingPromptPage("world_building_prompt_page", self)
        self.addSubInterface(self.world_building_prompt_page, FluentIcon.QUICK_NOTE, self.tra("背景设定"), parent = self.prompt_optimization_navigation_item)
        self.writing_style_prompt_page = WritingStylePromptPage("writing_style_prompt_page", self)
        self.addSubInterface(self.writing_style_prompt_page, FluentIcon.PENCIL_INK, self.tra("翻译风格"), parent = self.prompt_optimization_navigation_item)
        self.translation_example_prompt_page = TranslationExamplePromptPage("translation_example_prompt_page", self)
        self.addSubInterface(self.translation_example_prompt_page, FluentIcon.FIT_PAGE, self.tra("翻译示例"), parent = self.prompt_optimization_navigation_item)

        self.polishing_prompt_navigation = BaseNavigationItem("polishing_prompt_navigation", self)
        self.addSubInterface(self.polishing_prompt_navigation, FluentIcon.PALETTE, self.tra("润色提示词"), NavigationItemPosition.SCROLL)
        self.polishing_system_prompt_page = PolishingSystemPromptPage("polishing_system_prompt_page", self)
        self.addSubInterface(self.polishing_system_prompt_page, FluentIcon.LABEL, self.tra("基础提示"), parent = self.polishing_prompt_navigation)
        self.polishing_style_prompt_page = PolishingStylePromptPage("polishing_style_prompt_page", self)
        self.addSubInterface(self.polishing_style_prompt_page, FluentIcon.PENCIL_INK, self.tra("润色风格"), parent = self.polishing_prompt_navigation)

    # 添加表格设置
    def add_table_pages(self, plugin_manager) -> None:
        self.prompt_dictionary_page = PromptDictionaryPage("prompt_dictionary_page", self)
        self.addSubInterface(self.prompt_dictionary_page, FluentIcon.DICTIONARY, self.tra("术语表"), NavigationItemPosition.SCROLL)
        self.exclusion_list_page = ExclusionListPage("exclusion_list_page", self)
        self.addSubInterface(self.exclusion_list_page, FluentIcon.DICTIONARY, self.tra("禁翻表"), NavigationItemPosition.SCROLL)
        self.text_replace_navigation_item = BaseNavigationItem("text_replace_navigation_item", self)
        self.addSubInterface(self.text_replace_navigation_item, FluentIcon.FONT_SIZE, self.tra("文本替换"), NavigationItemPosition.SCROLL)
        self.text_replace_a_page = TextReplaceAPage("text_replace_a_page", self)
        self.addSubInterface(self.text_replace_a_page, FluentIcon.SEARCH, self.tra("译前替换"), parent = self.text_replace_navigation_item)
        self.text_replace_b_page = TextReplaceBPage("text_replace_b_page", self)
        self.addSubInterface(self.text_replace_b_page, FluentIcon.SEARCH_MIRROR, self.tra("译后替换"), parent = self.text_replace_navigation_item)



    # 添加第五节
    def add_stev_extraction_pages(self) -> None:
        pass
        self.stev_extraction_navigation_item = BaseNavigationItem("stev_extraction_navigation_item", self)
        self.addSubInterface(self.stev_extraction_navigation_item, FluentIcon.ZIP_FOLDER, self.tra("StevExtraction"), NavigationItemPosition.SCROLL)
        self.widget_export_source_text = Widget_export_source_text("widget_export_source_text", self, jtpp)
        self.addSubInterface(self.widget_export_source_text, FluentIcon.SHARE, self.tra("导出文本"), parent = self.stev_extraction_navigation_item)
        self.widget_import_translated_text = Widget_import_translated_text("widget_import_translated_text", self, jtpp)
        self.addSubInterface(self.widget_import_translated_text, FluentIcon.DOWNLOAD, self.tra("导入文本"), parent = self.stev_extraction_navigation_item)
        self.widget_update_text = Widget_update_text("widget_update_text", self, jtpp)
        self.addSubInterface(self.widget_update_text, FluentIcon.UPDATE, self.tra("导出增量文本"), parent = self.stev_extraction_navigation_item)


================================================
FILE: UserInterface/BaseNavigationItem.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QHBoxLayout

from qfluentwidgets import SubtitleLabel


class BaseNavigationItem(QWidget):

    def __init__(self, text: str, parent = None):
        super().__init__(parent = parent)

        self.label = SubtitleLabel("", self)
        self.label.setAlignment(Qt.AlignCenter)

        self.hBoxLayout = QHBoxLayout(self)
        self.hBoxLayout.addWidget(self.label, 1, Qt.AlignCenter)

        # 必须给子界面设置全局唯一的对象名
        self.setObjectName(text.replace(' ', '-'))


================================================
FILE: UserInterface/EditView/BasicTablePage.py
================================================
from PyQt5.QtCore import QPoint, Qt
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import (QAbstractItemView, QHeaderView, QTableWidgetItem,
                             QWidget, QVBoxLayout)
from qfluentwidgets import (Action, FluentIcon as FIF, MessageBox, RoundMenu, TableWidget)

from Base.Base import Base
from ModuleFolders.Cache.CacheProject import ProjectType

# 基础表格页
class BasicTablePage(Base,QWidget):
    # 定义列索引常量
    COL_NUM = 0 # 行号
    COL_SOURCE = 1 # 原文
    COL_TRANS = 2 # 译文
    COL_POLISH = 3 # 润文

    def closeEvent(self, event):
        # 在窗口关闭时，执行清理工作
        print("BasicTablePage is closing, unregistering from EventManager.")
        
        super().closeEvent(event) # 调用父类的 closeEvent

    # 修改构造函数
    def __init__(self, file_path: str, file_items: list, cache_manager, parent=None):
        super().__init__(parent)
        self.setObjectName('BasicTablePage')
        
        # 初始化 _on_item_changed 方法的处理开关
        self._item_changed_handler_enabled = True

        self.file_path = file_path          # 当前表格对应的文件路径
        self.cache_manager = cache_manager  # 缓存管理器实例
        
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(5, 0, 0, 0)
        self.layout.setSpacing(0)

        self.table = TableWidget(self)
        self._init_table()
        self.layout.addWidget(self.table)
        
        # 使用真实数据填充表格
        self._populate_real_data(file_items)

        # 连接单元格修改信号
        self.table.itemChanged.connect(self._on_item_changed)
        # 订阅来自执行器的通用表格更新事件
        self.subscribe(Base.EVENT.TABLE_UPDATE, self._on_table_update)

    # 表格属性
    def _init_table(self):
        self.headers = [self.tra("行"), self.tra("原文"), self.tra("译文"), self.tra("润文")]
        self.table.setColumnCount(len(self.headers))
        self.table.setHorizontalHeaderLabels(self.headers)
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        
        self.table.setWordWrap(True) #启单元格内文本自动换行
        self.table.setBorderVisible(True)
        self.table.setBorderRadius(8)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.Interactive)
        header.setStretchLastSection(True)

        self.table.setColumnWidth(0, 60)
        self.table.setColumnWidth(1, 400)
        self.table.setColumnWidth(2, 400)
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self._show_context_menu)

    # 获取数据并填充表格
    def _populate_real_data(self, items: list):
        # 在批量填充数据前，关闭 _on_item_changed 的处理逻辑
        self._item_changed_handler_enabled = False
        try:
            # 定义高亮颜色：半透明浅绿色
            highlight_brush = QBrush(QColor(144, 238, 144, 100))
            
            self.table.setRowCount(len(items))
            for row_idx, item_data in enumerate(items):
                # 行号列 (第0列)
                num_item = QTableWidgetItem(str(row_idx + 1))
                num_item.setTextAlignment(Qt.AlignCenter)
                num_item.setFlags(num_item.flags() & ~Qt.ItemIsEditable)
                num_item.setData(Qt.UserRole, item_data.text_index)
                self.table.setItem(row_idx, 0, num_item)

                # 原文列
                source_item = QTableWidgetItem(item_data.source_text)
                self.table.setItem(row_idx, 1, source_item)
                
                # 译文、润文列 (可编辑)
                trans_item = QTableWidgetItem(item_data.translated_text)
                polish_item = QTableWidgetItem(item_data.polished_text or '')
                self.table.setItem(row_idx, 2, trans_item)
                self.table.setItem(row_idx, 3, polish_item)

                # 检查是否存在 extra 字典以及对应的标记
                if item_data.extra:
                    # 如果翻译文本被标记，则高亮第2列（译文）
                    if item_data.extra.get('language_mismatch_translation', False):
                        trans_item.setBackground(highlight_brush)
                    
                    # 如果润色文本被标记，则高亮第3列（润文）
                    if item_data.extra.get('language_mismatch_polish', False):
                        polish_item.setBackground(highlight_brush)

        finally:
            # 无论是否发生异常，都确保在操作结束后重新打开开关
            self._item_changed_handler_enabled = True

    # 监听用户编辑单元格
    def _on_item_changed(self, item: QTableWidgetItem):
        # 检查开关状态，如果为关闭，则不执行任何操作
        if not self._item_changed_handler_enabled:
            return

        row = item.row()
        col = item.column()

        if col not in [self.COL_SOURCE, self.COL_TRANS, self.COL_POLISH]:
            return
            
        text_index_item = self.table.item(row, 0)
        if not text_index_item:
            return 
        text_index = text_index_item.data(Qt.UserRole)

        new_text = item.text()
        
        field_name = ''
        if col == self.COL_TRANS:
            field_name = 'translated_text'
        elif col == self.COL_POLISH:
            field_name = 'polished_text'
        elif col == self.COL_SOURCE:
            field_name = 'source_text'
        
        self.cache_manager.update_item_text(
            storage_path=self.file_path,
            text_index=text_index,
            field_name=field_name,
            new_text=new_text
        )

    # 表格操作的右键菜单
    def _show_context_menu(self, pos: QPoint):
        menu = RoundMenu(parent=self)
        has_selection = bool(self.table.selectionModel().selectedRows())
        if has_selection:
            menu.addAction(Action(FIF.EXPRESSIVE_INPUT_ENTRY, self.tra("翻译文本"), triggered=self._translate_text))
            menu.addAction(Action(FIF.BRUSH, self.tra("润色文本"), triggered=self._polish_text))
            menu.addSeparator()
            menu.addAction(Action(FIF.COPY, self.tra("禁止翻译"), triggered=self._copy_source_to_translation))
            menu.addAction(Action(FIF.DELETE, self.tra("清空翻译"), triggered=self._clear_translation))
            menu.addAction(Action(FIF.DELETE, self.tra("清空润色"), triggered=self._clear_polishing))
            menu.addSeparator()
        row_count = self.table.rowCount()
        row_count_action = Action(FIF.LEAF, self.tra("行数: {}").format(row_count))
        row_count_action.setEnabled(False)
        menu.addAction(row_count_action)
        global_pos = self.table.mapToGlobal(pos)
        menu.exec(global_pos)


    def _on_table_update(self, event, data: dict):
        """
        根据事件传递的数据，更新指定文件的指定列。
        """
        if data.get('file_path') != self.file_path:
            return

        target_column_index = data.get('target_column_index')
        updated_items = data.get('updated_items', {})

        if target_column_index is None or not updated_items:
            self.warning(f"表格更新数据不完整，操作中止。")
            return

        # 根据列索引确定要更新的字段名
        field_name_map = {
            self.COL_TRANS: 'translated_text',
            self.COL_POLISH: 'polished_text'
        }
        field_name = field_name_map.get(target_column_index)
        if not field_name:
            self.warning(f"无效的目标列索引: {target_column_index}")
            return

        # 在批量更新前关闭开关，操作结束后再打开
        self._item_changed_handler_enabled = False
        try:
            index_to_row_map = {
                self.table.item(row, self.COL_NUM).data(Qt.UserRole): row 
                for row in range(self.table.rowCount()) if self.table.item(row, self.COL_NUM)
            }

            for text_index, new_text in updated_items.items():
                if text_index in index_to_row_map:
                    row = index_to_row_map[text_index]
                    
                    # 更新UI表格
                    self.table.setItem(row, target_column_index, QTableWidgetItem(new_text))

                    # 更新CacheManager中的数据模型
                    self.cache_manager.update_item_text(
                        storage_path=self.file_path,
                        text_index=text_index,
                        field_name=field_name,
                        new_text=new_text
                    )
            
            self.table.resizeRowsToContents()
        finally:
            self._item_changed_handler_enabled = True

    def _get_selected_rows_indices(self):
        """获取所有被选中行的索引列表"""
        return sorted(list(set(index.row() for index in self.table.selectedIndexes())))

    def _translate_text(self):
        """处理右键菜单的“翻译文本”操作"""
        selected_rows = self._get_selected_rows_indices()
        if not selected_rows:
            return

        if Base.work_status == Base.STATUS.IDLE:
            Base.work_status = Base.STATUS.TABLE_TASK
        else:
            print("❌正在执行其他任务中！")
            return

        items_to_translate = []
        for row in selected_rows:
            text_index_item = self.table.item(row, self.COL_NUM)
            source_text_item = self.table.item(row, self.COL_SOURCE)
            if text_index_item and source_text_item:
                items_to_translate.append({
                    "text_index": text_index_item.data(Qt.UserRole),
                    "source_text": source_text_item.text()
                })
        
        if not items_to_translate:
            return
        
        language_stats = self.cache_manager.project.get_file(self.file_path).language_stats

        self.emit(Base.EVENT.TABLE_TRANSLATE_START, {
            "file_path": self.file_path,
            "items_to_translate": items_to_translate,
            "language_stats": language_stats,
        })
        self.info_toast(self.tra("提示"), self.tra("已提交 {} 行文本的翻译任务。").format(len(items_to_translate)))

    def _polish_text(self):
        """处理右键菜单的“润色文本”操作"""
        selected_rows = self._get_selected_rows_indices()
        if not selected_rows:
            return

        if Base.work_status == Base.STATUS.IDLE:
            Base.work_status = Base.STATUS.TABLE_TASK
        else:
            print("❌正在执行其他任务中！")
            return

        items_to_polish = []
        for row in selected_rows:
            text_index_item = self.table.item(row, self.COL_NUM)
            source_text_item = self.table.item(row, self.COL_SOURCE)
            translation_text_item = self.table.item(row, self.COL_TRANS)
            if text_index_item and source_text_item:
                items_to_polish.append({
                    "text_index": text_index_item.data(Qt.UserRole),
                    "source_text": source_text_item.text(),
                    "translation_text": translation_text_item.text()
                })
        
        if not items_to_polish:
            return

        self.emit(Base.EVENT.TABLE_POLISH_START, {
            "file_path": self.file_path,
            "items_to_polish": items_to_polish,
        })
        self.info_toast(self.tra("提示"), self.tra("已提交 {} 行文本的润色任务。").format(len(items_to_polish)))

    def _copy_source_to_translation(self):
        """将选中行的原文内容复制到译文行，表示无需翻译。"""
        selected_rows = self._get_selected_rows_indices()
        if not selected_rows:
            return
        
        for row in selected_rows:
            source_item = self.table.item(row, self.COL_SOURCE)
            if source_item:
                source_text = source_item.text()
                trans_item = self.table.item(row, self.COL_TRANS)
                if trans_item:
                    trans_item.setText(source_text)
                else:
                    self.table.setItem(row, self.COL_TRANS, QTableWidgetItem(source_text))
        
        self.info_toast(self.tra("操作完成"), self.tra("已将 {} 行的原文复制到译文。").format(len(selected_rows)))

    def _clear_translation(self):
        selected_rows = self._get_selected_rows_indices()
        for row in selected_rows:
            item = self.table.item(row, self.COL_TRANS)
            if item:
                item.setText("")
            else:
                self.table.setItem(row, self.COL_TRANS, QTableWidgetItem(""))

    def _clear_polishing(self):
        selected_rows = self._get_selected_rows_indices()
        for row in selected_rows:
            item = self.table.item(row, self.COL_POLISH)
            if item:
                item.setText("")
            else:
                self.table.setItem(row, self.COL_POLISH, QTableWidgetItem(""))


================================================
FILE: UserInterface/EditView/EditViewPage.py
================================================
import json
import os
import threading
import time
from PyQt5.QtCore import QTime, QVariant, Qt, QSize, pyqtSignal
from PyQt5.QtWidgets import ( QFileDialog, QFrame, QTreeWidgetItem,
                             QWidget, QHBoxLayout, QVBoxLayout, 
                             QSplitter, QStackedWidget)
from qfluentwidgets import (Action,  CaptionLabel, MessageBox, PrimarySplitPushButton, PushButton, RoundMenu,  ToggleToolButton, TransparentPushButton, TransparentToolButton,
                            TreeWidget, TabBar, FluentIcon as FIF, CardWidget, Action, RoundMenu, ProgressBar)
from qframelesswindow import QTimer

from Base.Base import Base
from ModuleFolders.ResponseChecker.TranslationChecker import TranslationChecker, CheckResult
from UserInterface.EditView.Monitoring.MonitoringPage import MonitoringPage
from UserInterface.EditView.Startup.StartupPage import StartupPage
from ModuleFolders.TaskConfig.TaskType import TaskType
from UserInterface.EditView.Check.LanguageCheckDialog import LanguageCheckDialog
from UserInterface.EditView.Search.SearchDialog import SearchDialog
from UserInterface.EditView.Search.SearchResultPage import SearchResultPage
from UserInterface.EditView.Timer.ScheduledDialogPage import ScheduledDialogPage
from UserInterface.EditView.BasicTablePage import BasicTablePage
from UserInterface.EditView.Term.TermResultPage import TermResultPage
from UserInterface.EditView.Term.TermExtractionDialog import TermExtractionDialog
from UserInterface.EditView.Check.CheckResultPage import CheckResultPage 

# 底部命令栏
class BottomCommandBar(Base,CardWidget):
    arrowClicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedHeight(60)
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(8, 5, 8, 5)
        self.layout.setSpacing(12)

        # 初始化
        self.current_mode = TaskType.TRANSLATION
        self.scheduled_timer = None # 用于一次性定时任务
        self.ui_update_timer = QTimer(self) # 用于任务进行中持续刷新UI
        self.ui_update_timer.setInterval(1000) # 每秒触发一次
        # 定时器刷新事件
        self.ui_update_timer.timeout.connect(lambda: self.emit(Base.EVENT.TASK_UPDATE, {}))

        self.back_btn = PushButton(FIF.RETURN, self.tra('返回'))
        self.back_btn.setIconSize(QSize(16, 16))
        self.back_btn.setFixedHeight(32)

        project_widget = QWidget()
        project_layout = QVBoxLayout(project_widget)
        project_layout.setContentsMargins(0, 0, 0, 0)
        project_layout.setSpacing(8)

        top_row = QHBoxLayout()
        self.project_name = CaptionLabel('project_name')
        self.project_name.setFixedWidth(200)
        self.progress_status = CaptionLabel("NA")
        top_row.addWidget(self.project_name, alignment=Qt.AlignLeft)
        top_row.addStretch()
        top_row.addWidget(self.progress_status, alignment=Qt.AlignRight)

        self.progress_bar = ProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setMinimumWidth(400)

        project_layout.addStretch(1)
        project_layout.addLayout(top_row)
        project_layout.addWidget(self.progress_bar)
        project_layout.addStretch(1)

        # 创建翻译和润色的下拉菜单
        self.menu = RoundMenu(parent=self)
        self.translate_action = Action(FIF.PLAY, self.tra('开始翻译'))
        self.polish_action = Action(FIF.ALBUM, self.tra('开始润色'))
        self.menu.addAction(self.translate_action)
        self.menu.addAction(self.polish_action)

        # 初始按钮
        self.start_btn = PrimarySplitPushButton(FIF.PLAY, self.tra('开始翻译'))
        self.start_btn.setFlyout(self.menu)
        self.continue_btn = TransparentPushButton(FIF.ROTATE, self.tra('继续'))
        self.continue_btn.setEnabled(False)  # 初始不可用
        self.stop_btn = TransparentPushButton(FIF.CANCEL_MEDIUM, self.tra('停止'))
        self.stop_btn.setEnabled(False)  # 初始不可用
        self.schedule_btn = TransparentPushButton(FIF.DATE_TIME, self.tra('定时'))
        self.export_btn = TransparentPushButton(FIF.SHARE, self.tra("导出结果"))
        self.arrow_btn = ToggleToolButton()
        self.arrow_btn.setIcon(FIF.UP)
        self.arrow_btn.setIconSize(QSize(16, 16))
        self.arrow_btn.setFixedHeight(32)

        for btn in [self.start_btn, self.continue_btn, self.arrow_btn]:
            btn.setIconSize(QSize(16, 16))
            btn.setFixedHeight(32)

        self.layout.addWidget(self.back_btn)
        self.layout.addStretch(1)
        self.layout.addWidget(project_widget)
        self.layout.addStretch(1)
        self.layout.addWidget(self.start_btn)
        self.layout.addWidget(self.continue_btn)
        self.layout.addWidget(self.stop_btn)
        self.layout.addWidget(self.schedule_btn)
        self.layout.addWidget(self.export_btn)
        self.layout.addWidget(self.arrow_btn)

        # 连接按钮
        self.start_btn.clicked.connect(self.command_play)
        self.stop_btn.clicked.connect(self.command_stop)
        self.continue_btn.clicked.connect(self.command_continue)
        self.export_btn.clicked.connect(self.command_export)
        self.schedule_btn.clicked.connect(self.command_schedule) 
        self.arrow_btn.clicked.connect(self.on_arrow_clicked)

        # 连接菜单项的点击事件
        self.translate_action.triggered.connect(
            lambda: self._on_mode_selected(TaskType.TRANSLATION, self.translate_action)
        )
        self.polish_action.triggered.connect(
            lambda: self._on_mode_selected(TaskType.POLISH, self.polish_action)
        )

        # 订阅事件
        self.subscribe(Base.EVENT.TASK_UPDATE, self.data_update)
        self.subscribe(Base.EVENT.TASK_STOP_DONE, self.task_stop_done)
        self.subscribe(Base.EVENT.APP_SHUT_DOWN, self.app_shut_down)

    # 更新项目名称标签的方法
    def update_project_name(self, name: str):
        self.project_name.setText(name)

    # 任务模式切换
    def _on_mode_selected(self, mode: str, action: Action):
        self.current_mode = mode
        self.start_btn.setText(action.text())
        if self.current_mode == TaskType.TRANSLATION:
            info_cont = ": " + self.tra("翻译模式")
            self.info_toast(self.tra("模式已切换为"), info_cont)
        elif self.current_mode == TaskType.POLISH:
            info_cont = ": " + self.tra("润色模式")
            self.info_toast(self.tra("模式已切换为"), info_cont)

    # 继续按钮的显示隐藏
    def enable_continue_button(self, enable: bool) -> None:
        self.continue_btn.setEnabled(enable)

    # 应用关闭事件
    def app_shut_down(self, event: int, data: dict) -> None:
        # 确保应用关闭时所有定时器都停止
        if self.scheduled_timer:
            self.scheduled_timer.stop()
        if self.ui_update_timer.isActive():
            self.ui_update_timer.stop()

    # 任务停止完成事件
    def task_stop_done(self, event: int, data: dict) -> None:
        """任务停止完成事件处理"""
        # 关闭UI刷新器
        if self.ui_update_timer.isActive():
            self.ui_update_timer.stop()

        self.start_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        Base.work_status = Base.STATUS.IDLE
        self.emit(Base.EVENT.TASK_CONTINUE_CHECK, {})

    # 更新底部进度条
    def data_update(self, event: int, data: dict) -> None:
        # 检查是否包含进度信息
        if data.get("line") is not None and data.get("total_line") is not None:
            line = data.get("line")
            total_line = data.get("total_line")

            # 更新进度文本标签 (例如 "15/100")
            self.progress_status.setText(f"{line}/{total_line}")

            # 更新进度条
            if total_line > 0:
                percentage = int((line / total_line) * 100)
                self.progress_bar.setValue(percentage)

            else:
                # 如果总行数为0，则将进度条重置为0
                self.progress_bar.setValue(0)
    # 开始按钮
    def command_play(self) -> None:
        """开始新任务"""
        self.cancel_scheduled_task() # 如果有定时任务，先取消

        if self.continue_btn.isEnabled():
            info_cont1 = self.tra("将重置尚未完成的任务") + "  ... ？"
            message_box = MessageBox("Warning", info_cont1, self.window())
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))
            if not message_box.exec():
                return

        self.start_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.continue_btn.setEnabled(False)
        
        self.emit(Base.EVENT.TASK_START, {
            "continue_status": False,
            "current_mode": self.current_mode
        })
        
        # 开启UI刷新器
        self.ui_update_timer.start()

        if not self.arrow_btn.isChecked():
            self.arrow_btn.setChecked(True)
            self.arrowClicked.emit()

    # 停止按钮
    def command_stop(self) -> None:
        """停止当前任务"""
        self.cancel_scheduled_task() # 如果有定时任务，也一并取消

        info_cont1 = self.tra("是否确定停止任务") + "  ... ？"
        message_box = MessageBox("Warning", info_cont1, self.window())
        message_box.yesButton.setText(self.tra("确认"))
        message_box.cancelButton.setText(self.tra("取消"))

        if message_box.exec():
            self.info("正在停止任务 ... ")
            self.emit(Base.EVENT.TASK_STOP, {})

    # 继续按钮
    def command_continue(self) -> None:
        """继续未完成的任务"""
        self.cancel_scheduled_task() # 如果有定时任务，先取消

        self.start_btn.setEnabled(False)
        self.continue_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        
        self.emit(Base.EVENT.TASK_START, {
            "continue_status": True,
            "current_mode": self.current_mode
        })
        
        # 开启UI刷新器
        self.ui_update_timer.start()

    # 导出按钮
    def command_export(self) -> None:
        selected_path = QFileDialog.getExistingDirectory(
            self.window(), self.tra("选择导出目录"), "."
        )
        if selected_path:
            self.emit(Base.EVENT.TASK_MANUAL_EXPORT, {"export_path": selected_path})

    # 展开按钮
    def on_arrow_clicked(self):
        self.arrowClicked.emit()

    # 定时按钮
    def command_schedule(self) -> None:
        """处理定时按钮点击事件"""
        # 如果已经有定时任务，则取消
        if self.scheduled_timer:
            self.cancel_scheduled_task()
            info_cont = self.tra("定时任务已取消") + "  ... "
            self.info_toast("", info_cont)
            return

        # 创建定时对话框
        dialog = ScheduledDialogPage(parent=self.window(), title=self.tra("定时任务"))
        if dialog.exec_():
            scheduled_time = dialog.get_scheduled_time()
            current_time = QTime.currentTime()

            current_msecs = current_time.msecsSinceStartOfDay()
            scheduled_msecs = scheduled_time.msecsSinceStartOfDay()

            msec_diff = scheduled_msecs - current_msecs
            # 如果设定时间早于当前时间，则认为是明天
            if msec_diff < 0:
                msec_diff += 24 * 60 * 60 * 1000

            # 检查时间间隔是否有效（例如，至少5秒）
            if msec_diff < 5000:
                warning_box = MessageBox(self.tra("无效时间"), self.tra("与当前时间间隔过短"), self.window())
                warning_box.yesButton.setText(self.tra("确认"))
                warning_box.cancelButton.hide()
                warning_box.exec()
                return

            # 创建定时器
            self.scheduled_timer = QTimer(self)
            self.scheduled_timer.setSingleShot(True)
            self.scheduled_timer.timeout.connect(self.start_scheduled_task)
            self.scheduled_timer.start(msec_diff)

            # 更新按钮文本
            time_str = scheduled_time.toString("HH:mm:ss")
            self.schedule_btn.setText(f"{time_str}")

            # 显示提示
            info_cont = f" {time_str} " + self.tra("定时开始任务") + "  ... "
            self.info_toast(self.tra("已设置定时任务，将在"), info_cont)

    # 开始定时任务
    def start_scheduled_task(self) -> None:
        """定时器触发，开始任务"""
        self.info("定时任务已开始 ...")
        self.cancel_scheduled_task() # 清理定时器自身状态

        # 启动任务
        self.start_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.continue_btn.setEnabled(False)
        self.emit(Base.EVENT.TASK_START, {
            "continue_status": False,
            "current_mode": self.current_mode
        })
        
        # 开启UI刷新器
        self.ui_update_timer.start()

        # 自动展开监控页面
        if not self.arrow_btn.isChecked():
            self.arrow_btn.setChecked(True)
            self.arrowClicked.emit()

    # 取消当前的定时任务
    def cancel_scheduled_task(self):
        """取消当前的定时任务"""
        if self.scheduled_timer:
            self.scheduled_timer.stop()
            self.scheduled_timer = None
        self.schedule_btn.setText(self.tra("定时"))

# 层级浏览器
class NavigationCard(Base,CardWidget):
    searchRequested = pyqtSignal(dict)  # 信号，发送搜索参数字典
    termExtractionRequested = pyqtSignal(dict)  # 用于发送术语提取参数的信号
    languageCheckRequested = pyqtSignal(dict)  # 用于发送语言检查参数的信号    

    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(10, 10, 10, 10)
        self.layout.setSpacing(8)
        
        self.toolbar = QWidget()
        self.toolbar_layout = QHBoxLayout(self.toolbar)
        self.toolbar_layout.setContentsMargins(0, 0, 0, 0)
        self.toolbar_layout.setSpacing(0)
        
        # 搜索按钮
        self.search_button = TransparentPushButton(FIF.SEARCH,self.tra("搜索"))
        # 设置合适的大小

        self.search_button.clicked.connect(self._open_search_dialog) # 连接点击事件

        # 术语提取按钮
        self.term_extraction_button = TransparentPushButton(FIF.FILTER, self.tra("术语"))
        self.term_extraction_button.clicked.connect(self._open_term_extraction_dialog)

        # 语言检查按钮
        self.check_button = TransparentPushButton(FIF.EDUCATION, self.tra("检查"))
        self.check_button.clicked.connect(self._open_language_check_dialog)

        # 为三个按钮设置合适的固定宽度
        button_width = 75
        self.search_button.setFixedWidth(button_width)
        self.term_extraction_button.setFixedWidth(button_width)
        self.check_button.setFixedWidth(button_width)

        # 添加按钮到工具栏布局
        self.toolbar_layout.addWidget(self.term_extraction_button)
        self.toolbar_layout.addWidget(self.search_button)
        self.toolbar_layout.addWidget(self.check_button)
        self.layout.addWidget(self.toolbar)
        
        self.tree = TreeWidget(self)
        self.tree.setHeaderHidden(True)
        self.layout.addWidget(self.tree)

    # 搜索按钮事件
    def _open_search_dialog(self):
        dialog = SearchDialog(self.window())
        if dialog.exec():
            # 用户点击了“搜索”并输入了内容
            params = {
                "query": dialog.search_query,
                "is_regex": dialog.is_regex,
                "scope": dialog.search_scope,
                "search_flagged": dialog.is_flagged_search
            }
            self.searchRequested.emit(params)

    # 检查按钮事件
    def _open_language_check_dialog(self):
        dialog = LanguageCheckDialog(self.window())
        if dialog.exec():
            # 发送对话框返回的完整参数字典
            self.languageCheckRequested.emit(dialog.check_params)
            

    # 按钮点击
    def _open_term_extraction_dialog(self):
        """打开术语提取设置对话框"""
        dialog = TermExtractionDialog(self.window())
        if dialog.exec():
            # 用户点击了“开始提取”
            params = {
                "model_name": dialog.selected_model,
                "entity_types": dialog.selected_types
            }
            self.termExtractionRequested.emit(params)

    # 树状关系更新
    def update_tree(self, hierarchy: dict):
        """
        根据提供的文件层级字典更新树状视图
        """
        self.tree.clear()
        
        if not hierarchy:
            return

        # 存储文件夹的QTreeWidgetItem，以便添加文件
        folder_items = {}

        # 先创建所有文件夹项
        sorted_dirs = sorted(hierarchy.keys())
        for dir_path in sorted_dirs:
            if dir_path == '.': # 根目录
                parent_item = self.tree.invisibleRootItem()
            else:
                # 逐级创建父目录
                parts = dir_path.replace('\\', '/').split('/')
                current_path = ""
                parent_item = self.tree.invisibleRootItem()
                for part in parts:
                    if not current_path:
                        current_path = part
                    else:
                        current_path = f"{current_path}/{part}"
                    
                    if current_path not in folder_items:
                        new_folder_item = QTreeWidgetItem([part])
                        # 标记为文件夹，不存储路径
                        new_folder_item.setData(0, Qt.UserRole, None) 
                        parent_item.addChild(new_folder_item)
                        folder_items[current_path] = new_folder_item
                        parent_item = new_folder_item
                    else:
                        parent_item = folder_items[current_path]
            
            # 添加文件到对应的文件夹项
            for filename in hierarchy[dir_path]:
                # 完整的相对路径
                full_path = os.path.join(dir_path, filename) if dir_path != '.' else filename
                file_item = QTreeWidgetItem([filename])
                # 使用 setData 存储文件的完整相对路径
                file_item.setData(0, Qt.UserRole, QVariant(full_path)) 
                parent_item.addChild(file_item)

        self.tree.expandAll()

# 标签栏
class PageCard(Base,CardWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(0)
        # 无边框

        # 创建水平布局用于放置 TabBar 和按钮
        tab_layout = QHBoxLayout()

        # 创建并配置 TabBar
        self.tab_bar = TabBar(self)
        self.tab_bar.setTabMaximumWidth(160)
        self.tab_bar.setTabShadowEnabled(False)
        self.tab_bar.setTabSelectedBackgroundColor(Qt.white, Qt.lightGray)
        self.tab_bar.setScrollable(True)

        # 创建按钮容器
        button_container = QWidget()
        button_layout = QHBoxLayout(button_container)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_layout.setSpacing(5)

        # 创建保存按钮
        self.save_button = TransparentToolButton(FIF.SAVE)
        self.save_button.setIconSize(QSize(16, 16))
        self.save_button.clicked.connect(self.on_save_button_clicked)

        # 将按钮添加到按钮容器布局
        button_layout.addWidget(self.save_button)


        # 将 TabBar 和按钮容器添加到水平布局
        tab_layout.addWidget(self.tab_bar, 1)  # 参数 1 表示该控件是可拉伸的
        tab_layout.addWidget(button_container) # 参数 0 (默认) 表示该控件不拉伸，保持原始大小

        # 将水平布局添加到主布局
        self.layout.addLayout(tab_layout)

        # 创建并添加 QStackedWidget
        self.stacked_widget = QStackedWidget(self)
        self.layout.addWidget(self.stacked_widget)

    def on_save_button_clicked(self):
        """
        获取配置中的 label_output_path 并调用手动保存缓存事件。
        不再生成最终翻译文件，只保存项目缓存。
        """
        config = self.load_config()
        output_path = config.get("label_output_path")

        # 检查路径是否存在，如果不存在则尝试创建
        try:
            cache_dir = os.path.join(output_path, "cache")
            if not os.path.isdir(cache_dir):
                os.makedirs(cache_dir, exist_ok=True)
        except OSError as e:
            self.error_toast(self.tra("路径错误"), self.tra("创建缓存目录失败: {}").format(e))
            return
        
        # 发出新的手动保存缓存事件
        self.emit(Base.EVENT.TASK_MANUAL_SAVE_CACHE, {"output_path": output_path})
        
        # 给予用户反馈
        self.success_toast(self.tra("成功"), self.tra("项目缓存文件已保存到翻译输出文件夹"))

# 标签页
class TabInterface(QWidget):
    def __init__(self, text: str, file_path: str, file_items: list, cache_manager, parent=None):
        super().__init__(parent=parent)
        self.vBoxLayout = QVBoxLayout(self)
        self.vBoxLayout.setContentsMargins(0, 0, 0, 0)

        # 将参数传递给 BasicTablePage
        self.tableView = BasicTablePage(file_path, file_items, cache_manager, self)
        self.vBoxLayout.addWidget(self.tableView)
        
        # 使用文件路径作为唯一的对象名称，避免特殊字符问题
        self.setObjectName(file_path)

# 主界面
class EditViewPage(Base,QFrame):

    languageCheckFinished = pyqtSignal(tuple)    

    def __init__(self, text: str, window, plugin_manager, cache_manager, file_reader) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        self.cache_manager = cache_manager  # 缓存管理器
        self.file_reader = file_reader  # 文件读取器

        # 创建主布局
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)  # 四周边距归零
        main_layout.setSpacing(0)  # 控件间距归零

        # 顶级堆叠控件，用于切换启动页和主界面
        self.top_stacked_widget = QStackedWidget()
        main_layout.addWidget(self.top_stacked_widget)

        # 创建启动页面
        support_project_types = self.file_reader.get_support_project_types()  # 获取支持的项目类型
        self.startup_page = StartupPage(support_project_types,window,cache_manager, file_reader)

        # 创建主界面控件
        self.main_interface = QWidget()
        self.main_interface_layout = QVBoxLayout(self.main_interface)
        self.main_interface_layout.setContentsMargins(0, 0, 0, 0)  # 四周边距归零
        self.main_interface_layout.setSpacing(0)  # 控件间距归零

        # 向主界面添加堆叠控件
        self.stacked_widget = QStackedWidget()

        # 主页面设置
        self.main_page = QWidget()
        self.main_page_layout = QVBoxLayout(self.main_page)
        self.splitter = QSplitter(Qt.Horizontal)  # 水平分割器
        self.nav_card = NavigationCard(window)  # 导航卡片
        self.page_card = PageCard()  # 页面卡片
        self.splitter.addWidget(self.nav_card)
        self.splitter.addWidget(self.page_card)
        self.splitter.setStretchFactor(0, 1) # 左邊 nav_card 佔 1 份
        self.splitter.setStretchFactor(1, 9) # 右邊 page_card 佔 9 份
        self.main_page_layout.addWidget(self.splitter)

        # 隐藏拖拽手柄，以免主题切换不和谐
        self.splitter.setHandleWidth(0)
        self.splitter.setStyleSheet("QSplitter::handle { width: 0px; }")

        # 监控页面设置
        self.monitoring_page = MonitoringPage()

        # 向堆叠控件添加页面，即信息展示页面与监控页面
        self.stacked_widget.addWidget(self.main_page)
        self.stacked_widget.addWidget(self.monitoring_page)

        # 底部命令栏设置
        self.bottom_bar_main = BottomCommandBar(window)

        # 组装主界面
        self.main_interface_layout.addWidget(self.stacked_widget)
        self.main_interface_layout.addWidget(self.bottom_bar_main)

        # 向顶级堆叠控件添加启动页面与主页面
        self.top_stacked_widget.addWidget(self.startup_page)
        self.top_stacked_widget.addWidget(self.main_interface)

        # 设置初始页面
        #self.stacked_widget.setCurrentIndex(1)  # 默认显示启动页
        self.top_stacked_widget.setCurrentIndex(0)  # 默认显示启动页


        # 连接各种信号
        self.nav_card.searchRequested.connect(self.perform_search) # 连接搜索按钮请求信号
        self.startup_page.folderSelected.connect(self.on_folder_selected) # 连接信号到界面切换和路径处理
        self.bottom_bar_main.back_btn.clicked.connect(self.on_back_button_clicked)  # 返回按钮绑定
        self.nav_card.tree.itemClicked.connect(self.on_tree_item_clicked)  # 树形项点击事件
        self.page_card.tab_bar.currentChanged.connect(self.on_tab_changed)  # 标签页切换事件
        self.page_card.tab_bar.tabCloseRequested.connect(self.on_tab_close_requested)  # 标签页关闭请求
        self.bottom_bar_main.arrowClicked.connect(self.toggle_page)  # 箭头按钮点击切换页面
        self.nav_card.termExtractionRequested.connect(self.perform_term_extraction) # 开始术语提取信号

        self.nav_card.languageCheckRequested.connect(self.perform_language_check) # 连接语言检查请求信号
        self.languageCheckFinished.connect(self._on_language_check_finished) # 语言检查完成信号


        # 订阅事件
        self.subscribe(Base.EVENT.TASK_CONTINUE_CHECK, self.task_continue_check)
        self.subscribe(Base.EVENT.TERM_EXTRACTION_DONE, self._on_term_extraction_finished)
              
        
    # 页面显示事件
    def showEvent(self, event) -> None:
        super().showEvent(event)
        # 触发继续状态检测事件
        self.task_continue_check( event = None, data = None)

    # 继续任务状态检查事件
    def task_continue_check(self, event: int, data: dict) -> None:
        threading.Thread(target = self.task_continue_check_target, daemon=True).start()

    # 继续任务状态检查
    def task_continue_check_target(self) -> None:
        time.sleep(0.5) # 等待页面切换效果

        self.continue_status = False # 默认为False

        if Base.work_status == Base.STATUS.IDLE:
            config = self.load_config()
            cache_folder_path = os.path.join(config.get("label_output_path", "./output"), "cache") # 添加默认值

            if not os.path.isdir(cache_folder_path):
                return False

            json_file_path = os.path.join(cache_folder_path, "ProjectStatistics.json")
            if not os.path.isfile(json_file_path):
                return False
            # 增强的JSON文件读取，防止并发访问和空文件问题
            max_retries = 3
            retry_delay = 0.1
            
            for attempt in range(max_retries):
                try:
                    # 检查文件大小，避免读取空文件
                    if os.path.getsize(json_file_path) == 0:
                        if attempt < max_retries - 1:
                            time.sleep(retry_delay)
                            continue
                        else:
                            print(f"[WARNING] ProjectStatistics.json文件为空，跳过继续检查")
                            return False
                    
                    # 安全读取JSON文件
                    with open(json_file_path, 'r', encoding='utf-8') as f:
                        content = f.read().strip()
                        if not content:
                            if attempt < max_retries - 1:
                                time.sleep(retry_delay)
                                continue
                            else:
                                print(f"[WARNING] ProjectStatistics.json内容为空")
                                return False
                        
                        data = json.loads(content)
                        break  # 成功读取，退出重试循环
                        
                except (json.JSONDecodeError, OSError, IOError) as e:
                    if attempt < max_retries - 1:
                        print(f"[WARNING] 读取ProjectStatistics.json失败(尝试{attempt+1}/{max_retries}): {e}")
                        time.sleep(retry_delay)
                        retry_delay *= 2  # 指数退避
                        continue
                    else:
                        print(f"[ERROR] 读取ProjectStatistics.json最终失败: {e}")
                        return False
                except Exception as e:
                    print(f"[ERROR] 读取ProjectStatistics.json时发生未知错误: {e}")
                    return False
            
            # 获取数据
            is_continue =  True
            project_name = data.get("project_name") # 获取已项目名字
            total_line = data.get("total_line") # 获取需翻译行数
            line = data.get("line") # 获取已翻译行数

            # 有数据则表示进行过任务,放宽读取范围
            if total_line:
                self.continue_status = True

            # 如果完成了任务，则不显示继续按钮
            if total_line and line >= total_line:
                is_continue = False

        # 根据任务状态，更新界面
        if self.continue_status == True :
            # 启动页显示继续翻译按钮
            self.startup_page.show_continue_button(True)
            # 命令栏启用继续按钮
            if is_continue:
                self.bottom_bar_main.enable_continue_button(True)
            # 在 ActionCard 上显示项目名
            self.startup_page.continue_card.set_project_name(project_name)

        else:
            self.startup_page.show_continue_button(False)
            # 命令栏禁用继续按钮
            self.bottom_bar_main.enable_continue_button(False)

    # 输入文件夹路径改变信号
    def on_folder_selected(self, project_name: str, project_mode: str):
        # 从缓存器获取文件层级结构
        file_hierarchy = self.cache_manager.get_file_hierarchy()
        # 更新导航卡片的树状视图
        self.nav_card.update_tree(file_hierarchy)

        # 更新底部命令栏的项目名
        self.bottom_bar_main.update_project_name(project_name)

        # 根据是否继续状态启用继续按钮
        if project_mode == "new":
            self.bottom_bar_main.enable_continue_button(False)
        else:
            # 启用底部命令栏的继续按钮
            self.bottom_bar_main.enable_continue_button(True)

        # 切换到主界面
        self.top_stacked_widget.setCurrentWidget(self.main_interface)

    # 底部命令栏返回按钮事件
    def on_back_button_clicked(self):

        if Base.work_status == Base.STATUS.IDLE:
            # 如果当前工作状态为空闲，则直接切换到启动页面
            self.top_stacked_widget.setCurrentIndex(0)
            return
        
    # 展开按钮事件，展开或收起监控页面
    def toggle_page(self):
        current_index = self.stacked_widget.currentIndex()
        new_index = 1 - current_index
        self.stacked_widget.setCurrentIndex(new_index)

    # 层级浏览器点击事件
    def on_tree_item_clicked(self, item, column):
        
        # 从 QTreeWidgetItem 中获取之前存储的文件路径
        file_path_variant = item.data(0, Qt.UserRole)
        
        # 如果 data 为 None，说明点击的是文件夹，直接返回
        if not file_path_variant:
            return

        file_path = file_path_variant # QVariant 会自动转换为 Python 类型

        # 检查标签页是否已经存在
        for i in range(self.page_card.stacked_widget.count()):
                widget = self.page_card.stacked_widget.widget(i)
                # 检查 widget 是否存在且 objectName 是否匹配
                if widget and widget.objectName() == file_path:
                    # 如果找到了，说明标签页已存在。
                    self.page_card.tab_bar.setCurrentIndex(i)
                    self.page_card.stacked_widget.setCurrentIndex(i)
                    return  # 任务完成，退出函数

        # 从缓存中获取该文件的所有文本项
        cache_file = self.cache_manager.project.get_file(file_path)
        if not cache_file:
            MessageBox(self.tra("错误"), self.tra("无法从缓存中加载文件: {}").format(file_path), self).exec() # M
            return
        
        file_items = cache_file.items

        # 创建新标签页，并传递所需的所有信息
        tab_name = os.path.basename(file_path) # 标签页只显示文件名
        new_tab = TabInterface(tab_name, file_path, file_items, self.cache_manager)
        
        self.page_card.stacked_widget.addWidget(new_tab)

        # 使用唯一的 file_path 作为 routeKey
        # 使用tab_name 作为显示的文本
        self.page_card.tab_bar.addTab(file_path, tab_name)
        
        new_index = self.page_card.tab_bar.count() - 1
        self.page_card.tab_bar.setCurrentIndex(new_index)

        # 立即切换到新创建的页面
        self.page_card.stacked_widget.setCurrentWidget(new_tab)

    # 标签页点击事件，切换到对应的页面
    def on_tab_changed(self, index):
        if index >= 0:
            widget = self.page_card.stacked_widget.widget(index)
            if widget:
                self.page_card.stacked_widget.setCurrentWidget(widget)

    # 标签页删除事件
    def on_tab_close_requested(self, index):
        # 确保 widget 存在再移除
        widget_to_remove = self.page_card.stacked_widget.widget(index)
        if widget_to_remove:
            self.page_card.stacked_widget.removeWidget(widget_to_remove)
            # Qt 会在稍后安全地删除 widget
            widget_to_remove.deleteLater()
        
        self.page_card.tab_bar.removeTab(index)

    # 执行搜索事件
    def perform_search(self, params: dict):
        """执行搜索并显示结果"""
        query = params["query"]
        scope = params["scope"]
        is_regex = params["is_regex"]
        search_flagged = params["search_flagged"]

        self.info(f"正在搜索: '{query}' (范围: {scope}, 正则: {is_regex}, 标记行: {search_flagged})")
        
        # 调用 CacheManager 执行搜索
        results = self.cache_manager.search_items(query, scope, is_regex, search_flagged)

        if not results:
            MessageBox(self.tra("未找到结果"), self.tra("未能找到与 '{}' 匹配的内容。").format(query), self.window()).exec() # M
            return
        
        # 创建搜索结果标签页
        tab_name = f"Search - {query[:20]}..."
        # 使用时间戳确保路由键唯一
        route_key = f"search_{int(time.time())}"

        # 检查是否已存在完全相同的搜索结果页（简单检查名称）
        for i in range(self.page_card.tab_bar.count()):
            if self.page_card.tab_bar.tabText(i) == tab_name:
                self.page_card.tab_bar.setCurrentIndex(i)
                # 同时也要确保内容页面切换
                self.page_card.stacked_widget.setCurrentIndex(i)
                return

        # 创建新的搜索结果页面实例
        search_page = SearchResultPage(results, self.cache_manager, params)
        search_page.setObjectName(route_key)

        # 添加新标签页
        self.page_card.stacked_widget.addWidget(search_page)
        self.page_card.tab_bar.addTab(routeKey=route_key, text=tab_name)

        # 获取新标签页的索引
        new_index = self.page_card.tab_bar.count() - 1
        
        # 显式地同时设置 TabBar 和 StackedWidget 的当前索引
        # 这样可以确保新标签页被激活并显示在前台
        self.page_card.tab_bar.setCurrentIndex(new_index)
        self.page_card.stacked_widget.setCurrentIndex(new_index)


    # 执行语言检查
    def perform_language_check(self, params: dict):
        """在一个单独的线程中执行检查流程"""
        self.info("开始执行检查任务...")
        # 启动线程
        thread = threading.Thread(target=self._language_check_worker, args=(params,), daemon=True)
        thread.start()

    def _language_check_worker(self, params: dict):
        """工作线程"""
        checker = TranslationChecker(self.cache_manager)
        # 调用新的流程入口
        result_code, data = checker.check_process(params)
        self.languageCheckFinished.emit((result_code, data))

    def _on_language_check_finished(self, result: tuple):
        """接收检查结果并在主线程中显示"""
        result_code, data = result
        
        # 如果有规则错误，则显示错误表格
        if result_code == CheckResult.HAS_RULE_ERRORS:
            self._show_check_result_table(data)
            return

        title = self.tra("检查结果")
        msg_box = None

        if result_code == CheckResult.ERROR_CACHE:
            msg_box = MessageBox(title, self.tra("检查失败，请检查项目文件夹缓存是否正常"), self.window())
        elif result_code == CheckResult.ERROR_NO_TRANSLATION:
            msg_box = MessageBox(title, self.tra("检查失败，请先执行翻译流程"), self.window())
        elif result_code == CheckResult.ERROR_NO_POLISH:
            msg_box = MessageBox(title, self.tra("检查失败，请先执行润色流程"), self.window())
        elif result_code == CheckResult.SUCCESS_REPORT:
            msg_box = MessageBox(title, self.tra("检测完成，请查看控制台输出"), self.window())
        elif result_code == CheckResult.SUCCESS_JUDGE_PASS:
            lang = data.get("target_language", "N/A")
            content = self.tra("检查通过：项目的所有文件均符合设定译文预期").format(lang)
            msg_box = MessageBox(title, content, self.window())
        elif result_code == CheckResult.SUCCESS_JUDGE_FAIL:
            lang = data.get("target_language", "N/A")
            content = self.tra("项目的所有文件译文语言占比不正常，请检查标记行和控制台输出").format(lang)
            msg_box = MessageBox(title, content, self.window())
        
        if msg_box:
            msg_box.yesButton.setText(self.tra("确认"))
            msg_box.cancelButton.hide()
            msg_box.exec()  

    # 表格显示方法
    def _show_check_result_table(self, errors: list):
        """创建并显示检查结果表格标签页"""
        tab_name = self.tra("检查结果")
        route_key = f"check_res_{int(time.time())}" # 唯一ID
        
        # 检查是否已存在同名页 
        for i in range(self.page_card.tab_bar.count()):
            if self.page_card.tab_bar.tabText(i) == tab_name:
                self.page_card.tab_bar.setCurrentIndex(i)
                self.page_card.stacked_widget.setCurrentIndex(i)
                # 也可以选择在这里刷新该页面的数据，目前选择新建页
                # return 
        
        result_page = CheckResultPage(errors, self.cache_manager)
        result_page.setObjectName(route_key)
        
        self.page_card.stacked_widget.addWidget(result_page)
        self.page_card.tab_bar.addTab(routeKey=route_key, text=tab_name)
        
        new_index = self.page_card.tab_bar.count() - 1
        self.page_card.tab_bar.setCurrentIndex(new_index)
        self.page_card.stacked_widget.setCurrentIndex(new_index)
        
        self.warning("检查完成，发现 {0} 个问题，请查看生成的表格。")

    # 执行提取术语事件
    def perform_term_extraction(self, params: dict):
        """
        从缓存获取数据，并发起一个全局的术语提取事件。
        """
        self.info(f"收到术语提取请求，参数: {params}")
        
        self.info("正在从缓存中收集所有原文...")
        all_items_to_process = self.cache_manager.get_all_source_items()
        
        self.info(f"数据收集完毕，共 {len(all_items_to_process)} 条。正在发送提取事件...")
        
        # 发送开始事件，将参数和数据传递给 SimpleExecutor
        self.emit(Base.EVENT.TERM_EXTRACTION_START, {
            "params": params,
            "items_data": all_items_to_process
        })

    # 术语提取结束事件
    def _on_term_extraction_finished(self, event: int, data: dict):
        """
        此槽函数在主线程中执行，用于接收 TERM_EXTRACTION_DONE 事件并安全地更新UI。
        """
        results = data.get("results", [])

        if not results:
            MessageBox(self.tra("未找到"), self.tra("未能提取到任何符合条件的术语。"), self.window()).exec()
            return

        # 创建并显示结果标签页 (这部分代码保持不变)
        tab_name = self.tra("术语提取结果")
        route_key = f"terms_{int(time.time())}"

        result_page = TermResultPage(results)
        result_page.setObjectName(route_key)
        
        self.page_card.stacked_widget.addWidget(result_page)
        self.page_card.tab_bar.addTab(routeKey=route_key, text=tab_name)
        
        new_index = self.page_card.tab_bar.count() - 1
        self.page_card.tab_bar.setCurrentIndex(new_index)
        self.page_card.stacked_widget.setCurrentIndex(new_index)
        self.info("术语提取完成，结果已显示。")


================================================
FILE: UserInterface/EditView/Check/CheckResultPage.py
================================================
[Binary file]


================================================
FILE: UserInterface/EditView/Check/LanguageCheckDialog.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QGridLayout, QHBoxLayout
from qfluentwidgets import CheckBox, ComboBox, MessageBoxBase, StrongBodyLabel, CaptionLabel
from Base.Base import Base

class LanguageCheckDialog(Base, MessageBoxBase):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 1. 定义默认配置
        self.default = {
            "check_target_polish": False, # False 表示检测译文，True 表示检测润文
            "check_lang_mode_text": "judge", # "report" 或 "judge",juedge 为精准判断
            "rule_check_exclusion": True,
            "rule_check_terminology": False,
            "rule_check_auto_process": True,
            "rule_check_placeholder": True,
            "rule_check_number": True,
            "rule_check_example": True,
            "rule_check_newline": True
        }
        
        self.config_data = self.save_config(self.load_config_from_default())

        self.view = QWidget(self)
        self.view_layout = QVBoxLayout(self.view)
        self.view_layout.setContentsMargins(0, 0, 0, 0)
        self.view_layout.setSpacing(20)
        self.view.setMinimumWidth(600) 

        self._init_ui()
        self._restore_ui_state()
        self._connect_signals()

        self.viewLayout.addWidget(self.view)
        
        self.yesButton.setText(self.tra("开始检查"))
        self.cancelButton.setText(self.tra("取消"))

    def _init_ui(self):
        # ... (保持原有 settings_container 代码不变) ...
        self.settings_container = QWidget()
        self.settings_layout = QGridLayout(self.settings_container)
        self.settings_layout.setContentsMargins(0, 0, 0, 0)
        self.settings_layout.setVerticalSpacing(15)
        self.settings_layout.setHorizontalSpacing(15)

        self.target_label = StrongBodyLabel(self.tra("检测对象:"), self)
        self.target_combo = ComboBox(self)
        self.target_combo.addItems([self.tra("译文"), self.tra("润文")])
        
        self.mode_label = StrongBodyLabel(self.tra("语言检测:"), self)
        self.mode_combo = ComboBox(self)
        self.mode_combo.addItems([self.tra("宏观统计"), self.tra("精准判断")])

        self.settings_layout.addWidget(self.target_label, 0, 0)
        self.settings_layout.addWidget(self.target_combo, 0, 1)
        self.settings_layout.addWidget(self.mode_label, 1, 0)
        self.settings_layout.addWidget(self.mode_combo, 1, 1)

        self.view_layout.addWidget(self.settings_container)

        # ================= 规则检查项 =================
        self.view_layout.addWidget(StrongBodyLabel(self.tra("规则检查项"), self))
        
        # [新增] 术语表检查 CheckBox
        self.check_terminology = CheckBox(self.tra("术语表检查"), self)
        self.check_exclusion = CheckBox(self.tra("禁翻表检查"), self)
        self.check_auto_process = CheckBox(self.tra("自动处理检查"), self)
        self.check_placeholder = CheckBox(self.tra("占位符残留"), self)
        self.check_number = CheckBox(self.tra("数字序号残留"), self)
        self.check_example = CheckBox(self.tra("示例文本复读"), self)
        self.check_newline = CheckBox(self.tra("换行符一致性"), self)

        # [新增] 添加选项说明
        self._add_option(self.check_terminology, self.tra("检查译文中是否包含术语表中的预定义译法"))
        self._add_option(self.check_exclusion, self.tra("检查译文中是否正确保留禁翻内容"))
        self._add_option(self.check_auto_process, self.tra("检查默认处理规则是否被正确执行"))
        self._add_option(self.check_placeholder, self.tra("检查 [P0] 等占位标签是否残留在文本中"))
        self._add_option(self.check_number, self.tra("检查行首数字编号 (1.) 是否残留"))
        self._add_option(self.check_example, self.tra("检查是否存在由模型生成的无效内容"))
        self._add_option(self.check_newline, self.tra("检查译文换行符数量是否与原文一致"))

    def _add_option(self, checkbox: CheckBox, description: str):
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(15)
        layout.addWidget(checkbox)
        desc_label = CaptionLabel(description, self)
        desc_label.setTextColor(QColor(120, 120, 120), QColor(160, 160, 160))
        layout.addWidget(desc_label, 1)
        self.view_layout.addWidget(container)
        self.view_layout.addSpacing(5)

    def _restore_ui_state(self):
        config = self.config_data
        
        is_polish = config.get("check_target_polish", False)
        self.target_combo.setCurrentIndex(1 if is_polish else 0)
        
        mode_code = config.get("check_lang_mode_text", "report")
        if mode_code == "judge":
            self.mode_combo.setCurrentText(self.tra("精准判断"))
        else:
            self.mode_combo.setCurrentText(self.tra("宏观统计"))

        # [新增] 恢复术语表状态
        self.check_terminology.setChecked(config.get("rule_check_terminology", True))
        self.check_exclusion.setChecked(config.get("rule_check_exclusion", True))
        self.check_auto_process.setChecked(config.get("rule_check_auto_process", True))
        self.check_placeholder.setChecked(config.get("rule_check_placeholder", True))
        self.check_number.setChecked(config.get("rule_check_number", True))
        self.check_example.setChecked(config.get("rule_check_example", True))
        self.check_newline.setChecked(config.get("rule_check_newline", True))

    def _connect_signals(self):
        self.target_combo.currentIndexChanged.connect(self._on_setting_changed)
        self.mode_combo.currentTextChanged.connect(self._on_setting_changed)
        
        # [新增] 连接信号
        self.check_terminology.stateChanged.connect(self._on_setting_changed)
        self.check_exclusion.stateChanged.connect(self._on_setting_changed)
        self.check_auto_process.stateChanged.connect(self._on_setting_changed)
        self.check_placeholder.stateChanged.connect(self._on_setting_changed)
        self.check_number.stateChanged.connect(self._on_setting_changed)
        self.check_example.stateChanged.connect(self._on_setting_changed)
        self.check_newline.stateChanged.connect(self._on_setting_changed)

    def _on_setting_changed(self):
        config = self.load_config()
        
        config["check_target_polish"] = (self.target_combo.currentIndex() == 1)
        
        if self.mode_combo.currentText() == self.tra("精准判断"):
            config["check_lang_mode_text"] = "judge"
        else:
            config["check_lang_mode_text"] = "report"
        
        # [新增] 保存术语表状态
        config["rule_check_terminology"] = self.check_terminology.isChecked()
        config["rule_check_exclusion"] = self.check_exclusion.isChecked()
        config["rule_check_auto_process"] = self.check_auto_process.isChecked()
        config["rule_check_placeholder"] = self.check_placeholder.isChecked()
        config["rule_check_number"] = self.check_number.isChecked()
        config["rule_check_example"] = self.check_example.isChecked()
        config["rule_check_newline"] = self.check_newline.isChecked()
        
        self.save_config(config)
        self.config_data = config

    def accept(self):
        is_polish = self.config_data.get("check_target_polish", False)
        mode_code = self.config_data.get("check_lang_mode_text", "report")

        self.check_params = {
            "target": "polish" if is_polish else "translate",
            "mode": mode_code,
            "rules": {
                "terminology": self.check_terminology.isChecked(),
                "exclusion": self.check_exclusion.isChecked(),
                "auto_process": self.check_auto_process.isChecked(),
                "placeholder": self.check_placeholder.isChecked(),
                "number": self.check_number.isChecked(),
                "example": self.check_example.isChecked(),
                "newline": self.check_newline.isChecked()
            }
        }
        super().accept()


================================================
FILE: UserInterface/EditView/Monitoring/MonitoringPage.py
================================================
import threading
import time
from PyQt5.QtWidgets import QLayout, QWidget, QVBoxLayout
from qfluentwidgets import (FlowLayout,FluentIcon as FIF)

from Base.Base import Base
from Widget.DashboardCard import DashboardCard
from Widget.WaveformCard import WaveformCard
from Widget.ProgressRingCard import ProgressRingCard
from Widget.CombinedLineCard import CombinedLineCard

# 监控页面
class MonitoringPage(Base,QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)  # 左、上、右、下

        # 添加控件
        self.head_hbox_container = QWidget(self)
        self.head_hbox = FlowLayout(self.head_hbox_container, needAni=False)
        self.head_hbox.setSpacing(8)
        self.head_hbox.setContentsMargins(0, 0, 0, 0)

        # 添加卡片控件
        self.add_combined_line_card(self.head_hbox)
        self.add_time_card(self.head_hbox)
        self.add_remaining_time_card(self.head_hbox)
        self.add_token_card(self.head_hbox)
        self.add_task_card(self.head_hbox)
        self.add_ring_card(self.head_hbox)
        self.add_waveform_card(self.head_hbox)
        self.add_speed_card(self.head_hbox)
        self.add_stability_card(self.head_hbox)

        # 添加到主容器
        self.container.addWidget(self.head_hbox_container, 1)

        # 注册事件
        self.subscribe(Base.EVENT.TASK_UPDATE, self.data_update) # 监听监控数据更新事件
        self.subscribe(Base.EVENT.TASK_COMPLETED, self.data_update)  # 监听任务完成事件

        # 监控页面数据存储
        self.data = {}


    # 进度环
    def add_ring_card(self, parent: QLayout) -> None:
        self.ring = ProgressRingCard(title=self.tra("任务进度"),
                    icon=FIF.PIE_SINGLE,
                    min_value=0,
                    max_value=10000,
                    ring_size=(140, 140),
                    text_visible=True)
        self.ring.setFixedSize(204, 204)
        self.ring.set_format(self.tra("无任务"))
        parent.addWidget(self.ring)

    # 波形图
    def add_waveform_card(self, parent: QLayout) -> None:
        self.waveform = WaveformCard(self.tra("波形图"),
                                    icon=FIF.MARKET
                                    )
        self.waveform.set_draw_grid(False)  # 关闭网格线
        self.waveform.setFixedSize(633, 204)
        parent.addWidget(self.waveform)

    # 累计时间
    def add_time_card(self, parent: QLayout) -> None:
        self.time = DashboardCard(
                title=self.tra("累计时间"),
                value="Time",
                unit="",
                icon=FIF.STOP_WATCH,
            )
        self.time.setFixedSize(204, 204)
        parent.addWidget(self.time)

    # 剩余时间
    def add_remaining_time_card(self, parent: QLayout) -> None:
        self.remaining_time = DashboardCard(
                title=self.tra("剩余时间"),
                value="Time",
                unit="",
                icon=FIF.FRIGID,
            )
        self.remaining_time.setFixedSize(204, 204)
        parent.addWidget(self.remaining_time)

    # 行数统计
    def add_combined_line_card(self, parent: QLayout) -> None:

        self.combined_line_card = CombinedLineCard(
            title=self.tra("行数统计"),
            icon=FIF.PRINT,
            left_title=self.tra("已完成"),
            right_title=self.tra("剩余"),
            initial_left_value="0",
            initial_left_unit="Line",
            initial_right_value="0",
            initial_right_unit="Line",
            parent=self
        )

        self.combined_line_card.setFixedSize(416, 204)
        parent.addWidget(self.combined_line_card)

    # 平均速度
    def add_speed_card(self, parent: QLayout) -> None:
        self.speed = DashboardCard(
                title=self.tra("平均速度"),
                value="T/S",
                unit="",
                icon=FIF.SPEED_HIGH,
            )
        self.speed.setFixedSize(204, 204)
        parent.addWidget(self.speed)

    # 累计消耗
    def add_token_card(self, parent: QLayout) -> None:
        self.token = DashboardCard(
                title=self.tra("累计消耗"),
                value="Token",
                unit="",
                icon=FIF.CALORIES,
            )
        self.token.setFixedSize(204, 204)
        parent.addWidget(self.token)

    # 并行任务
    def add_task_card(self, parent: QLayout) -> None:
        self.task = DashboardCard(
                title=self.tra("实时任务数"),
                value="0",
                unit="",
                icon=FIF.SCROLL,
            )
        self.task.setFixedSize(204, 204)
        parent.addWidget(self.task)

    # 稳定性
    def add_stability_card(self, parent: QLayout) -> None:
        self.stability = DashboardCard(
                title=self.tra("任务稳定性"),
                value="%",
                unit="",
                icon=FIF.TRAIN,
            )
        self.stability.setFixedSize(204, 204)
        parent.addWidget(self.stability)


    # 监控页面更新事件
    def data_update(self, event: int, data: dict) -> None:
        if Base.work_status in (Base.STATUS.STOPING, Base.STATUS.TASKING):
            self.update_time(event, data)
            self.update_line(event, data)
            self.update_token(event, data)
            self.update_stability(event, data)

        self.update_task(event, data)
        self.update_status(event, data)

    # 更新时间
    def update_time(self, event: int, data: dict) -> None:
        if data.get("start_time", None) is not None:
            self.data["start_time"] = data.get("start_time")

        if self.data.get("start_time", 0) == 0:
            total_time = 0
        else:
            total_time = int(time.time() - self.data.get("start_time", 0))

        if total_time < 60:
            self.time.set_unit("S")
            self.time.set_value(f"{total_time}")
        elif total_time < 60 * 60:
            self.time.set_unit("M")
            self.time.set_value(f"{(total_time / 60):.2f}")
        else:
            self.time.set_unit("H")
            self.time.set_value(f"{(total_time / 60 / 60):.2f}")

        remaining_time = int(total_time / max(1, self.data.get("line", 0)) * (self.data.get("total_line", 0) - self.data.get("line", 0)))
        if remaining_time < 60:
            self.remaining_time.set_unit("S")
            self.remaining_time.set_value(f"{remaining_time}")
        elif remaining_time < 60 * 60:
            self.remaining_time.set_unit("M")
            self.remaining_time.set_value(f"{(remaining_time / 60):.2f}")
        else:
            self.remaining_time.set_unit("H")
            self.remaining_time.set_value(f"{(remaining_time / 60 / 60):.2f}")

    # 更新行数
    def update_line(self, event: int, data: dict) -> None:
        if data.get("line", None) is not None and data.get("total_line", None) is not None:
            self.data["line"] = data.get("line")
            self.data["total_line"] = data.get("total_line")

        translated_line = self.data.get("line", 0)
        total_line = self.data.get("total_line", 0)
        remaining_line = max(0, total_line - translated_line)

        t_value_str: str
        t_unit_str: str
        if translated_line < 1000:
            t_unit_str = "Line"
            t_value_str = f"{translated_line}"
        elif translated_line < 1000 * 1000:
            t_unit_str = "KLine"
            t_value_str = f"{(translated_line / 1000):.2f}"
        else:
            t_unit_str = "MLine"
            t_value_str = f"{(translated_line / 1000 / 1000):.2f}"

        r_value_str: str
        r_unit_str: str
        if remaining_line < 1000:
            r_unit_str = "Line"
            r_value_str = f"{remaining_line}"
        elif remaining_line < 1000 * 1000:
            r_unit_str = "KLine"
            r_value_str = f"{(remaining_line / 1000):.2f}"
        else:
            r_unit_str = "MLine"
            r_value_str = f"{(remaining_line / 1000 / 1000):.2f}"

        if hasattr(self, 'combined_line_card') and self.combined_line_card:
            self.combined_line_card.set_left_data(value=t_value_str, unit=t_unit_str)
            self.combined_line_card.set_right_data(value=r_value_str, unit=r_unit_str)

    # 更新实时任务数
    def update_task(self, event: int, data: dict) -> None:
        task = len([t for t in threading.enumerate() if "translator" in t.name])
        if task < 1000:
            self.task.set_unit("Task")
            self.task.set_value(f"{task}")
        else:
            self.task.set_unit("KTask")
            self.task.set_value(f"{(task / 1000):.2f}")

    # 更新 Token 数据
    def update_token(self, event: int, data: dict) -> None:
        if data.get("token", None) is not None and data.get("total_completion_tokens", None) is not None:
            self.data["token"] = data.get("token")
            self.data["total_completion_tokens"] = data.get("total_completion_tokens")

        token = self.data.get("token", 0)
        if token < 1000:
            self.token.set_unit("Token")
            self.token.set_value(f"{token}")
        elif token < 1000 * 1000:
            self.token.set_unit("KToken")
            self.token.set_value(f"{(token / 1000):.2f}")
        else:
            self.token.set_unit("MToken")
            self.token.set_value(f"{(token / 1000 / 1000):.2f}")

        speed = self.data.get("total_completion_tokens", 0) / max(1, time.time() - self.data.get("start_time", 0))
        self.waveform.add_value(speed)
        if speed < 1000:
            self.speed.set_unit("T/S")
            self.speed.set_value(f"{speed:.2f}")
        else:
            self.speed.set_unit("KT/S")
            self.speed.set_value(f"{(speed / 1000):.2f}")

    # 更新稳定性
    def update_stability(self, event: int, data: dict) -> None:
        # 如果传入数据中包含新的请求统计，则更新数据
        if data.get("total_requests") is not None and data.get("error_requests") is not None:
            self.data["total_requests"] = data["total_requests"]
            self.data["error_requests"] = data["error_requests"]

        # 获取总请求数和错误请求数（默认值为0）
        total_requests = self.data.get("total_requests", 0)
        error_requests = self.data.get("error_requests", 0)  # 修正变量名错误

        # 计算稳定性百分比（成功率）
        if total_requests == 0:
            stability_percent = 0.0
        else:
            stability_percent = ((total_requests - error_requests) / total_requests) * 100  # 成功率计算

        # 设置单位和格式化百分比值（保留两位小数）
        self.stability.set_unit("%")
        self.stability.set_value(f"{stability_percent:.2f}")

    # 更新进度环
    def update_status(self, event: int, data: dict) -> None:
        if Base.work_status == Base.STATUS.STOPING:
            percent = self.data.get("line", 0) / max(1, self.data.get("total_line", 0))
            self.ring.set_value(int(percent * 10000))
            info_cont = self.tra("停止中") + "\n" + f"{percent * 100:.2f}%"
            self.ring.set_format(info_cont)
        elif Base.work_status == Base.STATUS.TASKING:
            percent = self.data.get("line", 0) / max(1, self.data.get("total_line", 0))
            self.ring.set_value(int(percent * 10000))
            info_cont = self.tra("任务中") + "\n" + f"{percent * 100:.2f}%"
            self.ring.set_format(info_cont)
        else:
            self.ring.set_value(0)
            info_cont = self.tra("无任务")
            self.ring.set_format(info_cont)




================================================
FILE: UserInterface/EditView/Search/SearchDialog.py
================================================

from qfluentwidgets import LineEdit, CheckBox, ComboBox, MessageBoxBase
from PyQt5.QtWidgets import QWidget, QVBoxLayout
from Base.Base import Base

class SearchDialog(Base,MessageBoxBase):
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 创建自定义视图
        self.view = QWidget(self)
        layout = QVBoxLayout(self.view)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(15)
        self.view.setMinimumWidth(350) 
        
        # 创建输入控件
        self.query_edit = LineEdit(self)
        self.query_edit.setPlaceholderText(self.tra("输入搜索内容..."))

        self.flagged_line_checkbox = CheckBox(self.tra("仅搜索被标记行"), self)
        self.regex_checkbox = CheckBox(self.tra("使用正则表达式"), self)
        
        self.scope_combo = ComboBox(self)
        self.scope_combo.addItems([self.tra("全文"), self.tra("原文"), self.tra("译文"), self.tra("润文")])
        
        # 将控件添加到布局中
        layout.addWidget(self.query_edit)
        layout.addWidget(self.flagged_line_checkbox)
        layout.addWidget(self.regex_checkbox)
        layout.addWidget(self.scope_combo)
        
        # 将自定义视图添加到对话框中
        self.viewLayout.addWidget(self.view)
        
        self.yesButton.setText(self.tra("搜索"))
        self.cancelButton.setText(self.tra("取消"))
        
        # 存储搜索参数
        self.search_scopes = {
            self.tra("全文"): "all",
            self.tra("原文"): "source_text",
            self.tra("译文"): "translated_text",
            self.tra("润文"): "polished_text"
        }
        self.search_query = ""
        self.is_regex = False
        self.search_scope = "all"
        self.is_flagged_search = False

    def accept(self):
        """当用户点击"搜索"按钮时，收集数据"""
        self.search_query = self.query_edit.text()
        self.is_flagged_search = self.flagged_line_checkbox.isChecked()
        self.is_regex = self.regex_checkbox.isChecked()
        selected_text = self.scope_combo.currentText()
        self.search_scope = self.search_scopes.get(selected_text, "all")
        
        if not self.search_query:
            pass # 允许空搜索
        
        super().accept()


================================================
FILE: UserInterface/EditView/Search/SearchResultPage.py
================================================
import os
import re 
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QBrush, QColor
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QTableWidgetItem, 
                             QAbstractItemView, QHeaderView, QHBoxLayout, QSpacerItem, QSizePolicy)

from qfluentwidgets import (TableWidget, PrimaryPushButton, LineEdit, StrongBodyLabel,
                            CheckBox)
from Base.Base import Base


class SearchResultPage(Base, QWidget):
    # ===== 列索引常量 ===== #
    COL_FILE = 0   # 文件名列
    COL_ROW = 1    # 行号列
    COL_SOURCE = 2 # 原文列
    COL_TRANS = 3  # 译文列
    COL_POLISH = 4 # 润文列

    def __init__(self, search_results: list, cache_manager, search_params: dict, parent=None):
        """搜索结果展示页面构造函数
        
        Args:
            search_results: 搜索结果列表，格式为[(文件路径, 行号, 文本项)]
            cache_manager: 缓存管理器实例，用于数据持久化
            search_params: 包含 'query', 'is_regex', 'scope' 的字典
            parent: 父组件
        """
        super().__init__(parent)
        self.setObjectName('SearchResultPage')
        
        self.cache_manager = cache_manager  # 缓存管理器实例
        self.search_params = search_params  # 存储搜索参数
        
        # 主布局
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(10, 8, 10, 8)  # 设置边距
        self.layout.setSpacing(10)  # 设置组件间距

        # 初始化批量替换面板
        self._init_replace_panel()

        # 初始化表格组件
        self.table = TableWidget(self)
        self._init_table()
        self.layout.addWidget(self.table)
        
        # 填充表格数据
        self._populate_data(search_results)

        # 连接表格内容变更信号
        self.table.itemChanged.connect(self._on_item_changed)

    def _init_replace_panel(self):
        """初始化批量替换面板（包含查找/替换输入框、选项和操作按钮）"""
        self.replace_panel = QWidget(self)
        self.replace_panel.setObjectName("replacePanel")
        
        # 面板布局
        panel_layout = QVBoxLayout(self.replace_panel)
        panel_layout.setContentsMargins(0, 0, 0, 5)
        panel_layout.setSpacing(8)

        # 创建两行布局：第一行输入框，第二行选项和按钮
        row1_layout = QHBoxLayout()
        row2_layout = QHBoxLayout()

        # ===== 第一行：查找和替换输入 ===== #
        row1_layout.addWidget(StrongBodyLabel(self.tra("查找内容:"), self))
        self.find_input = LineEdit(self)
        self.find_input.setPlaceholderText(self.tra("输入搜索内容...")) 
        row1_layout.addWidget(self.find_input)
        
        row1_layout.addSpacing(20)  # 添加间距

        row1_layout.addWidget(StrongBodyLabel(self.tra("替换为:"), self))
        self.replace_input = LineEdit(self)
        self.replace_input.setPlaceholderText(self.tra("输入替换后的文本..."))
        row1_layout.addWidget(self.replace_input)
        
        # ===== 第二行：替换选项和操作 ===== #
        row2_layout.addWidget(StrongBodyLabel(self.tra("选项:"), self))
        # 大小写匹配复选框
        self.case_checkbox = CheckBox(self.tra("区分大小写"), self)
        # 全词匹配复选框
        self.whole_word_checkbox = CheckBox(self.tra("全词匹配"), self)
        # 正则表达式模式复选框
        self.regex_checkbox = CheckBox(self.tra("正则模式"), self)
        
        row2_layout.addWidget(self.case_checkbox)
        row2_layout.addWidget(self.whole_word_checkbox)
        row2_layout.addWidget(self.regex_checkbox)
        
        row2_layout.addSpacing(15)  # 添加间距
        
        # 替换范围选择
        row2_layout.addWidget(StrongBodyLabel(self.tra("范围:"), self))
        self.trans_col_checkbox = CheckBox(self.tra("译文列"), self)
        self.polish_col_checkbox = CheckBox(self.tra("润文列"), self)
        self.trans_col_checkbox.setChecked(True)  # 默认选中译文列
        row2_layout.addWidget(self.trans_col_checkbox)
        row2_layout.addWidget(self.polish_col_checkbox)

        # 添加弹性空间使按钮靠右
        row2_layout.addSpacerItem(QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum))
        
        # 全部替换按钮
        self.replace_all_button = PrimaryPushButton(self.tra("全部替换"), self)
        row2_layout.addWidget(self.replace_all_button)

        # 将两行布局添加到面板
        panel_layout.addLayout(row1_layout)
        panel_layout.addLayout(row2_layout)

        # 添加面板到主布局
        self.layout.addWidget(self.replace_panel)
        
        # ===== 信号连接 ===== #
        # 正则模式切换时更新UI状态
        self.regex_checkbox.toggled.connect(self._on_regex_toggled)
        # 绑定全部替换按钮点击事件
        self.replace_all_button.clicked.connect(self._on_replace_all_clicked)

    def _on_regex_toggled(self, is_checked: bool):
        """正则模式复选框状态变化处理
        
        当启用正则模式时：
        1. 禁用全词匹配选项（二者互斥）
        2. 自动取消全词匹配的选中状态
        """
        self.whole_word_checkbox.setEnabled(not is_checked)
        if is_checked:
            self.whole_word_checkbox.setChecked(False)

    def _init_table(self):
        """初始化表格控件（设置列名、样式和交互行为）"""
        # 表格列标题（已翻译）
        self.headers = [
            self.tra("文件"), 
            self.tra("行"), 
            self.tra("原文"), 
            self.tra("译文"), 
            self.tra("润文")
        ]
        self.table.setColumnCount(len(self.headers))
        self.table.setHorizontalHeaderLabels(self.headers)
        self.table.verticalHeader().hide()  # 隐藏行号列
        self.table.setAlternatingRowColors(True)  # 启用斑马纹
        self.table.setWordWrap(True)  # 允许文本换行
        #self.table.setBorderVisible(True)  # 显示边框
        self.table.setBorderRadius(8)  # 圆角边框
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)  # 扩展选择模式
        
        # 设置表头行为
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.Interactive)  # 可交互调整列宽
        header.setStretchLastSection(True)  # 最后一列自动拉伸
        
        # 设置初始列宽
        self.table.setColumnWidth(0, 150)  # 文件名列
        self.table.setColumnWidth(1, 55)   # 行号列
        self.table.setColumnWidth(2, 300)  # 原文列
        self.table.setColumnWidth(3, 300)  # 译文列

    def _populate_data(self, search_results: list):
        """将搜索结果填充到表格中
        
        Args:
            search_results: 搜索结果列表，格式为[(文件路径, 行号, 文本项)]
        """
        # 阻塞信号防止频繁触发itemChanged
        self.table.blockSignals(True)

        # 定义高亮颜色
        highlight_brush = QBrush(QColor(144, 238, 144, 100))
        
        # 设置表格行数
        self.table.setRowCount(len(search_results))

        # 遍历所有搜索结果
        for row_idx, result_info in enumerate(search_results):
            file_path, original_row_num, item = result_info

            # 文件名项（不可编辑）
            file_item = QTableWidgetItem(os.path.basename(file_path))
            file_item.setFlags(file_item.flags() & ~Qt.ItemIsEditable)
            self.table.setItem(row_idx, self.COL_FILE, file_item)

            # 行号项（不可编辑，存储原始数据）
            row_num_item = QTableWidgetItem(str(original_row_num))
            row_num_item.setTextAlignment(Qt.AlignCenter)  # 居中对齐
            row_num_item.setFlags(row_num_item.flags() & ~Qt.ItemIsEditable)
            # 存储元数据：(文件路径, 文本索引)
            row_num_item.setData(Qt.UserRole, (file_path, item.text_index))
            self.table.setItem(row_idx, self.COL_ROW, row_num_item)

            # 原文项（不可编辑）
            source_item = QTableWidgetItem(item.source_text)
            source_item.setFlags(source_item.flags() & ~Qt.ItemIsEditable)
            self.table.setItem(row_idx, self.COL_SOURCE, source_item)

            # 译文项（可编辑）
            trans_item = QTableWidgetItem(item.translated_text)
            self.table.setItem(row_idx, self.COL_TRANS, trans_item)
            # 润文项（可编辑）
            polish_item = QTableWidgetItem(item.polished_text or '')
            self.table.setItem(row_idx, self.COL_POLISH, polish_item)

            # 检查并应用高亮
            if item.extra:
                if item.extra.get('language_mismatch_translation', False):
                    trans_item.setBackground(highlight_brush)
                if item.extra.get('language_mismatch_polish', False):
                    polish_item.setBackground(highlight_brush)
        
        # 自动调整行高以适应内容
        self.table.resizeRowsToContents()
        # 恢复信号连接
        self.table.blockSignals(False)

    def _on_item_changed(self, item: QTableWidgetItem):
        """处理表格内容变更事件（用户编辑译文/润文列时触发）
        
        1. 获取被修改的单元格位置
        2. 通过关联的行号项获取元数据
        3. 更新缓存管理器中的对应数据
        """
        row = item.row()
        col = item.column()

        # 仅处理译文列(3)和润文列(4)的变更
        if col not in [self.COL_TRANS, self.COL_POLISH]:
            return

        # 获取关联的行号项（存储元数据）
        ref_item = self.table.item(row, self.COL_ROW)
        if not ref_item:
            return
        
        # 解析元数据：(文件路径, 文本索引)
        file_path, text_index = ref_item.data(Qt.UserRole)
        new_text = item.text()  # 获取修改后的文本

        # 确定修改的是译文还是润文
        field_name = 'translated_text' if col == self.COL_TRANS else 'polished_text'
        
        # 更新缓存数据
        self.cache_manager.update_item_text(
            storage_path=file_path,
            text_index=text_index,
            field_name=field_name,
            new_text=new_text
        )

    def _on_replace_all_clicked(self):
        """执行全部替换操作
        步骤：
        1. 验证输入有效性
        2. 获取所有替换选项
        3. 遍历目标单元格
        4. 执行替换并更新UI
        5. 显示操作结果
        """
        # 获取用户输入和选项
        find_text = self.find_input.text()
        replace_text = self.replace_input.text()
        is_case_sensitive = self.case_checkbox.isChecked()
        is_whole_word = self.whole_word_checkbox.isChecked()
        is_regex = self.regex_checkbox.isChecked()
        in_trans_col = self.trans_col_checkbox.isChecked()
        in_polish_col = self.polish_col_checkbox.isChecked()

        # 输入验证
        if not find_text:
            self.error_toast(self.tra("失败"), self.tra("查找内容不能为空。"))
            return
        
        if not in_trans_col and not in_polish_col:
            self.error_toast(self.tra("失败"), self.tra("请至少选择一个替换范围（译文列或润文列）。"))
            return

        # 正则表达式预编译验证
        if is_regex:
            try:
                # 尝试编译正则表达式（带大小写敏感标志）
                flags = 0 if is_case_sensitive else re.IGNORECASE
                re.compile(find_text, flags)
            except re.error as e:
                self.error_toast(self.tra("替换失败"), self.tra(f"无效的正则表达式：{e}"))
                return

        # 确定目标列索引
        target_cols = []
        if in_trans_col:
            target_cols.append(self.COL_TRANS)
        if in_polish_col:
            target_cols.append(self.COL_POLISH)

        # 阻塞表格信号
        self.table.blockSignals(True)
        
        replacement_count = 0  # 替换计数器
        # 遍历所有行和目标列
        for row in range(self.table.rowCount()):
            for col in target_cols:
                item = self.table.item(row, col)
                if not item:
                    continue
                
                original_text = item.text()
                # 执行实际替换操作
                new_text = self._perform_replace(
                    original_text, find_text, replace_text, 
                    is_case_sensitive, is_whole_word, is_regex
                )

                # 更新发生变化的单元格
                if original_text != new_text:
                    # 1. 更新UI
                    item.setText(new_text)
                    replacement_count += 1
                    
                    # 2. 获取元数据
                    ref_item = self.table.item(row, self.COL_ROW)
                    if ref_item:
                        file_path, text_index = ref_item.data(Qt.UserRole)
                        
                        # 3. 确定修改的字段
                        field_name = 'translated_text' if col == self.COL_TRANS else 'polished_text'
                        
                        # 4. 调用缓存管理器更新数据
                        self.cache_manager.update_item_text(
                            storage_path=file_path,
                            text_index=text_index,
                            field_name=field_name,
                            new_text=new_text
                        )
        
        # 恢复信号连接并更新UI
        self.table.blockSignals(False)
        self.table.resizeRowsToContents()  # 重新调整行高

        # 显示操作结果
        self.success_toast(
            self.tra("操作完成"), 
            self.tra(f"共找到并替换了 {replacement_count} 处。")
        )

    def _perform_replace(self, text, find, replace, case_sensitive, whole_word, is_regex):
        """执行实际文本替换逻辑
        
        支持三种模式：
        1. 正则表达式模式
        2. 全词匹配模式
        3. 普通文本替换模式
        
        Returns:
            str: 替换后的新文本
        """
        # 正则表达式模式
        if is_regex:
            flags = 0 if case_sensitive else re.IGNORECASE
            return re.sub(find, replace, text, flags=flags)

        # 非正则模式
        flags = 0 if case_sensitive else re.IGNORECASE
        
        # 全词匹配模式
        if whole_word:
            pattern = r'\b' + re.escape(find) + r'\b'
            return re.sub(pattern, replace, text, flags=flags)
        # 普通文本替换
        else:
            if case_sensitive:
                # 区分大小写 - 使用高效的原生替换
                return text.replace(find, replace)
            else:
                # 不区分大小写 - 使用正则替换
                return re.sub(re.escape(find), replace, text, flags=flags)


================================================
FILE: UserInterface/EditView/Startup/StartupPage.py
================================================
import threading
from PyQt5.QtWidgets import QLayout, QVBoxLayout, QWidget
from qfluentwidgets import pyqtSignal, StateToolTip
from qfluentwidgets.components.date_time.calendar_picker import FIF

from Base.Base import Base
from Widget.LineEditCard import LineEditCard
from Widget.FolderDropCard import FolderDropCard
from Widget.ComboBoxCard import ComboBoxCard
from Widget.ActionCard import ActionCard

class StartupPage(Base, QWidget):
    """开始页面"""
    folderSelected = pyqtSignal(str, str)  # 信号：通知主界面文件夹已选好，切换页面
    loadSuccess = pyqtSignal(str, str)     # 信号(子线程->主线程)：项目加载成功
    loadFailed = pyqtSignal(str)           # 信号(子线程->主线程)：项目加载失败

    def __init__(self, support_project_types=None, parent=None, cache_manager=None, file_reader=None):
        super().__init__(parent)
        self.support_project_types = support_project_types
        self.cache_manager = cache_manager
        self.file_reader = file_reader
        self.stateTooltip = None  # 用于显示状态提示

        # 连接子线程信号到主线程的槽函数
        self.loadSuccess.connect(self._on_load_success)
        self.loadFailed.connect(self._on_load_failed)

        # 默认配置
        self.default = {
            "translation_project": "AutoType",
            "label_input_path": "./input",
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        # 添加组件

        self.add_widget_projecttype(self.container, config)
        self.add_widget_folder_drop(self.container, config)

        # 添加“继续项目”入口
        self.continue_card = ActionCard(
            title=self.tra("继续项目"),
            description=self.tra("加载上次的项目缓存并继续"),
            button_text=self.tra("继续"),
            icon=FIF.RIGHT_ARROW,
            parent=self
        )
        self.continue_card.hide()
        self.continue_card.clicked.connect(lambda: self.folder_path_changed("continue"))
        self.container.addWidget(self.continue_card)

        # 添加弹簧
        self.container.addStretch(1)

    def show_continue_button(self, show: bool) -> None:
        """显示或隐藏继续按钮入口"""
        if show:
            self.continue_card.show()
        else:
            self.continue_card.hide()

    def add_widget_projecttype(self, parent, config) -> None:
        """项目类型"""
        translated_pairs = [(self.tra(project_type), project_type) for project_type in self.support_project_types]

        def init(widget) -> None:
            current_config = self.load_config()
            current_value = current_config.get("translation_project", "AutoType")
            index = next((i for i, (_, value) in enumerate(translated_pairs) if value == current_value), 0)
            widget.set_current_index(max(0, index))

        def current_text_changed(widget, text: str) -> None:
            value = next((value for display, value in translated_pairs if display == text), "AutoType")
            config = self.load_config()
            config["translation_project"] = value
            self.save_config(config)

        options = [display for display, value in translated_pairs]
        parent.addWidget(
            ComboBoxCard(
                self.tra("项目类型"),
                self.tra("设置当前翻译项目所使用的原始文本的格式，注意，选择错误将不能进行翻译"),
                options,
                init=init,
                current_text_changed=current_text_changed
            )
        )

    def add_widget_folder_drop(self, parent: QLayout, config: dict) -> None:
        """输入文件夹"""
        def widget_callback(path: str) -> None:
            current_config = self.load_config()
            current_config["label_input_path"] = path.strip()
            self.save_config(current_config)
            self.folder_path_changed("new")

        initial_path = config.get("label_input_path", "./input")
        # 将 drag_card 保存为实例属性，以便后续禁用/启用
        self.drag_card = FolderDropCard(
            init=initial_path,
            path_changed=widget_callback,
        )
        parent.addWidget(self.drag_card)

    def folder_path_changed(self, mode: str) -> None:
        """
        [主线程] 用户点击按钮或输入文件夹后调用此方法。
        它负责启动UI提示并开启一个子线程来执行耗时的加载任务。
        """
        # 显示加载提示
        if self.stateTooltip:
            self.stateTooltip.close()
        
        self.stateTooltip = StateToolTip(self.tra('正在加载项目...'), self.tra('客官请耐心等待哦~~'), self.window())
        # 将提示工具移动到窗口上方居中的位置
        x = self.window().width() // 2 - self.stateTooltip.width() // 2
        y = 32  # 设置一个固定的顶部边距
        self.stateTooltip.move(x, y)
        self.stateTooltip.show()

        # 禁用输入控件，防止重复操作
        self.drag_card.setEnabled(False)
        self.continue_card.setEnabled(False)

        # 在子线程中执行加载任务
        loader_thread = threading.Thread(target=self._load_project_worker, args=(mode,), daemon=True)
        loader_thread.start()

    def _load_project_worker(self, mode: str) -> None:
        """
        [子线程] 执行实际的文件读取和缓存加载工作。
        完成后通过信号通知主线程结果。
        """
        try:
            config = self.load_config()
            translation_project = config.get("translation_project", "AutoType")
            label_input_path = config.get("label_input_path", "./input")
            label_input_exclude_rule = config.get("label_input_exclude_rule", "")
            label_output_path = config.get("label_output_path", "./output")

            if mode == "new":
                CacheProject = self.file_reader.read_files(
                    translation_project,
                    label_input_path,
                    label_input_exclude_rule
                )
                self.cache_manager.load_from_project(CacheProject)
            else:  # "continue"
                self.cache_manager.load_from_file(label_output_path)

            if self.cache_manager.get_item_count() == 0:
                raise ValueError("项目数据为空，可能是项目类型或输入文件夹设置不正确。")

            project_name = self.cache_manager.project.project_name
            self.loadSuccess.emit(project_name, mode)

        except Exception as e:
            error_message = "翻译项目数据载入失败 ... 请检查是否正确设置项目类型与输入文件夹 ..."
            self.error(error_message, e)
            self.loadFailed.emit(error_message)

    def _on_load_success(self, project_name: str, project_mode: str) -> None:
        """
        [主线程] 接收加载成功信号后的处理函数。
        """
        # 更新UI提示为成功状态
        if self.stateTooltip:
            info = self.tra('项目加载成功！') + '🚀'
            self.stateTooltip.setContent(self.tra(info))
            self.stateTooltip.setState(True)
            self.stateTooltip = None  # 重置以便下次使用

        # 重新启用控件
        self.drag_card.setEnabled(True)
        self.continue_card.setEnabled(True)

        # 打印文件信息到控制台
        self.print("")
        self.info(f"项目数据全部载入成功 ...")
        for _, file in self.cache_manager.project.files.items():
            language_stats = file.language_stats
            storage_path = file.storage_path
            encoding = file.encoding
            file_project_type = file.file_project_type

            self.print("")
            self.info(f"已经载入文件 - {storage_path}")
            self.info(f"文件类型 - {file_project_type}")
            self.info(f"文件编码 - {encoding}")
            self.info(f"语言统计 - {language_stats}")
        self.print("")

        # 发送最终信号，通知主界面切换页面
        self.folderSelected.emit(project_name, project_mode)

    def _on_load_failed(self, error_message: str) -> None:
        """
        [主线程] 接收加载失败信号后的处理函数。
        """
        # 更新UI提示为失败状态
        if self.stateTooltip:
            info = self.tra('加载失败...') + '😵'
            self.stateTooltip.setContent(self.tra(info))
            self.stateTooltip.setState(False)
            self.stateTooltip = None  # 重置以便下次使用

        # 重新启用控件
        self.drag_card.setEnabled(True)
        self.continue_card.setEnabled(True)

        # 弹出错误提示
        self.error_toast(self.tra("错误"), error_message)


================================================
FILE: UserInterface/EditView/Term/TermExtractionDialog.py
================================================
import os
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QGridLayout, QHBoxLayout
from qfluentwidgets import (ComboBox, CheckBox, MessageBoxBase, StrongBodyLabel, 
                            InfoBar, InfoBarPosition, CaptionLabel, HyperlinkButton,
                            SubtitleLabel, BodyLabel)
from Base.Base import Base

class TermExtractionDialog(Base, MessageBoxBase):
    """
    术语提取设置对话框。
    """
    def __init__(self, parent=None):
        super().__init__(parent)

        # --- 1. 定义不同语言的标签集 ---
        self.JAPANESE_TYPES = ["PERSON", "ORG", "GPE", "LOC", "PRODUCT", "EVENT"]
        self.CHINESE_TYPES = self.JAPANESE_TYPES
        self.ENGLISH_TYPES = self.JAPANESE_TYPES
        self.KOREAN_TYPES = ["DT", "LC", "OG", "PS", "QT"]
        self.DEFAULT_TYPES = self.JAPANESE_TYPES

        # --- 2. 初始化主视图 ---
        self.view = QWidget(self)
        self.view.setMinimumWidth(480) # 加宽以容纳更详细的标签
        
        # 主布局
        self.main_layout = QVBoxLayout(self.view)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(20) # 增加间距，利用留白区分区块

        # =================================================
        #   UI 区域 1: 顶部标题与说明
        # =================================================
        header_layout = QVBoxLayout()
        header_layout.setSpacing(6)
        
        # 1.1 大标题
        title_label = SubtitleLabel(self.tra("术语提取"), self)
        header_layout.addWidget(title_label)
        
        # 1.2 功能说明
        desc_text = self.tra("选择合适的NER模型，自动识别并提取文本中的专有名词（如人名、地名）。")
        desc_label = BodyLabel(desc_text, self)
        desc_label.setTextColor(Qt.gray, Qt.gray) # 设置灰色字体作为次要信息
        desc_label.setWordWrap(True) # 允许换行
        header_layout.addWidget(desc_label)
        
        self.main_layout.addLayout(header_layout)

        # =================================================
        #   UI 区域 2: 模型选择
        # =================================================
        model_section = QVBoxLayout()
        model_section.setSpacing(8)

        # 2.1 区域标题行 (包含标题和右侧链接)
        model_header_row = QHBoxLayout()
        model_header_row.addWidget(StrongBodyLabel(self.tra("1. 选择分词模型"), self))
        model_header_row.addStretch(1)
        
        tutorial_url = "https://github.com/NEKOparapa/AiNiee/wiki/NER%E6%A8%A1%E5%9E%8B%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%8D%97" 
        self.tutorialButton = HyperlinkButton(url=tutorial_url, text=self.tra("模型下载指南"), parent=self)
        model_header_row.addWidget(self.tutorialButton)
        
        model_section.addLayout(model_header_row)

        # 2.2 下拉框
        self.model_combo = ComboBox(self)
        self.load_ner_models()
        model_section.addWidget(self.model_combo)

        # 2.3 底部小提示
        prefix_tip = self.tra("提示: 日语选择ja模型，英语选择en模型，韩语选择ko模型")
        model_section.addWidget(CaptionLabel(prefix_tip, self))
        
        self.main_layout.addLayout(model_section)

        # =================================================
        #   UI 区域 3: 实体类型选择 (替代原来的 GroupBox)
        # =================================================
        entity_section = QVBoxLayout()
        entity_section.setSpacing(10)

        # 3.1 区域标题
        entity_section.addWidget(StrongBodyLabel(self.tra("2. 提取内容类型"), self))

        # 3.2 复选框容器 (使用 QWidget + Grid 替代 GroupBox)
        self.entity_container = QWidget(self)
        self.entity_layout = QGridLayout(self.entity_container)
        self.entity_layout.setContentsMargins(0, 5, 0, 5) # 稍微缩进一点
        self.entity_layout.setVerticalSpacing(12)
        self.entity_layout.setHorizontalSpacing(20)
        
        self.entity_checkboxes = {}
        
        entity_section.addWidget(self.entity_container)
        self.main_layout.addLayout(entity_section)

        # =================================================

        # --- 信号连接 ---
        self.model_combo.currentTextChanged.connect(self._update_entity_checkboxes)

        # --- 初始加载 ---
        if self.model_combo.count() > 0:
            self._update_entity_checkboxes(self.model_combo.currentText())

        # 添加视图到 MessageBox
        self.viewLayout.addWidget(self.view)

        # 按钮文字
        self.yesButton.setText(self.tra("开始提取"))
        self.cancelButton.setText(self.tra("取消"))

        self.selected_model = None
        self.selected_types = []

    def _clear_layout(self, layout):
        if layout is None: return
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()

    def _update_entity_checkboxes(self, model_name: str):
        """
        根据模型名称更新实体类型复选框
        """
        # 1. 确定标签列表
        if model_name.startswith(('ja_', 'ja-')):
            types_to_display = self.JAPANESE_TYPES
        elif model_name.startswith(('en_', 'en-')):
            types_to_display = self.ENGLISH_TYPES
        elif model_name.startswith(('zh_', 'zh-')):
            types_to_display = self.CHINESE_TYPES
        elif model_name.startswith(('ko_', 'ko-')):
            types_to_display = self.KOREAN_TYPES
        else:
            types_to_display = self.DEFAULT_TYPES

        # 2. 清空旧布局
        self._clear_layout(self.entity_layout)
        self.entity_checkboxes.clear()

        # 3. 标签翻译映射
        type_map = {
            "PERSON": self.tra("人物 (Person)"),
            "ORG": self.tra("组织 (Org)"),
            "GPE": self.tra("国家/城市 (GPE)"),
            "LOC": self.tra("地点 (Loc)"),
            "PRODUCT": self.tra("产品/作品 (Product)"),
            "EVENT": self.tra("事件 (Event)"),
            # 韩语标签映射
            "DT": self.tra("日期 (Date)"),
            "LC": self.tra("地点 (Location)"),
            "OG": self.tra("组织 (Org)"),
            "PS": self.tra("人物 (Person)"),
            "QT": self.tra("数量 (Quantity)")
        }

        # 4. 创建新的复选框
        row, col = 0, 0
        for entity_type in types_to_display:
            # 获取友好的显示文本
            display_text = type_map.get(entity_type, entity_type)
            
            checkbox = CheckBox(display_text, self)
            checkbox.setChecked(True)
            
            # 存储引用
            self.entity_checkboxes[entity_type] = checkbox
            
            self.entity_layout.addWidget(checkbox, row, col)
            
            # 每行显示 2 个，布局更宽松清晰
            col += 1
            if col > 1: 
                col = 0
                row += 1

    def load_ner_models(self):
        """扫描NER模型"""
        model_dir = os.path.join('.', 'Resource', 'Models', 'ner')
        if not os.path.exists(model_dir):
            self.model_combo.addItem(self.tra("未找到模型目录"))
            self.model_combo.setEnabled(False)
            self.yesButton.setEnabled(False)
            return

        models = []
        try:
            models = [d.name for d in os.scandir(model_dir) if d.is_dir()]
        except:
            pass

        if models:
            self.model_combo.addItems(sorted(models))
        else:
            self.model_combo.addItem(self.tra("目录中无可用模型"))
            self.model_combo.setEnabled(False)
            self.yesButton.setEnabled(False)

    def accept(self):
        """数据收集与校验"""
        self.selected_model = self.model_combo.currentText()
        
        self.selected_types = [
            k for k, cb in self.entity_checkboxes.items() if cb.isChecked()
        ]

        if not self.selected_model or not self.model_combo.isEnabled() or "未找到" in self.selected_model or "无可用" in self.selected_model:
            InfoBar.error(
                title=self.tra('错误'),
                content=self.tra("请先选择一个可用的语言模型。"),
                duration=3000,
                position=InfoBarPosition.TOP,
                parent=self.parent()
            )
            return

        if not self.selected_types:
            InfoBar.error(
                title=self.tra('错误'),
                content=self.tra("请至少选择一个提取类型。"),
                duration=3000,
                position=InfoBarPosition.TOP,
                parent=self.parent()
            )
            return
        
        super().accept()


================================================
FILE: UserInterface/EditView/Term/TermResultPage.py
================================================
import os
from PyQt5.QtCore import Qt, QPoint
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QTableWidgetItem,
                             QAbstractItemView, QHeaderView, QHBoxLayout,
                             QSpacerItem, QSizePolicy)

from qfluentwidgets import (TableWidget, PrimaryPushButton, FluentIcon,
                              RoundMenu, Action, MessageBox)
from Base.Base import Base

class TermResultPage(Base, QWidget):
    """
    用于显示术语提取结果的页面。
    """
    # 定义列索引常量
    COL_TERM = 0
    COL_COUNT = 1
    COL_TYPE = 2
    COL_CONTEXT = 3
    COL_FILE = 4

    def __init__(self, extraction_results: list, parent=None):
        super().__init__(parent)
        self.setObjectName('TermResultPage')

        # 存储提取结果以供后续使用
        self.extraction_results = extraction_results

        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(10, 8, 10, 8)
        self.layout.setSpacing(10)

        self._init_toolbar()

        self.table = TableWidget(self)
        self._init_table()
        self.layout.addWidget(self.table)

        self._populate_data(extraction_results)

    def _init_toolbar(self):
        """初始化顶部工具栏"""
        toolbar_layout = QHBoxLayout()
        toolbar_layout.setContentsMargins(0, 0, 0, 0)
        toolbar_layout.addSpacerItem(QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum))
        self.translate_save_button = PrimaryPushButton(FluentIcon.LANGUAGE, self.tra("翻译后保存到术语表"), self)
        self.translate_save_button.clicked.connect(self._on_translate_and_save)
        toolbar_layout.addWidget(self.translate_save_button)
        self.save_button = PrimaryPushButton(FluentIcon.DICTIONARY_ADD, self.tra("直接保存到术语表"), self)
        self.save_button.clicked.connect(self._on_save_to_glossary)
        toolbar_layout.addWidget(self.save_button)
        self.layout.addLayout(toolbar_layout)

    def _init_table(self):
        """初始化表格样式和表头"""
        self.headers = [self.tra("术语"), self.tra("出现次数"), self.tra("类型"), self.tra("所在原文"), self.tra("来源文件")]
        self.table.setColumnCount(len(self.headers))
        self.table.setHorizontalHeaderLabels(self.headers)
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.setWordWrap(True)
        self.table.setBorderVisible(True)
        self.table.setBorderRadius(8)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)

        # 启用多行选择
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)

        header = self.table.horizontalHeader()
        header.setSortIndicatorShown(False)
        header.setSectionResizeMode(QHeaderView.Interactive)
        header.setStretchLastSection(True)
        self.table.setColumnWidth(self.COL_TERM, 180)
        self.table.setColumnWidth(self.COL_COUNT, 90)
        self.table.setColumnWidth(self.COL_TYPE, 120)
        self.table.setColumnWidth(self.COL_CONTEXT, 400)
        self.table.setColumnWidth(self.COL_FILE, 180)

        # 自定义上下文菜单策略并连接信号
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self._show_context_menu)

    def _populate_data(self, results: list):
        """用提取结果填充表格"""
        self.table.setSortingEnabled(False)
        self.table.setRowCount(len(results))
        for row_idx, result in enumerate(results):
            term_item = QTableWidgetItem(result["term"])
            type_item = QTableWidgetItem(result["type"])
            context_item = QTableWidgetItem(result["context"])
            file_item = QTableWidgetItem(os.path.basename(result["file_path"]))
            count = result.get('count', 1)
            count_item = QTableWidgetItem()
            count_item.setData(Qt.DisplayRole, count)
            count_item.setData(Qt.EditRole, count)
            count_item.setTextAlignment(Qt.AlignCenter)
            self.table.setItem(row_idx, self.COL_TERM, term_item)
            self.table.setItem(row_idx, self.COL_COUNT, count_item)
            self.table.setItem(row_idx, self.COL_TYPE, type_item)
            self.table.setItem(row_idx, self.COL_CONTEXT, context_item)
            self.table.setItem(row_idx, self.COL_FILE, file_item)
        self.table.resizeRowsToContents()
        self.table.setSortingEnabled(True)
        self.table.sortByColumn(self.COL_COUNT, Qt.DescendingOrder)


    def _show_context_menu(self, pos: QPoint):
        """当在表格上右键时，显示上下文菜单"""
        menu = RoundMenu(parent=self)

        # 检查是否有行被选中
        selected_rows = self.table.selectionModel().selectedRows()
        has_selection = bool(selected_rows)

        # 添加“删除行”选项
        delete_action = Action(FluentIcon.DELETE, self.tra("删除选中行"))
        delete_action.setEnabled(has_selection) # 仅在有选中行时启用
        delete_action.triggered.connect(self._delete_selected_rows)
        menu.addAction(delete_action)

        menu.addSeparator()

        # 添加“行数信息”选项
        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.INFO, self.tra("总行数: {}").format(row_count))
        row_count_action.setEnabled(False)  # 仅作信息展示，不可点击
        menu.addAction(row_count_action)

        # 在鼠标光标位置显示菜单
        global_pos = self.table.mapToGlobal(pos)
        menu.exec(global_pos)

    def _delete_selected_rows(self):
        """删除所有选中的行"""
        selected_indexes = self.table.selectedIndexes()
        if not selected_indexes:
            return

        # 获取所有不重复的选中行号
        rows_to_delete = sorted(list(set(index.row() for index in selected_indexes)))

        # 弹出确认对话框
        confirm_msg = MessageBox(
            self.tra("确认删除"),
            self.tra("您确定要删除选中的 {} 行吗？此操作不可撤销。").format(len(rows_to_delete)),
            self.window()
        )
        if not confirm_msg.exec():
            return # 用户点击了取消

        # 从后往前删除，避免索引变化导致错误
        for row in reversed(rows_to_delete):
            # 从数据模型中删除
            del self.extraction_results[row]
            # 从视图（表格）中删除
            self.table.removeRow(row)

        self.success_toast(
            self.tra("操作成功"),
            self.tra("已成功删除 {} 行。").format(len(rows_to_delete))
        )

    def _on_save_to_glossary(self):
        """处理“直接保存到术语表”按钮点击事件"""
        if not self.extraction_results:
            self.warning_toast(self.tra("提示"), self.tra("没有可保存的术语。"))
            return
        try:
            config = self.load_config()
            prompt_dictionary_data = config.get("prompt_dictionary_data", [])
            existing_srcs = {item['src'] for item in prompt_dictionary_data}
            added_count = 0
            for result in self.extraction_results:
                src = result['term']
                if src not in existing_srcs:
                    new_entry = {
                        "src": src,
                        "dst": "",
                        "info": result['type']
                    }
                    prompt_dictionary_data.append(new_entry)
                    existing_srcs.add(src)
                    added_count += 1
            config["prompt_dictionary_data"] = prompt_dictionary_data
            self.save_config(config)
            self.success_toast(
                self.tra("保存成功"),
                self.tra(f"已添加 {added_count} 个新术语到术语表。")
            )
        except Exception as e:
            self.error_toast(self.tr("保存失败"), str(e))
            self.error(f"保存术语表时发生错误: {e}")

    def _on_translate_and_save(self):
        """处理“翻译后保存到术语表”按钮点击事件"""
        if not self.extraction_results:
            self.warning_toast(self.tra("提示"), self.tra("没有可处理的术语。"))
            return
        self.emit(Base.EVENT.TERM_TRANSLATE_SAVE_START, {
            "extraction_results": self.extraction_results
        })
        self.info_toast(
            self.tra("任务已开始"),
            self.tra("正在后台根据原文进行提取、翻译和保存，请稍后...")
        )


================================================
FILE: UserInterface/EditView/Timer/ScheduledDialogPage.py
================================================
from PyQt5.QtCore import QTime
from qfluentwidgets import BodyLabel, MessageBoxBase, TimePicker, StrongBodyLabel

from Base.Base import Base

class ScheduledDialogPage(MessageBoxBase, Base):
    """
    定时开始任务对话框
    """
    def __init__(self, parent=None,title: str = "定时开始任务", message_box_close = None):
        super().__init__(parent=parent)

        self.message_box_close = message_box_close

        # 设置框体
        self.yesButton.setText(self.tra("确定"))
        self.cancelButton.setText((self.tra("取消")))

        self.viewLayout.setContentsMargins(16, 16, 16, 16)
        self.title_label = StrongBodyLabel(title, self)
        self.viewLayout.addWidget(self.title_label)

        # 添加说明标签
        info_label = BodyLabel(self.tra("请设置开始任务的时间"))
        self.viewLayout.addWidget(info_label)

        self.time_picker = TimePicker(self)
        current_time = QTime.currentTime()
        self.time_picker.setTime(current_time)

        self.viewLayout.addWidget(self.time_picker)

        self.yesButton.clicked.connect(self.accept)
        self.cancelButton.clicked.connect(self.reject)

    def get_scheduled_time(self):
        return self.time_picker.getTime()


================================================
FILE: UserInterface/Extraction_Tool/Export_Source_Text.py
================================================
import os
import yaml

from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CheckBox
from qfluentwidgets import FluentIcon
from qfluentwidgets import PushButton
from qfluentwidgets import HyperlinkButton
from qfluentwidgets import StrongBodyLabel
from qfluentwidgets import PrimaryPushButton

class Widget_export_source_text(QFrame):#  提取子界面
    def __init__(self, text: str, parent=None,jtpp=None):#解释器会自动调用这个函数
        super().__init__(parent=parent)          #调用父类的构造函数
        self.setObjectName(text.replace(' ', '-'))#设置对象名，作用是在NavigationInterface中的addItem中的routeKey参数中使用
        self.jtpp = jtpp
        #设置各个控件-----------------------------------------------------------------------------------------



        # -----创建第1个组，添加多个组件-----
        box = QGroupBox()
        layout = QHBoxLayout()


        self.labe1_3 = StrongBodyLabel()
        self.labe1_3.setText("RPG Maker MV/MZ 的文本提取注入工具")


        #设置官方文档说明链接按钮
        hyperlinkButton = HyperlinkButton(
            url='https://www.ai2.moe/topic/10271-%E8%87%AA%E5%88%9B%E5%B7%A5%E5%85%B7%E7%BF%BB%E8%AF%91%E5%B7%A5%E5%85%B7rpg%E7%BF%BB%E8%AF%91jt%EF%BC%8C%E7%9B%AE%E6%A0%87%E6%98%AF%E9%9B%B6%E9%97%A8%E6%A7%9B%E7%9A%84%EF%BC%8C%E5%86%85%E5%B5%8C%E4%BA%86%E5%A4%9A%E4%B8%AA%E8%84%9A%E6%9C%AC%E7%9A%84%E9%9D%92%E6%98%A5%E7%89%88t214%E5%BA%A6%E7%9B%98/',
            text='(使用说明)'
        )


        layout.addStretch(1)  # 添加伸缩项
        layout.addWidget(self.labe1_3)
        layout.addWidget(hyperlinkButton)
        layout.addStretch(1)  # 添加伸缩项
        box.setLayout(layout)




        # -----创建第1个组，添加多个组件-----
        box_switch = QGroupBox()
        layout_switch = QHBoxLayout()

        #设置“是否日语游戏”标签
        self.labe1_4 = StrongBodyLabel()
        self.labe1_4.setText("是否日语游戏")



        # 设置“是否日语游戏”选择开关
        self.SwitchButton_ja = CheckBox('        ')
        self.SwitchButton_ja.setChecked(True)
        # 绑定选择开关的点击事件
        self.SwitchButton_ja.clicked.connect(self.test)



        layout_switch.addWidget(self.labe1_4)
        layout_switch.addStretch(1)  # 添加伸缩项
        layout_switch.addWidget(self.SwitchButton_ja)
        box_switch.setLayout(layout_switch)



        # -----创建第2个组，添加多个组件-----
        box_input = QGroupBox()
        layout_input = QHBoxLayout()

        #设置“游戏文件夹”标签
        label4 = StrongBodyLabel()
        label4.setText("游戏文件夹")

        #设置“游戏文件夹”显示
        self.label_input_path = StrongBodyLabel()
        self.label_input_path.setText("(游戏根目录文件夹)")

        #设置打开文件按钮
        self.pushButton_input = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_input.clicked.connect(self.Select_project_folder) #按钮绑定槽函数



        layout_input.addWidget(label4)
        layout_input.addWidget(self.label_input_path)
        layout_input.addStretch(1)  # 添加伸缩项
        layout_input.addWidget(self.pushButton_input)
        box_input.setLayout(layout_input)



        # -----创建第3个组，添加多个组件-----
        box_output = QGroupBox()
        layout_output = QHBoxLayout()

        #设置“输出文件夹”标签
        label6 = StrongBodyLabel()
        label6.setText("原文存储文件夹")

        #设置“输出文件夹”显示
        self.label_output_path = StrongBodyLabel()
        self.label_output_path.setText("(游戏原文提取后存放的文件夹)")

        #设置输出文件夹按钮
        self.pushButton_output = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_output.clicked.connect(self.Select_output_folder) #按钮绑定槽函数


        layout_output.addWidget(label6)
        layout_output.addWidget(self.label_output_path)
        layout_output.addStretch(1)  # 添加伸缩项
        layout_output.addWidget(self.pushButton_output)
        box_output.setLayout(layout_output)



        # -----创建第3个组，添加多个组件-----
        box_data = QGroupBox()
        layout_data = QHBoxLayout()

        #设置“输出文件夹”标签
        label6 = StrongBodyLabel()
        label6.setText("工程存储文件夹")

        #设置“输出文件夹”显示
        self.label_data_path = StrongBodyLabel()
        self.label_data_path.setText("(该游戏工程数据存放的文件夹)")

        #设置输出文件夹按钮
        self.pushButton_data = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_data.clicked.connect(self.Select_data_folder) #按钮绑定槽函数


        layout_data.addWidget(label6)
        layout_data.addWidget(self.label_data_path)
        layout_data.addStretch(1)  # 添加伸缩项
        layout_data.addWidget(self.pushButton_data)
        box_data.setLayout(layout_data)





        # -----创建第x个组，添加多个组件-----
        box_start_export = QGroupBox()
        layout_start_export = QHBoxLayout()


        #设置“开始翻译”的按钮
        self.primaryButton_start_export = PrimaryPushButton('开始提取原文', self, FluentIcon.UPDATE)
        self.primaryButton_start_export.clicked.connect(self.Start_export) #按钮绑定槽函数


        layout_start_export.addStretch(1)  # 添加伸缩项
        layout_start_export.addWidget(self.primaryButton_start_export)
        layout_start_export.addStretch(1)  # 添加伸缩项
        box_start_export.setLayout(layout_start_export)



        # 最外层的垂直布局
        container = QVBoxLayout()

        # 把内容添加到容器中
        container.addStretch(1)  # 添加伸缩项
        container.addWidget(box)
        container.addWidget(box_switch)
        container.addWidget(box_input)
        container.addWidget(box_output)
        container.addWidget(box_data)
        container.addWidget(box_start_export)
        container.addStretch(1)  # 添加伸缩项

        # 设置窗口显示的内容是最外层容器
        self.setLayout(container)
        container.setSpacing(28) # 设置布局内控件的间距为28
        container.setContentsMargins(50, 70, 50, 30) # 设置布局的边距, 也就是外边框距离，分别为左、上、右、下

    #设置开关绑定函数
    def test(self, isChecked: bool):
        if isChecked== False:
            print("[INFO] 不建议使用在非日语游戏上,容易出现问题")

    # 选择输入文件夹按钮绑定函数
    def Select_project_folder(self):
        label_input_path = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if label_input_path:
            self.label_input_path.setText(label_input_path)
            print('[INFO] 已选择游戏根目录文件夹: ',label_input_path)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作


    # 选择原文文件夹按钮绑定函数
    def Select_output_folder(self):
        label_output_path = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if label_output_path:
            self.label_output_path.setText(label_output_path)
            print('[INFO] 已选择原文存储文件夹:' ,label_output_path)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作


    # 选择工程文件夹按钮绑定函数
    def Select_data_folder(self):
        data_Folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if data_Folder:
            self.label_data_path.setText(data_Folder)
            print('[INFO] 已选择工程存储文件夹:' ,data_Folder)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作


    # 提取函数
    def Start_export(self):
        print('[INFO] 开始提取游戏原文,请耐心等待！！！')

        #读取配置文件
        config_path = os.path.join(".", "StevExtraction", "config.yaml") 

        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)

        #修改输入输出路径及开关
        config['game_path'] = self.label_input_path.text()
        config['save_path'] = self.label_data_path.text()
        config['data_path'] = self.label_output_path.text()
        config['ja']=self.SwitchButton_ja.isChecked()
        #提取文本
        pj=self.jtpp.Jr_Tpp(config)
        pj.FromGame(config['game_path'],config['save_path'],config['data_path'])


================================================
FILE: UserInterface/Extraction_Tool/Export_Update_Text.py
================================================
import os
import yaml

from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import FluentIcon
from qfluentwidgets import PushButton
from qfluentwidgets import StrongBodyLabel
from qfluentwidgets import PrimaryPushButton


class Widget_update_text(QFrame):#  更新子界面
    def __init__(self, text: str, parent=None,jtpp=None):#解释器会自动调用这个函数
        super().__init__(parent=parent)          #调用父类的构造函数
        self.setObjectName(text.replace(' ', '-'))#设置对象名，作用是在NavigationInterface中的addItem中的routeKey参数中使用
        self.jtpp = jtpp
        #设置各个控件-----------------------------------------------------------------------------------------



        # -----创建第1个组，添加多个组件-----
        box_input = QGroupBox()
        layout_input = QHBoxLayout()

        #设置“输入文件夹”标签
        label4 = StrongBodyLabel()
        label4.setText("游戏文件夹")

        #设置“输入文件夹”显示
        self.label_input_path = StrongBodyLabel()
        self.label_input_path.setText("(新版本的游戏根目录文件夹)")

        #设置打开文件按钮
        self.pushButton_input = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_input.clicked.connect(self.Select_game_folder) #按钮绑定槽函数



        layout_input.addWidget(label4)
        layout_input.addWidget(self.label_input_path)
        layout_input.addStretch(1)  # 添加伸缩项
        layout_input.addWidget(self.pushButton_input)
        box_input.setLayout(layout_input)



        # -----创建第2个组，添加多个组件-----
        box_data = QGroupBox()
        layout_data = QHBoxLayout()

        #设置“输入文件夹”标签
        label4 = StrongBodyLabel()
        label4.setText("工程文件夹")

        #设置“输入文件夹”显示
        self.label_data_path = StrongBodyLabel()
        self.label_data_path.setText("(新版本游戏导出的工程数据文件夹)")

        #设置打开文件按钮
        self.pushButton_data = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_data.clicked.connect(self.Select_data_folder) #按钮绑定槽函数



        layout_data.addWidget(label4)
        layout_data.addWidget(self.label_data_path)
        layout_data.addStretch(1)  # 添加伸缩项
        layout_data.addWidget(self.pushButton_data)
        box_data.setLayout(layout_data)



        # -----创建第3个组，添加多个组件-----
        box_translation_folder = QGroupBox()
        layout_translation_folder = QHBoxLayout()

        #设置“输出文件夹”标签
        self.label6 = StrongBodyLabel()
        self.label6.setText("译文文件夹")

        #设置“输出文件夹”显示
        self.label_translation_folder = StrongBodyLabel()
        self.label_translation_folder.setText("(旧版本游戏的译文文件存放的文件夹)")

        #设置输出文件夹按钮
        self.pushButton_translation_folder = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_translation_folder.clicked.connect(self.Select_translation_folder) #按钮绑定槽函数


        layout_translation_folder.addWidget(self.label6)
        layout_translation_folder.addWidget(self.label_translation_folder)
        layout_translation_folder.addStretch(1)  # 添加伸缩项
        layout_translation_folder.addWidget(self.pushButton_translation_folder)
        box_translation_folder.setLayout(layout_translation_folder)


        # -----创建第4个组，添加多个组件-----
        box_output_folder = QGroupBox()
        layout_putput_folder = QHBoxLayout()

        #设置“输出文件夹”标签
        self.label7 = StrongBodyLabel()
        self.label7.setText("保存文件夹")

        #设置“输出文件夹”显示
        self.label_output_folder = StrongBodyLabel()
        self.label_output_folder.setText("(新版游戏提取到的原文与旧版译文合并后，剩下的需要翻译的原文保存路径)")

        #设置输出文件夹按钮
        self.pushButton_putput_folder = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_putput_folder.clicked.connect(self.Select_save_folder) #按钮绑定槽函数


        layout_putput_folder.addWidget(self.label7)
        layout_putput_folder.addWidget(self.label_output_folder)
        layout_putput_folder.addStretch(1)  # 添加伸缩项
        layout_putput_folder.addWidget(self.pushButton_putput_folder)
        box_output_folder.setLayout(layout_putput_folder)





        # -----创建第x个组，添加多个组件-----
        box_start_import = QGroupBox()
        layout_start_import = QHBoxLayout()


        #设置“开始翻译”的按钮
        self.primaryButton_start_import = PrimaryPushButton('开始提取原文', self, FluentIcon.UPDATE)
        self.primaryButton_start_import.clicked.connect(self.Start_import) #按钮绑定槽函数


        layout_start_import.addStretch(1)  # 添加伸缩项
        layout_start_import.addWidget(self.primaryButton_start_import)
        layout_start_import.addStretch(1)  # 添加伸缩项
        box_start_import.setLayout(layout_start_import)



        # 最外层的垂直布局
        container = QVBoxLayout()

        # 把内容添加到容器中
        container.addStretch(1)  # 添加伸缩项
        container.addWidget(box_input)
        container.addWidget(box_data)
        container.addWidget(box_translation_folder)
        container.addWidget(box_output_folder)
        container.addWidget(box_start_import)
        container.addStretch(1)  # 添加伸缩项

        # 设置窗口显示的内容是最外层容器
        self.setLayout(container)
        container.setSpacing(28) # 设置布局内控件的间距为28
        container.setContentsMargins(50, 70, 50, 30) # 设置布局的边距, 也就是外边框距离，分别为左、上、右、下


    # 选择输入文件夹按钮绑定函数
    def Select_game_folder(self):
        label_input_path = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if label_input_path:
            self.label_input_path.setText(label_input_path)
            print('[INFO] 已选择新版游戏文件夹: ',label_input_path)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作

    # 选择工程文件夹按钮绑定函数
    def Select_data_folder(self):
        Data_Folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if Data_Folder:
            self.label_data_path.setText(Data_Folder)
            print('[INFO] 已选择新版游戏工程数据文件夹: ',Data_Folder)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作

    # 选择译文文件夹按钮绑定函数
    def Select_translation_folder(self):
        translation_folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if translation_folder:
            self.label_translation_folder.setText(translation_folder)
            print('[INFO] 已选择旧版译文文件夹:' ,translation_folder)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作

    # 选择存储文件夹按钮绑定函数
    def Select_save_folder(self):
        save_folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if save_folder:
            self.label_output_folder.setText(save_folder)
            print('[INFO] 已选择保存文件夹:' ,save_folder)
        else :
            print('[INFO] 未选择文件夹')


    # 导入按钮绑定函数
    def Start_import(self):
        print('[INFO] 开始提取新版本游戏原文,请耐心等待！！！')

        #读取配置文件
        current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
        config_path = os.path.join(current_dir, "StevExtraction", "config.yaml")


        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)

        #修改配置信息
        config['game_path'] = self.label_input_path.text()
        config['save_path'] = self.label_data_path.text()
        config['translation_path'] = self.label_translation_folder.text()
        config['data_path'] = self.label_output_folder.text()


        #导入文本
        pj=self.jtpp.Jr_Tpp(config)
        pj.Update(config['game_path'],config['translation_path'],config['save_path'],config['data_path'])


================================================
FILE: UserInterface/Extraction_Tool/Import_Translated_Text.py
================================================
import os
import yaml

from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import SpinBox
from qfluentwidgets import LineEdit
from qfluentwidgets import CheckBox
from qfluentwidgets import FluentIcon
from qfluentwidgets import PushButton
from qfluentwidgets import StrongBodyLabel
from qfluentwidgets import PrimaryPushButton


class Widget_import_translated_text(QFrame):#  导入子界面
    def __init__(self, text: str, parent=None, jtpp=None):#解释器会自动调用这个函数
        super().__init__(parent=parent)          #调用父类的构造函数
        self.setObjectName(text.replace(' ', '-'))#设置对象名，作用是在NavigationInterface中的addItem中的routeKey参数中使用
        self.jtpp = jtpp
        #设置各个控件-----------------------------------------------------------------------------------------



        # -----创建第1个组，添加多个组件-----
        box_input = QGroupBox()
        layout_input = QHBoxLayout()

        #设置“输入文件夹”标签
        label4 = StrongBodyLabel()
        label4.setText("游戏文件夹")

        #设置“输入文件夹”显示
        self.label_input_path = StrongBodyLabel()
        self.label_input_path.setText("(原来的游戏根目录文件夹)")

        #设置打开文件按钮
        self.pushButton_input = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_input.clicked.connect(self.Select_game_folder) #按钮绑定槽函数



        layout_input.addWidget(label4)
        layout_input.addWidget(self.label_input_path)
        layout_input.addStretch(1)  # 添加伸缩项
        layout_input.addWidget(self.pushButton_input)
        box_input.setLayout(layout_input)



        # -----创建第2个组，添加多个组件-----
        box_data = QGroupBox()
        layout_data = QHBoxLayout()

        #设置“输入文件夹”标签
        label4 = StrongBodyLabel()
        label4.setText("工程文件夹")

        #设置“输入文件夹”显示
        self.label_data_path = StrongBodyLabel()
        self.label_data_path.setText("(原来导出的工程数据文件夹)")

        #设置打开文件按钮
        self.pushButton_data = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_data.clicked.connect(self.Select_data_folder) #按钮绑定槽函数



        layout_data.addWidget(label4)
        layout_data.addWidget(self.label_data_path)
        layout_data.addStretch(1)  # 添加伸缩项
        layout_data.addWidget(self.pushButton_data)
        box_data.setLayout(layout_data)



        # -----创建第3个组，添加多个组件-----
        box_translation_folder = QGroupBox()
        layout_translation_folder = QHBoxLayout()

        #设置“输出文件夹”标签
        self.label6 = StrongBodyLabel()
        self.label6.setText("译文文件夹")

        #设置“输出文件夹”显示
        self.label_translation_folder = StrongBodyLabel()
        self.label_translation_folder.setText("(译文文件存放的文件夹)")

        #设置输出文件夹按钮
        self.pushButton_translation_folder = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_translation_folder.clicked.connect(self.Select_translation_folder) #按钮绑定槽函数


        layout_translation_folder.addWidget(self.label6)
        layout_translation_folder.addWidget(self.label_translation_folder)
        layout_translation_folder.addStretch(1)  # 添加伸缩项
        layout_translation_folder.addWidget(self.pushButton_translation_folder)
        box_translation_folder.setLayout(layout_translation_folder)


        # -----创建第4个组，添加多个组件-----
        box_output_folder = QGroupBox()
        layout_putput_folder = QHBoxLayout()

        #设置“输出文件夹”标签
        self.label7 = StrongBodyLabel()
        self.label7.setText("存储文件夹")

        #设置“输出文件夹”显示
        self.label_output_folder = StrongBodyLabel()
        self.label_output_folder.setText("(游戏文件注入译文后，存放的文件夹)")

        #设置输出文件夹按钮
        self.pushButton_putput_folder = PushButton('选择文件夹', self, FluentIcon.FOLDER)
        self.pushButton_putput_folder.clicked.connect(self.Select_save_folder) #按钮绑定槽函数


        layout_putput_folder.addWidget(self.label7)
        layout_putput_folder.addWidget(self.label_output_folder)
        layout_putput_folder.addStretch(1)  # 添加伸缩项
        layout_putput_folder.addWidget(self.pushButton_putput_folder)
        box_output_folder.setLayout(layout_putput_folder)



        # -----创建第5个组，添加多个组件-----
        box_title_watermark1 = QGroupBox()
        layout_title_watermark1 = QHBoxLayout()


        self.LineEdit_title_watermark = LineEdit()

        #设置微调距离用的空白标签
        self.labelB = StrongBodyLabel()
        self.labelB.setText("          ")

        # 设置“添加游戏标题水印”选择开关
        self.checkBox_title_watermark = CheckBox('添加标题水印', self)



        layout_title_watermark1.addWidget(self.LineEdit_title_watermark)
        layout_title_watermark1.addWidget(self.labelB)
        layout_title_watermark1.addWidget(self.checkBox_title_watermark)
        box_title_watermark1.setLayout(layout_title_watermark1)





        # -----创建第5个组，添加多个组件-----
        box_auto_wrap = QGroupBox()
        layout_auto_wrap = QHBoxLayout()

        #设置标签
        label4 = StrongBodyLabel()
        label4.setText("换行字数")

        self.spinBox_auto_wrap = SpinBox(self)
        self.spinBox_auto_wrap.setRange(0, 1000)
        self.spinBox_auto_wrap.setValue(0)


        # 设置“添加游戏标题水印”选择开关
        self.checkBox_auto_wrap = CheckBox('启用自动换行', self)


        layout_auto_wrap.addWidget(label4)
        layout_auto_wrap.addWidget(self.spinBox_auto_wrap)
        layout_auto_wrap.addStretch(1)
        layout_auto_wrap.addWidget(self.checkBox_auto_wrap)
        box_auto_wrap.setLayout(layout_auto_wrap)


        # -----创建第x个组，添加多个组件-----
        box_start_import = QGroupBox()
        layout_start_import = QHBoxLayout()


        #设置“开始翻译”的按钮
        self.primaryButton_start_import = PrimaryPushButton('开始注入译文', self, FluentIcon.UPDATE)
        self.primaryButton_start_import.clicked.connect(self.Start_import) #按钮绑定槽函数


        layout_start_import.addStretch(1)  # 添加伸缩项
        layout_start_import.addWidget(self.primaryButton_start_import)
        layout_start_import.addStretch(1)  # 添加伸缩项
        box_start_import.setLayout(layout_start_import)



        # 最外层的垂直布局
        container = QVBoxLayout()

        # 把内容添加到容器中
        container.addStretch(1)  # 添加伸缩项
        container.addWidget(box_input)
        container.addWidget(box_data)
        container.addWidget(box_translation_folder)
        container.addWidget(box_output_folder)
        container.addWidget(box_title_watermark1)
        container.addWidget(box_auto_wrap)
        container.addWidget(box_start_import)
        container.addStretch(1)  # 添加伸缩项

        # 设置窗口显示的内容是最外层容器
        self.setLayout(container)
        container.setSpacing(28) # 设置布局内控件的间距为28
        container.setContentsMargins(50, 70, 50, 30) # 设置布局的边距, 也就是外边框距离，分别为左、上、右、下


    # 选择输入文件夹按钮绑定函数
    def Select_game_folder(self):
        label_input_path = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if label_input_path:
            self.label_input_path.setText(label_input_path)
            print('[INFO] 已选择原游戏文件夹: ',label_input_path)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作

    # 选择工程文件夹按钮绑定函数
    def Select_data_folder(self):
        Data_Folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if Data_Folder:
            self.label_data_path.setText(Data_Folder)
            print('[INFO] 已选择工程数据文件夹: ',Data_Folder)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作

    # 选择译文文件夹按钮绑定函数
    def Select_translation_folder(self):
        translation_folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if translation_folder:
            self.label_translation_folder.setText(translation_folder)
            print('[INFO] 已选择译文文件夹:' ,translation_folder)
        else :
            print('[INFO] 未选择文件夹')
            return  # 直接返回，不执行后续操作

    # 选择存储文件夹按钮绑定函数
    def Select_save_folder(self):
        save_folder = QFileDialog.getExistingDirectory(None, 'Select Directory', '')      #调用QFileDialog类里的函数来选择文件目录
        if save_folder:
            self.label_output_folder.setText(save_folder)
            print('[INFO] 已选择注入后存储文件夹:' ,save_folder)
        else :
            print('[INFO] 未选择文件夹')


    # 导入按钮绑定函数
    def Start_import(self):
        print('[INFO] 开始注入译文到游戏文件中,请耐心等待！！！')

        #读取配置文件
        config_path = os.path.join(".", "StevExtraction", "config.yaml") 

        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)

        #修改配置信息
        config['game_path'] = self.label_input_path.text()
        config['save_path'] = self.label_data_path.text()
        config['translation_path'] = self.label_translation_folder.text()
        config['output_path'] = self.label_output_folder.text()

        if self.checkBox_title_watermark.isChecked():
            config['mark'] = self.LineEdit_title_watermark.text()
        else:
            config['mark'] = 0

        if self.checkBox_auto_wrap.isChecked():
            config['line_length'] = self.spinBox_auto_wrap.value()
        else:
            config['line_length'] = 0

        #导入文本
        pj=self.jtpp.Jr_Tpp(config,config['save_path'])
        pj.ToGame(config['game_path'],config['translation_path'],config['output_path'],config['mark'])


================================================
FILE: UserInterface/NameExtractor/NameExtractor.py
================================================
import json
import re
from pathlib import Path


class NameExtractor:
    def __init__(self):
        # 初始化代码
        pass


    def extract_names_from_trans(self,file_path: Path) -> set:
        """
        从 .trans 文件（实际为JSON）中提取人名。
        """
        names = set()

        content = file_path.read_text(encoding="utf-8")
        trans_content = json.loads(content)

        if not isinstance(trans_content, dict) or "project" not in trans_content:
            return names
            
        project_data = trans_content.get("project", {})
        files_data = project_data.get("files", {})

        if not isinstance(files_data, dict):
            return names

        # 遍历每个文件类别（例如："data/Actors.json"）
        for file_category, category_data in files_data.items():
            if not isinstance(category_data, dict):
                continue # 跳过无效的类别数据

            parameters = category_data.get("parameters", [])  # 如果缺失，默认为空列表

            # 检查 parameters 是否是列表
            if not isinstance(parameters, list):
                continue

            # 遍历 parameters 列表中的每个元素
            for param_item in parameters:
                # 检查元素是否为列表 (根据示例，目标信息在内层列表中)
                if isinstance(param_item, list):
                    # 遍历内层列表中的每个字典
                    for sub_item in param_item:
                            # 检查内层元素是否为字典并包含 rowInfoText
                        if isinstance(sub_item, dict):
                            row_info_text = sub_item.get("rowInfoText", "")
                            if isinstance(row_info_text, str) and row_info_text.strip():
                                names.add(row_info_text.strip())

        return names

    def extract_names_from_rpy(self,file_path: Path) -> set:
        """
        从 .rpy 文件中提取 Character 定义中的人名。
        """
        names = set()
        # 正则表达式匹配 'define variable = Character("Name", ...)' 结构
        # 考虑了可能存在的空格和可选参数
        pattern = re.compile(r'^\s*define\s+\w+\s*=\s*Character\s*\(\s*"([^"]+)"')

        with file_path.open("r", encoding="utf-8-sig") as f: # 小心行头标识
            for line in f:
                match = pattern.match(line)
                if match:
                    name = match.group(1).strip()
                    if name: # 确保提取到的名字不是空字符串
                        names.add(name)
        return names

    def _find_names_recursively(self, data, names, key_name):
        """
        递归地在嵌套的数据结构（字典和列表）中查找键为 "key_name" 且值为字符串的条目。
        并将找到的非空字符串添加到 names 集合中。

        Args:
            data: 当前要搜索的数据片段（可以是任何类型）。
            names: 用于存储找到的名称的集合（原地修改）。
        """
        if isinstance(data, dict):
            # 如果是字典，遍历键值对
            for key, value in data.items():
                # 检查键是否为 "key_name" 且值是否为字符串
                if key == key_name and isinstance(value, str):
                    stripped_name = value.strip()
                    if stripped_name:  # 确保添加的不是空字符串
                        names.add(stripped_name)
                # 对值进行递归调用，以处理嵌套结构
                NameExtractor._find_names_recursively(self,value, names, key_name)
        elif isinstance(data, list):
            # 如果是列表，遍历列表中的每个元素
            for item in data:
                # 对列表中的每个元素进行递归调用
                NameExtractor._find_names_recursively(self,item, names, key_name)
        # 其他类型（如字符串、数字、布尔值、None）则忽略，因为它们不能包含 "key_name" 键

    def extract_names_from_json(self, file_path: Path):
        """
        从 .json 文件中提取名称。

        - 首先尝试识别是否为 VNText (顶层列表元素含 "message") 或 RPG (顶层列表元素含 "id" 和 "traits") 结构。
        - 如果是 VNText 或 RPG 类型，则按照特定规则从顶层列表元素中提取名称。
        - 如果不是可识别的 VNText 或 RPG 结构，则递归查找整个 JSON 数据中所有键为 "name"
          且值为非空字符串的条目。
        """
        names = set()


        content = file_path.read_text(encoding="utf-8")
        data = json.loads(content)

        # --- 类型检测逻辑 ---
        is_vntext = False
        is_rpg = False
        type_detection_possible = isinstance(data, list) and data # 只有顶层是列表且非空时才进行vnt/rpg检测

        if type_detection_possible:
            first_valid_dict_element = None
            for element in data:
                if isinstance(element, dict): # 查找第一个字典元素用于类型判断
                    first_valid_dict_element = element
                    break

            if first_valid_dict_element:
                if "message" in first_valid_dict_element:
                    is_vntext = True
                elif "id" in first_valid_dict_element and "traits" in first_valid_dict_element:
                    is_rpg = True
        # --- 类型检测结束 ---

        # --- 提取逻辑 ---
        if is_vntext or is_rpg:
            # --- 保留原有的 VNT/RPG 处理逻辑 ---
            # 这种情况下，我们只关心顶层列表中的字典
            for item in data: # 此时已知 data 是列表
                if not isinstance(item, dict):
                    continue

                if is_vntext:
                    # 提取 VNText 的 name 和 names
                    name = item.get("name")
                    if isinstance(name, str):
                        stripped_name = name.strip()
                        if stripped_name:
                            names.add(stripped_name)

                    names_list = item.get("names")
                    if isinstance(names_list, list):
                        for n in names_list:
                            if isinstance(n, str):
                                stripped_n = n.strip()
                                if stripped_n:
                                    names.add(stripped_n)
                elif is_rpg: # is_rpg is True
                    # 提取 RPG 的 name
                    name = item.get("name")
                    if isinstance(name, str):
                       stripped_name = name.strip()
                       if stripped_name:
                           names.add(stripped_name)
            # --- VNT/RPG 处理结束 ---

        else:
            # 如果不是可识别的 VNT/RPG 类型 (或者顶层不是列表)，则对整个数据结构进行递归搜索
            NameExtractor._find_names_recursively(self,data, names,"display_name")
            pass

        return names




    def deduplicate_names(self,names_set: set) -> set:
        """
        对提取到的人名进行去重，并处理 '人名+数字' vs '人名' 的情况。
        规则：如果同时存在 "Name1" 和 "Name"，则只保留 "Name"。
        """
        final_names = set()
        # 用于快速查找基础名称（无数字后缀）是否存在
        base_names_present = set()

        # 先找出所有不带数字后缀的名字
        for name in names_set:
            match = re.match(r'^(.*?)(\d+)$', name)
            if not match: # 如果名字不以数字结尾
                final_names.add(name)
                base_names_present.add(name) # 记录这个基础名称

        # 再处理带数字后缀的名字
        for name in names_set:
            match = re.match(r'^(.*?)(\d+)$', name)
            if match: # 如果名字以数字结尾
                base_name = match.group(1)
                # 只有当其基础名称（去掉数字后缀的部分）不在集合中时，才添加带后缀的名字
                if base_name not in base_names_present:
                    final_names.add(name) # 添加原始带后缀的名字，例如 "Player1"

        return final_names


    def extract_names_from_folder(self,folder_path_str: str) -> list:
        """
        遍历指定文件夹及其子文件夹，提取所有支持文件类型中的人名信息。

        Args:
            folder_path_str: 文件夹的路径字符串。

        Returns:
            一个列表，每个元素是一个字典，格式为 {"src": name, "dst": "", "info": ""}。
        """
        folder_path = Path(folder_path_str)

        all_names = set()

        # 遍历文件夹中所有文件
        for item in folder_path.rglob('*'): # 递归遍历所有子目录
            if item.is_file():
                file_path = item
                file_extension = file_path.suffix.lower()
                extracted_set = set()

                # 处理单个文件
                try:
                    if file_extension == '.trans':
                        extracted_set = NameExtractor.extract_names_from_trans(self, file_path)

                    elif file_extension == '.rpy':
                        extracted_set = NameExtractor.extract_names_from_rpy(self, file_path)

                    elif file_extension == '.json':
                        extracted_set = NameExtractor.extract_names_from_json(self, file_path)

                    # 将提取到的人名更新进人名集合
                    if extracted_set:
                        all_names.update(extracted_set)

                except json.JSONDecodeError as json_err:
                    # 对无效的 JSON 文件给出更具体的警告
                    print(f"Warning: Skipping invalid JSON file '{file_path}': {json_err}")
                except Exception as e:
                    # 捕获处理单个文件时可能出现的其他错误
                    print(f"Warning: Error processing file '{file_path}': {e}")

        # 进行特殊去重
        deduplicated_names = NameExtractor.deduplicate_names(self, all_names)

        # 格式化输出
        output_list = [
            {"src": name, "dst": "", "info": ""}
            for name in sorted(list(deduplicated_names)) # 按字母排序以获得一致的输出
        ]

        return output_list


================================================
FILE: UserInterface/Platform/APIEditPage.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import PlainTextEdit
from qfluentwidgets import MessageBoxBase
from qfluentwidgets import SingleDirectionScrollArea

from Base.Base import Base
from Widget.GroupCard import GroupCard
from Widget.ComboBoxCard import ComboBoxCard
from Widget.LineEditCard import LineEditCard
from Widget.SwitchButtonCard import SwitchButtonCard
from Widget.EditableComboBoxCard import EditableComboBoxCard

class APIEditPage(MessageBoxBase, Base):

    def __init__(self, window, key):
        super().__init__(window)

        # 初始化
        self.key = key

        # 设置框体
        self.widget.setFixedSize(960, 720)
        self.yesButton.setText(self.tra("关闭"))
        self.cancelButton.hide()

        # 载入配置文件
        config = self.load_config()

        # 设置主布局
        self.viewLayout.setContentsMargins(0, 0, 0, 0)

        # 设置滚动器
        self.scroller = SingleDirectionScrollArea(self, orient = Qt.Vertical)
        self.scroller.setWidgetResizable(True)
        self.scroller.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        self.viewLayout.addWidget(self.scroller)

        # 设置滚动控件
        self.vbox_parent = QWidget(self)
        self.vbox_parent.setStyleSheet("QWidget { background: transparent; }")
        self.vbox = QVBoxLayout(self.vbox_parent)
        self.vbox.setSpacing(8)
        self.vbox.setContentsMargins(24, 24, 24, 24) # 左、上、右、下
        self.scroller.setWidget(self.vbox_parent)

        # 接口地址
        if "api_url" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_url(self.vbox, config)

        # 接口地址自动补全
        if "auto_complete" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_auto_complete(self.vbox, config)

        # 接口密钥
        if "api_key" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_key(self.vbox, config)

        # 接口区域
        if "region" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_region(self.vbox, config)

        # 接口密钥
        if "access_key" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_access_key(self.vbox, config)

        # 接口密钥
        if "secret_key" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_secret_key(self.vbox, config)

        # 接口格式
        if "api_format" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_format(self.vbox, config)

        # 模型名称
        if "model" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_model(self.vbox, config)

        # 填充
        self.vbox.addStretch(1)

    # 接口地址
    def add_widget_url(self, parent, config):
        def init(widget):
            widget.set_text(config.get("platforms").get(self.key).get("api_url"))
            widget.set_fixed_width(256)
            info_cont = self.tra("请输入接口地址") + " ..."
            widget.set_placeholder_text(info_cont)

        def text_changed(widget, text: str):
            config = self.load_config()
            config["platforms"][self.key]["api_url"] = text.strip()
            self.save_config(config)

        parent.addWidget(
            LineEditCard(
                self.tra("接口地址"),
                self.tra("请输入接口地址，例如 https://api.deepseek.com"),
                init = init,
                text_changed = text_changed,
            )
        )

    # 接口地址自动补全
    def add_widget_auto_complete(self, parent, config):
        def init(widget):
            widget.set_checked(config.get("platforms").get(self.key).get("auto_complete"))

        def checked_changed(widget, checked: bool):
            config = self.load_config()
            config["platforms"][self.key]["auto_complete"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("接口地址自动补全"),
                self.tra("将自动为你填写接口地址，例如 https://api.deepseek.com -> https://api.deepseek.com/v1"),
                init = init,
                checked_changed = checked_changed,
            )
        )

    # 接口密钥
    def add_widget_key(self, parent, config):

        def text_changed(widget):
            config = self.load_config()
            config["platforms"][self.key]["api_key"] = widget.toPlainText().strip()
            self.save_config(config)

        def init(widget):
            plain_text_edit = PlainTextEdit(self)
            plain_text_edit.setPlainText(config.get("platforms").get(self.key).get("api_key"))
            plain_text_edit.setPlaceholderText(self.tra("请输入接口密钥"))
            plain_text_edit.textChanged.connect(lambda: text_changed(plain_text_edit))
            widget.addWidget(plain_text_edit)

        parent.addWidget(
            GroupCard(
                self.tra("接口密钥"),
                self.tra("请输入接口密钥，例如 sk-d0daba12345678fd8eb7b8d31c123456，多个密钥之间请使用半角逗号（,）分隔"),
                init = init,
            )
        )


     # 接口密钥
    def add_widget_access_key(self, parent, config):

        def text_changed(widget):
            config = self.load_config()
            config["platforms"][self.key]["access_key"] = widget.toPlainText().strip()
            self.save_config(config)

        def init(widget):
            plain_text_edit = PlainTextEdit(self)
            plain_text_edit.setPlainText(config.get("platforms").get(self.key).get("access_key"))
            plain_text_edit.setPlaceholderText(self.tra("请输入AWS Access Key"))
            plain_text_edit.textChanged.connect(lambda: text_changed(plain_text_edit))
            widget.addWidget(plain_text_edit)

        parent.addWidget(
            GroupCard(
                self.tra("AWS Access Key"),
                self.tra("请输入AWS Access Key"),
                init = init,
            )
        )

     # 接口密钥
    def add_widget_secret_key(self, parent, config):

        def text_changed(widget):
            config = self.load_config()
            config["platforms"][self.key]["secret_key"] = widget.toPlainText().strip()
            self.save_config(config)

        def init(widget):
            plain_text_edit = PlainTextEdit(self)
            plain_text_edit.setPlainText(config.get("platforms").get(self.key).get("secret_key"))
            plain_text_edit.setPlaceholderText(self.tra("请输入AWS Secret Key"))
            plain_text_edit.textChanged.connect(lambda: text_changed(plain_text_edit))
            widget.addWidget(plain_text_edit)

        parent.addWidget(
            GroupCard(
                self.tra("AWS Secret Key"),
                self.tra("请输入AWS Secret Key"),
                init = init,
            )
        )

    # 接口区域
    def add_widget_region(self, parent, config):

        def init(widget):
            platforms = config.get("platforms").get(self.key)

            # 如果默认区域列表中不存在该条目，则添加
            items = platforms.get("region_datas")
            if platforms.get("region") != "" and platforms.get("region") not in platforms.get("region_datas"):
                items.append(platforms.get("region"))

            widget.set_items(items)
            widget.set_fixed_width(256)
            widget.set_current_index(max(0, widget.find_text(platforms.get("region"))))
            widget.set_placeholder_text(self.tra("请输入区域"))

        def current_text_changed(widget, text: str):
            config = self.load_config()
            config["platforms"][self.key]["region"] = text.strip()
            self.save_config(config)

        def items_changed(widget, items: list[str]): # 处理 items_changed 信号的槽函数
            config = self.load_config()
            config["platforms"][self.key]["region_datas"] = items # 更新 region_datas
            self.save_config(config) # 保存配置

        card = EditableComboBoxCard(
            self.tra("区域(可编辑)"),
            self.tra("请选择或者输入要使用的区域"),
            [],
            init = init,
            current_text_changed = current_text_changed,
        )
        card.items_changed.connect(lambda items: items_changed(card, items)) # 连接信号
        parent.addWidget(card)


    # 接口格式
    def add_widget_format(self, parent, config):
        def init(widget):
            platform = config.get("platforms").get(self.key)

            widget.set_items(platform.get("format_datas"))
            widget.set_current_index(max(0, widget.find_text(platform.get("api_format"))))

        def current_text_changed(widget, text: str):
            config = self.load_config()
            config["platforms"][self.key]["api_format"] = text.strip()
            self.save_config(config)

        parent.addWidget(
            ComboBoxCard(
                self.tra("接口格式"),
                self.tra("请选择接口格式，大部分模型使用 OpenAI 格式，部分中转站的 Claude 模型则使用 Anthropic 格式"),
                [],
                init = init,
                current_text_changed = current_text_changed,
            )
        )


    # 模型名称
    def add_widget_model(self, parent, config):
        def init(widget):
            platforms = config.get("platforms").get(self.key)

            # 如果默认模型列表中不存在该条目，则添加
            items = platforms.get("model_datas")
            if platforms.get("model") != "" and platforms.get("model") not in platforms.get("model_datas"):
                items.append(platforms.get("model"))

            widget.set_items(items)
            widget.set_fixed_width(256)
            widget.set_current_index(max(0, widget.find_text(platforms.get("model"))))
            widget.set_placeholder_text(self.tra("请输入模型名称"))

        def current_text_changed(widget, text: str):
            config = self.load_config()
            config["platforms"][self.key]["model"] = text.strip()
            self.save_config(config)

        def items_changed(widget, items: list[str]): # 处理 items_changed 信号的槽函数
            config = self.load_config()
            config["platforms"][self.key]["model_datas"] = items # 更新 model_datas
            self.save_config(config) # 保存配置

        card = EditableComboBoxCard(
            self.tra("模型名称(可编辑)"),
            self.tra("请选择或者输入要使用的模型的名称"),
            [],
            init = init,
            current_text_changed = current_text_changed,
        )
        self.model_card = card
        card.items_changed.connect(lambda items: items_changed(card, items)) # 连接信号
        # 新增：从接口获取模型
        card.fetch_models_requested.connect(lambda: self._open_model_fetch_dialog())
        parent.addWidget(card)

    # 打开获取模型页面
    def _open_model_fetch_dialog(self):
        from UserInterface.Platform.ModelBrowserDialog import ModelBrowserDialog
        # self.debug(f"open_model_fetch_dialog: opening for platform={self.key}")

        # 读取当前平台配置，传入对话框用于请求
        config = self.load_config()
        platform = config.get("platforms").get(self.key)
        dialog = ModelBrowserDialog(self.window(), self.key, platform)

        def _on_models_confirmed(selected_models: list[str]):
            # self.debug(f"model_fetch_confirmed: {selected_models}")
            if not selected_models:
                self.warning_toast("", self.tra("未选择任何模型"))
                return
            # 将选择的模型加入到 model_datas 中（去重，并优先放前面）
            config = self.load_config()
            platforms = config.get("platforms")
            model_datas = platforms[self.key].get("model_datas", [])
            for m in selected_models:
                if m not in model_datas:
                    model_datas.append(m)
            platforms[self.key]["model_datas"] = model_datas
            # 如果只选择了一个，则设置为当前模型
            if len(selected_models) == 1:
                platforms[self.key]["model"] = selected_models[0]
            # 保存配置
            self.save_config(config)
            # self.debug(f"model_datas after save: {platforms[self.key].get('model_datas')}")
            self.debug(f"current model after save: {platforms[self.key].get('model')}")

            # 刷新右侧下拉框的选项与当前选中项
            try:
                items = platforms[self.key].get("model_datas", [])
                self.model_card.set_items(items)
                current_model = platforms[self.key].get("model", "")
                if current_model:
                    self.model_card.set_current_index(max(0, self.model_card.find_text(current_model)))
            except Exception as e:
                self.debug(f"refresh combobox failed: {e}")

            # 简单提示
            self.success_toast("", self.tra("已添加所选模型"))

        # 同时支持信号回调和 exec_ 返回，避免任何时序丢失
        try:
            dialog.selectedConfirmed.connect(_on_models_confirmed)
        except Exception:
            pass

        if dialog.exec_():
            # 再次兜底读取
            _on_models_confirmed(dialog.get_selected_models())



================================================
FILE: UserInterface/Platform/ArgsEditPage.py
================================================
import os
import json

from PyQt5.QtCore import Qt
from PyQt5.QtCore import QUrl
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import HyperlinkLabel, PlainTextEdit
from qfluentwidgets import MessageBoxBase
from qfluentwidgets import SingleDirectionScrollArea

from Base.Base import Base
from Widget.SliderCard import SliderCard
from Widget.GroupCard import GroupCard
from Widget.SwitchButtonCard import SwitchButtonCard
from Widget.ComboBoxCard import ComboBoxCard

class ArgsEditPage(MessageBoxBase, Base):

    def __init__(self, window, key):
        super().__init__(window)

        # 初始化
        self.key = key

        # 设置框体
        self.widget.setFixedSize(960, 720)
        self.yesButton.setText(self.tra("关闭"))
        self.cancelButton.hide()

        # 载入配置文件
        config = self.load_config()
        preset = self.load_file("./Resource/platforms/preset.json")

        # 设置主布局
        self.viewLayout.setContentsMargins(0, 0, 0, 0)

        # 设置滚动器
        self.scroller = SingleDirectionScrollArea(self, orient = Qt.Vertical)
        self.scroller.setWidgetResizable(True)
        self.scroller.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        self.viewLayout.addWidget(self.scroller)

        # 设置滚动控件
        self.vbox_parent = QWidget(self)
        self.vbox_parent.setStyleSheet("QWidget { background: transparent; }")
        self.vbox = QVBoxLayout(self.vbox_parent)
        self.vbox.setSpacing(8)
        self.vbox.setContentsMargins(24, 24, 24, 24) # 左、上、右、下
        self.scroller.setWidget(self.vbox_parent)


        # extra_body
        if "extra_body" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_extra_body(self.vbox, config)

        # top_p
        if "top_p" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_top_p(self.vbox, config, preset)

        # temperature
        if "temperature" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_temperature(self.vbox, config, preset)

        # presence_penalty
        if "presence_penalty" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_presence_penalty(self.vbox, config, preset)

        # frequency_penalty
        if "frequency_penalty" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_frequency_penalty(self.vbox, config, preset)

        # think_switch
        if "think_switch" in config.get("platforms").get(self.key).get("key_in_settings"):
            self.add_widget_think_switch(self.vbox, config)

        # 获取接口格式以进行条件渲染
        settings = config.get("platforms").get(self.key).get("key_in_settings")
        api_format = config.get("platforms").get(self.key).get("api_format")

        # think_depth - 仅在格式为 OpenAI 或 Anthropic 时显示
        if "think_depth" in settings and api_format in ["OpenAI", "Anthropic"]:
            self.add_widget_think_depth(self.vbox, config)

        # thinking_budget - 仅在格式为 Google 时显示
        if "thinking_budget" in settings and api_format == "Google":
            self.add_widget_thinking_budget(self.vbox, config, preset)

        # 填充
        self.vbox.addStretch(1)

    # 从文件加载
    def load_file(self, path: str) -> dict:
        result = {}

        if os.path.exists(path):
            with open(path, "r", encoding = "utf-8") as reader:
                result = json.load(reader)
        else:
            self.error(f"未找到 {path} 文件 ...")

        return result


    # 思考开关
    def add_widget_think_switch(self, parent, config):
        def init(widget):
            widget.set_checked(config.get("platforms").get(self.key).get("think_switch"))

        def checked_changed(widget, checked: bool):
            config = self.load_config()
            config["platforms"][self.key]["think_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("think_switch"),
                self.tra("思考模式开关"),
                init = init,
                checked_changed = checked_changed,
            )
        )

    # 思考深度
    def add_widget_think_depth(self, parent, config):
        def init(widget):
            platform = config.get("platforms").get(self.key)

            widget.set_items(["low","medium","high"])
            widget.set_current_index(max(0, widget.find_text(platform.get("think_depth"))))

        def current_text_changed(widget, text: str):
            config = self.load_config()
            config["platforms"][self.key]["think_depth"] = text.strip()
            self.save_config(config)

        parent.addWidget(
            ComboBoxCard(
                self.tra("think_depth"),
                self.tra("思考深度"),
                [],
                init = init,
                current_text_changed = current_text_changed,
            )
        )

    # 思维预算
    def add_widget_thinking_budget(self, parent, config, preset):
        def init(widget):
            widget.set_range(-1, 32768)
            value = config.get("platforms").get(self.key).get("thinking_budget", -1)
            widget.set_text(str(value))
            widget.set_value(value)

        def value_changed(widget, value):
            widget.set_text(str(value))
            config = self.load_config()
            config["platforms"][self.key]["thinking_budget"] = value
            self.save_config(config)

        if self.key in preset.get("platforms"):
            default_value = preset.get("platforms").get(self.key).get("thinking_budget")
        else:
            default_value = -1

        info_cont = self.tra("请谨慎设置，对于目标接口，此参数的默认值为") + f" {default_value} (-1代表自动)"
        parent.addWidget(
            SliderCard(
                "thinking_budget",
                info_cont,
                init = init,
                value_changed = value_changed,
            )
        )

    # 自定义Body
    def add_widget_extra_body(self, parent, config):

        def text_changed(widget):
            try:
                config = self.load_config()

                extra_body_str = widget.toPlainText().strip()
                if not extra_body_str:
                    config["platforms"][self.key]["extra_body"] = {}
                else:
                    extra_body_dict = json.loads(extra_body_str.replace("'", "\""))
                    if extra_body_dict is None:
                        extra_body_dict = {}
                        
                    config["platforms"][self.key]["extra_body"] = extra_body_dict

                self.save_config(config)
            except Exception as e:
                # 建议添加错误提示，方便调试
                print(f"[INFO] 接口保存 extra_body 参数失败: {e}")

        def init(widget):
            plain_text_edit = PlainTextEdit(self)

            extra_body = config.get("platforms").get(self.key).get("extra_body")
            
            # 只有当 extra_body 是非空字典时才显示内容
            if isinstance(extra_body, dict) and extra_body:
                plain_text_edit.setPlainText(json.dumps(extra_body, ensure_ascii=False, indent=2))
            else:
                plain_text_edit.setPlainText("")

            info_cont = self.tra("请输入自定义Body")
            plain_text_edit.setPlaceholderText(info_cont)
            plain_text_edit.textChanged.connect(lambda: text_changed(plain_text_edit))
            widget.addWidget(plain_text_edit)

        parent.addWidget(
            GroupCard(
                "extra_body",
                self.tra("请输入自定义Body，例如 {\"provider\": {\"order\": [\"DeepInfra\", \"Together\"], \"allow_fallbacks\": false}}"),
                init = init,
            )
        )

    # top_p
    def add_widget_top_p(self, parent, config, preset):
        def init(widget):
            widget.set_range(0, 100)
            widget.set_text(f"{config.get("platforms").get(self.key).get("top_p"):.2f}")
            widget.set_value(int(config.get("platforms").get(self.key).get("top_p") * 100))

        def value_changed(widget, value):
            widget.set_text(f"{(value / 100):.2f}")

            config = self.load_config()
            config["platforms"][self.key]["top_p"] = value / 100
            self.save_config(config)

        if self.key in preset.get("platforms"):
            default_value = preset.get("platforms").get(self.key).get("top_p")
        else:
            default_value = preset.get("platforms").get("openai").get("top_p")

        info_cont = self.tra("请谨慎设置，对于目标接口，此参数的默认值为") + f" {default_value}"
        parent.addWidget(
            SliderCard(
                "top_p",
                info_cont,
                init = init,
                value_changed = value_changed,
            )
        )

    # temperature
    def add_widget_temperature(self, parent, config, preset):
        def init(widget):
            widget.set_range(0, 200)
            widget.set_text(f"{config.get("platforms").get(self.key).get("temperature"):.2f}")
            widget.set_value(int(config.get("platforms").get(self.key).get("temperature") * 100))

        def value_changed(widget, value):
            widget.set_text(f"{(value / 100):.2f}")

            config = self.load_config()
            config["platforms"][self.key]["temperature"] = value / 100
            self.save_config(config)

        if self.key in preset.get("platforms"):
            default_value = preset.get("platforms").get(self.key).get("temperature")
        else:
            default_value = preset.get("platforms").get("openai").get("temperature")

        info_cont = self.tra("请谨慎设置，对于目标接口，此参数的默认值为") + f" {default_value}"
        parent.addWidget(
            SliderCard(
                "temperature",
                info_cont,
                init = init,
                value_changed = value_changed,
            )
        )

    # presence_penalty
    def add_widget_presence_penalty(self, parent, config, preset):
        def init(widget):
            widget.set_range(-200, 200)
            widget.set_text(f"{config.get("platforms").get(self.key).get("presence_penalty"):.2f}")
            widget.set_value(int(config.get("platforms").get(self.key).get("presence_penalty") * 100))

        def value_changed(widget, value):
            widget.set_text(f"{(value / 100):.2f}")

            config = self.load_config()
            config["platforms"][self.key]["presence_penalty"] = value / 100
            self.save_config(config)

        if self.key in preset.get("platforms"):
            default_value = preset.get("platforms").get(self.key).get("presence_penalty")
        else:
            default_value = preset.get("platforms").get("openai").get("presence_penalty")

        info_cont = self.tra("请谨慎设置，对于目标接口，此参数的默认值为") + f" {default_value}"
        parent.addWidget(
            SliderCard(
                "presence_penalty",
                info_cont,
                init = init,
                value_changed = value_changed,
            )
        )

    # frequency_penalty
    def add_widget_frequency_penalty(self, parent, config, preset):
        def init(widget):
            widget.set_range(-200, 200)
            widget.set_text(f"{config.get("platforms").get(self.key).get("frequency_penalty"):.2f}")
            widget.set_value(int(config.get("platforms").get(self.key).get("frequency_penalty") * 100))

        def value_changed(widget, value):
            widget.set_text(f"{(value / 100):.2f}")

            config = self.load_config()
            config["platforms"][self.key]["frequency_penalty"] = value / 100
            self.save_config(config)

        if self.key in preset.get("platforms"):
            default_value = preset.get("platforms").get(self.key).get("frequency_penalty")
        else:
            default_value = preset.get("platforms").get("openai").get("frequency_penalty")

        info_cont = self.tra("请谨慎设置，对于目标接口，此参数的默认值为") + f" {default_value}"
        parent.addWidget(
            SliderCard(
                "frequency_penalty",
                info_cont,
                init = init,
                value_changed = value_changed,
            )
        )



================================================
FILE: UserInterface/Platform/LimitEditPage.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import MessageBoxBase
from qfluentwidgets import SingleDirectionScrollArea

from Base.Base import Base
from Widget.SpinCard import SpinCard

class LimitEditPage(MessageBoxBase, Base):

    def __init__(self, window, key):
        super().__init__(window)

        # 初始化
        self.key = key

        # 设置框体
        self.widget.setFixedSize(960, 720)
        self.yesButton.setText(self.tra("关闭"))
        self.cancelButton.hide()

        # 载入配置文件
        config = self.load_config()

        # 设置主布局
        self.viewLayout.setContentsMargins(0, 0, 0, 0)

        # 设置滚动器
        self.scroller = SingleDirectionScrollArea(self, orient = Qt.Vertical)
        self.scroller.setWidgetResizable(True)
        self.scroller.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        self.viewLayout.addWidget(self.scroller)

        # 设置滚动控件
        self.vbox_parent = QWidget(self)
        self.vbox_parent.setStyleSheet("QWidget { background: transparent; }")
        self.vbox = QVBoxLayout(self.vbox_parent)
        self.vbox.setSpacing(8)
        self.vbox.setContentsMargins(24, 24, 24, 24) # 左、上、右、下
        self.scroller.setWidget(self.vbox_parent)

        # 添加控件
        self.add_widget_rpm(self.vbox, config)
        self.add_widget_tpm(self.vbox, config)

        # 填充
        self.vbox.addStretch(1)

    # 每分钟请求数
    def add_widget_rpm(self, parent, config):
        def init(widget):
            widget.set_range(0, 9999999)
            widget.set_value(config.get("platforms").get(self.key).get("rpm_limit", 4096))

        def value_changed(widget, value: str):
            config = self.load_config()
            config["platforms"][self.key]["rpm_limit"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("每分钟请求数"),
                self.tra("RPM，即每个密钥在一分钟内能响应的请求的最大数量"),
                init = init,
                value_changed = value_changed,
            )
        )

    # 每分钟 Token 数
    def add_widget_tpm(self, parent, config):
        def init(widget):
            widget.set_range(0, 9999999)
            widget.set_value(config.get("platforms").get(self.key).get("tpm_limit", 4096000))

        def value_changed(widget, value: str):
            config = self.load_config()
            config["platforms"][self.key]["tpm_limit"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("每分钟 Token 数"),
                self.tra("TPM，即每个密钥在一分钟内能生成的 Token 的最大数量"),
                init = init,
                value_changed = value_changed,
            )
        )



================================================
FILE: UserInterface/Platform/ModelBrowserDialog.py
================================================
from typing import List
import re

from PyQt5.QtCore import Qt, QThread, QObject, pyqtSignal, QTimer
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLabel, QGridLayout

import httpx

from qfluentwidgets import (
    MessageBoxBase, LineEdit, PushButton, StrongBodyLabel, FluentIcon,
    PillPushButton, SingleDirectionScrollArea, isDarkTheme, IndeterminateProgressRing,
)

from Base.Base import Base
from ModuleFolders.LLMRequester.LLMClientFactory import LLMClientFactory

class _GoogleModelFetchWorker(QObject):
    """用于从 google-genai 获取模型的工作线程"""
    finished = pyqtSignal(list)
    failed = pyqtSignal(str)

    def __init__(self, platform_config: dict):
        super().__init__()
        self.platform_config = platform_config
        self._aborted = False

    def cancel(self):
        self._aborted = True

    def run(self):
        if self._aborted:
            return
        try:
            # 使用 LLMClientFactory 获取 Google 客户端
            client = LLMClientFactory().get_google_client(self.platform_config)

            # 获取所有可用模型
            all_models_iterator = client.models.list()

            if self._aborted:
                return

            filtered_models = []
            exclude_keywords = ["native-audio", "image", "tts", "live"]

            # 遍历并按要求过滤模型
            for model in all_models_iterator:
                model_name = model.name

                # 保留 gemini 和 gemma 模型
                if 'gemini' in model_name or 'gemma' in model_name:
                    # 排除特定类型的模型
                    if not any(keyword in model_name for keyword in exclude_keywords):
                        short_name = model_name.split('/')[-1]
                        filtered_models.append(short_name)

            if not self._aborted:
                self.finished.emit(filtered_models)

        except Exception as e:
            if not self._aborted:
                self.failed.emit(str(e))
            return

class _ModelFetchWorker(QObject):
    finished = pyqtSignal(list)
    failed = pyqtSignal(str)

    def __init__(self, url: str, headers: dict):
        super().__init__()
        self.url = url
        self.headers = headers
        self._aborted = False

    def cancel(self):
        self._aborted = True

    def run(self):
        if self._aborted:
            return
        try:
            with httpx.Client(http2=True, timeout=10.0) as client:
                resp = client.get(self.url, headers=self.headers, timeout=10.0)
                resp.raise_for_status()
                data = resp.json()
        except Exception as e:
            if not self._aborted:
                self.failed.emit(str(e))
            return

        if self._aborted:
            return

        models = []
        try:
            if isinstance(data, dict) and isinstance(data.get("data"), list):
                for item in data.get("data", []):
                    mid = item.get("id") or item.get("model")
                    if mid:
                        models.append(str(mid))
            elif isinstance(data, list):
                for item in data:
                    if isinstance(item, str):
                        models.append(item)
                    elif isinstance(item, dict):
                        mid = item.get("id") or item.get("model")
                        if mid:
                            models.append(str(mid))
        except Exception:
            pass

        if not self._aborted:
            self.finished.emit(models)



class ModelBrowserDialog(MessageBoxBase, Base):
    """
    统一的“获取模型”对话框：
    - 支持从 OpenAI 兼容接口 GET /v1/models 拉取全部模型
    - 支持从 google-genai 原生接口拉取模型
    - 本地分页与搜索（适配几百条模型的展示）
    - 单/多选：按住 Ctrl/Shift 可多选；双击单条将立即确认
    """
    # 确认时把最终选择通过信号抛出，避免外部读取竞态
    selectedConfirmed = pyqtSignal(list)

    def __init__(self, window, platform_key: str, platform_config: dict):
        super().__init__(parent=window)
        self.platform_key = platform_key
        self.platform_config = platform_config

        # UI 基本设置

        # 关闭/销毁保护标志
        self._closing = False

        self.widget.setMinimumSize(720, 520)
        self.yesButton.setText(self.tra("确定"))
        self.cancelButton.setText(self.tra("取消"))
        self.yesButton.setEnabled(False)

        # 数据
        self._all_models: List[str] = []
        self._filtered: List[str] = []
        self._page_size = 50
        self._current_page = 1

        # 构建界面
        self._build_ui()

        # 轻度样式优化
        self.setStyleSheet("""
        QListWidget { background: transparent; border: 1px solid rgba(255,255,255,0.08); }
        QListWidget::item { padding: 6px 10px; }
        QListWidget::item:selected { background: rgba(98, 160, 234, 0.18); border: none; }
        QLabel { color: palette(window-text); }
        """)

        # 异步/同步拉取数据（这里用同步 httpx，数据量一般可接受）
        # 容器背景使用主题色；按钮与主题色形成明暗对比，文本固定为 #f1356d
        theme_hex = None
        # 根据主题构造对比用的明暗色（覆盖在主题背景上）
        if isDarkTheme():
            theme_hex = "#2b2b2b"
            btn_bg = "#dddddd"
            btn_border = "rgba(255,255,255,0.28)"
            btn_hover = "rgba(255,255,255,0.22)"
            btn_checked = "rgba(255,255,255,0.30)"
        else:
            theme_hex = "#ffffff"
            btn_bg = "rgba(0,0,0,0.06)"
            btn_border = "rgba(0,0,0,0.18)"
            btn_hover = "rgba(0,0,0,0.10)"
            btn_checked = "rgba(0,0,0,0.16)"



        # 设置模型区域背景为主题色
        # 放在 grid_parent 上，使视觉上“模型展示区域”整体统一
        # 注意：为了有留白，外层布局已有边距
        self.grid_parent.setStyleSheet(f"QWidget {{ background-color: {theme_hex}; border-radius: 8px; }}")

        text_color = "#202020"  # 固定按钮文本色

        # 胶囊按钮样式
        self._capsule_style = (
            "QPushButton {"
            " border-radius: 18px; padding: 8px 14px;"
            f" border: 1px solid {btn_border};"
            f" background-color: {btn_bg};"
            f" color: {text_color};"
            "}"
            "QPushButton:hover {"
            f" background-color: {btn_hover};"
            "}"
            "QPushButton:checked {"
            f" background-color: {btn_checked};"
            f" border: 1px solid {btn_border};"
            f" color: {text_color};"
            "}"
        )

        self._begin_loading_state()
        self._fetch_models()

        # 连接确认按钮，点击时调用 accept（保证加的信号和快照逻辑生效）
        try:
            self.yesButton.clicked.disconnect()
        except Exception:
            pass
        self.yesButton.clicked.connect(self.accept)

    # 公开方法：获取选择的模型
    def get_selected_models(self) -> List[str]:
        # 若已在 accept() 阶段确认，则返回确认时的快照，避免并发导致的空值
        if hasattr(self, "_confirmed_models"):
            return list(self._confirmed_models)
        return list(self._selected)

    # UI
    def _build_ui(self) -> None:
        self.viewLayout.setContentsMargins(16, 16, 16, 16)

        # 标题
        title = StrongBodyLabel(self.tra("获取模型"), self)
        self.viewLayout.addWidget(title)

        # 搜索条
        top_bar = QHBoxLayout()
        self.search_box = LineEdit(self)
        self.search_box.setPlaceholderText(self.tra("搜索模型..."))
        self.search_box.textChanged.connect(self._on_search_changed)
        top_bar.addWidget(self.search_box, 1)

        # 分页控制
        self.prev_btn = PushButton(self.tra("上一页"), self)
        self.prev_btn.setIcon(FluentIcon.LEFT_ARROW)
        self.prev_btn.clicked.connect(lambda: self._goto_page(self._current_page - 1))
        self.next_btn = PushButton(self.tra("下一页"), self)
        self.next_btn.setIcon(FluentIcon.RIGHT_ARROW)
        self.next_btn.clicked.connect(lambda: self._goto_page(self._current_page + 1))
        self.page_label = QLabel("1/1", self)
        self.page_label.setAlignment(Qt.AlignCenter)

        top_bar.addWidget(self.prev_btn)
        top_bar.addWidget(self.page_label)
        top_bar.addWidget(self.next_btn)
        self.viewLayout.addLayout(top_bar)

        # 模型栅格（滚动区 + Grid）
        self.scroll_area = SingleDirectionScrollArea(self, orient=Qt.Vertical)
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setStyleSheet("QScrollArea { border: none; background: transparent; }")

        self.grid_parent = QWidget(self)
        self.grid_layout = QGridLayout(self.grid_parent)
        self.grid_layout.setContentsMargins(8, 8, 18, 8)  # 右侧适当留白，避免贴太近滚动条
        self.grid_layout.setHorizontalSpacing(16)
        self.grid_layout.setVerticalSpacing(12)
        self.scroll_area.setWidget(self.grid_parent)
        self.viewLayout.addWidget(self.scroll_area)

        # 选择集合（跨页保留）
        self._selected = set()

    # 拉取模型（异步）
    def _fetch_models(self) -> None:
        # 判断平台类型
        if self.platform_key == "google":
            self._thread = QThread(self)
            self._worker = _GoogleModelFetchWorker(self.platform_config)
            self._worker.moveToThread(self._thread)
            self._thread.started.connect(self._worker.run)
            self._worker.finished.connect(self._on_fetch_finished)
            self._worker.failed.connect(self._on_fetch_failed)
            self._worker.finished.connect(self._thread.quit)
            self._worker.finished.connect(self._worker.deleteLater)
            self._thread.finished.connect(self._thread.deleteLater)
            self._thread.start()
        else:
            # OpenAI 兼容接口
            base_url = self.platform_config.get("api_url", "").rstrip("/")
            auto_complete = self.platform_config.get("auto_complete", False)

            # 自动补全规则（参考 TranslatorConfig）
            if self.platform_key == "sakura" and not base_url.endswith("/v1"):
                base_url = base_url + "/v1"
            elif auto_complete and not re.search(r"/v[1-9]$", base_url):
                base_url = base_url + "/v1"

            url = f"{base_url}/models"

            # 处理鉴权
            headers = {}
            api_keys = self.platform_config.get("api_key", "").replace(" ", "")
            if api_keys:
                headers["Authorization"] = f"Bearer {api_keys.split(',')[0]}"

            # 启动后台线程
            self._thread = QThread(self)
            self._worker = _ModelFetchWorker(url, headers)
            self._worker.moveToThread(self._thread)
            self._thread.started.connect(self._worker.run)
            self._worker.finished.connect(self._on_fetch_finished)
            self._worker.failed.connect(self._on_fetch_failed)
            # 线程结束后清理
            self._worker.finished.connect(self._thread.quit)
            self._worker.finished.connect(self._worker.deleteLater)
            self._thread.finished.connect(self._thread.deleteLater)
            self._thread.start()

    # 覆写关闭/拒绝，确保停止后台线程并安全清理
    def reject(self) -> None:
        # 先隐藏，减少重绘竞争
        try:
            self.hide()
        except Exception:
            self.debug("hide failed")
        # 如果线程还在跑，发起取消并等待其结束
        try:
            if hasattr(self, "_worker") and self._worker:
                self._worker.cancel()
            if hasattr(self, "_thread") and self._thread and self._thread.isRunning():
                self._thread.quit()
                self._thread.wait(2000)
        except Exception:
            pass
        super().reject()

    def accept(self) -> None:
        # 确认前先打上关闭标志并停止后台线程，避免竞态重绘
        self._closing = True
        # 在任何隐藏/清理动作前，先拍一份快照并发信号，保证上层拿得到
        try:
            self._confirmed_models = list(self._selected)
            self.selectedConfirmed.emit(self._confirmed_models)
        except Exception:
            pass
        try:
            self.hide()
        except Exception:
            self.debug("hide failed")
        try:
            if hasattr(self, "_worker") and self._worker:
                self._worker.cancel()
            if hasattr(self, "_thread") and self._thread and self._thread.isRunning():
                self._thread.quit()
                self._thread.wait(2000)
        except Exception:
            pass
        # 延迟调用父类 accept，确保本轮绘制结束（用 lambda + 显式 super 调用）
        QTimer.singleShot(0, lambda: super(ModelBrowserDialog, self).accept())
        return

    def closeEvent(self, event):
        try:
            if hasattr(self, "_worker") and self._worker:
                self._worker.cancel()
            if hasattr(self, "_thread") and self._thread and self._thread.isRunning():
                self._thread.quit()
                self._thread.wait(2000)
        except Exception:
            pass
        return super().closeEvent(event)



    def _on_fetch_failed(self, err: str):
        # 异步延迟清理 + 提示，避免与关闭/销毁竞争
        QTimer.singleShot(0, self._end_loading_state)
        QTimer.singleShot(0, lambda: self._show_placeholder(self.tra("获取失败")))
        QTimer.singleShot(0, lambda: self.error_toast(self.tra("获取模型"), self.tra("获取模型失败")))
        self.debug(f"fetch models error: {err}")

    def _on_fetch_finished(self, models: list):
        unique = sorted(list(dict.fromkeys(models)))
        self._all_models = unique
        # 异步延迟刷新，避免与关闭/销毁竞争
        QTimer.singleShot(0, self._apply_filter_and_refresh)
        QTimer.singleShot(0, self._end_loading_state)
        if unique:
            QTimer.singleShot(0, lambda: self.success_toast(self.tra("获取模型"), self.tra("获取成功")))
        else:
            QTimer.singleShot(0, lambda: self.warning_toast(self.tra("获取模型"), self.tra("没有返回任何模型")))

    # 事件
    def _on_search_changed(self, text: str) -> None:
        self._apply_filter_and_refresh()

    def _on_selection_change(self) -> None:
        # grid 方案改为使用内部集合控制按钮状态
        self.yesButton.setEnabled(len(self._selected) > 0)
    # 占位/加载提示
    def _clear_grid(self):
        while self.grid_layout.count():
            item = self.grid_layout.takeAt(0)
            w = item.widget()
            if w:
                w.deleteLater()

    def _show_placeholder(self, text: str):
        self._clear_grid()
        if not hasattr(self, "_placeholder_label"):
            self._placeholder_label = QLabel(self)
            self._placeholder_label.setAlignment(Qt.AlignCenter)
            self._placeholder_label.setStyleSheet("QLabel { color: palette(window-text); font-size: 14px; }")
        self._placeholder_label.setText(text)
        # 跨两列水平居中
        self.grid_layout.addWidget(self._placeholder_label, 0, 0, 1, 2, alignment=Qt.AlignCenter)

    def _begin_loading_state(self):
        self.search_box.setEnabled(False)
        self.prev_btn.setEnabled(False)
        self.next_btn.setEnabled(False)
        self.page_label.setText("...")
        # 居中显示圆形进度环 + 文本
        self._clear_grid()
        self._loading_container = QWidget(self)
        lay = QVBoxLayout(self._loading_container)
        lay.setContentsMargins(0, 24, 0, 24)
        lay.setSpacing(8)
        ring = IndeterminateProgressRing(self._loading_container)
        ring.setFixedSize(40, 40)
        txt = StrongBodyLabel(self.tra("正在获取模型..."), self._loading_container)
        txt.setAlignment(Qt.AlignCenter)
        # txt.setStyleSheet("QLabel { color: palette(window-text); }")
        lay.addWidget(ring, 0, Qt.AlignCenter)
        lay.addWidget(txt, 0, Qt.AlignCenter)
        self.grid_layout.addWidget(self._loading_container, 0, 0, 1, 2, alignment=Qt.AlignCenter)

    def _end_loading_state(self):
        self.search_box.setEnabled(True)
        if hasattr(self, "_loading_container") and self._loading_container:
            self._loading_container.deleteLater()
            self._loading_container = None
        # 翻页按钮的可用状态由 _refresh_list 里计算


    def _accept_if_single_clicked(self) -> None:
        # grid 方案：如果只有一个选择，仍然允许回车确认
        if len(self._selected) == 1:
            self.accept()

    # 数据刷新
    def _toggle_selection(self, name: str, checked: bool) -> None:
        if checked:
            self._selected.add(name)
        else:
            self._selected.discard(name)
        self._on_selection_change()

    def _apply_filter_and_refresh(self) -> None:
        q = self.search_box.text().strip().lower()
        if q:
            self._filtered = [m for m in self._all_models if q in m.lower()]
        else:
            self._filtered = list(self._all_models)
        self._current_page = 1
        self._refresh_list()

    def _goto_page(self, page: int) -> None:
        total_pages = max(1, (len(self._filtered) + self._page_size - 1) // self._page_size)
        page = max(1, min(page, total_pages))
        if page != self._current_page:
            self._current_page = page
            self._refresh_list()

    def _refresh_list(self) -> None:
        total = len(self._filtered)
        total_pages = max(1, (total + self._page_size - 1) // self._page_size)
        start = (self._current_page - 1) * self._page_size
        end = min(start + self._page_size, total)
        self.page_label.setText(f"{self._current_page}/{total_pages}")
        self.prev_btn.setEnabled(self._current_page > 1)
        self.next_btn.setEnabled(self._current_page < total_pages)

        # 清空旧的按钮
        while self.grid_layout.count():
            item = self.grid_layout.takeAt(0)
            w = item.widget()
            if w:
                w.deleteLater()

        # 两列胶囊按钮布局
        cols = 2
        row = 0
        col = 0
        for m in self._filtered[start:end]:
            btn = PillPushButton(m, self.grid_parent)
            btn.setCheckable(True)
            btn.setChecked(m in self._selected)
            btn.setStyleSheet(self._capsule_style)
            btn.setMinimumWidth(240)
            btn.setMinimumHeight(36)
            btn.toggled.connect(lambda checked, name=m: self._toggle_selection(name, checked))
            self.grid_layout.addWidget(btn, row, col)
            col += 1
            if col >= cols:
                col = 0
                row += 1


================================================
FILE: UserInterface/Platform/PlatformPage.py
================================================
import os
import json
import copy
import random
from functools import partial

from PyQt5.QtCore import QUrl, pyqtSignal, Qt, QMimeData
from PyQt5.QtGui import QDesktopServices, QIcon, QDrag
from PyQt5.QtWidgets import QFrame, QVBoxLayout, QHBoxLayout

from qfluentwidgets import Action, CaptionLabel, DropDownPushButton, HorizontalSeparator, PrimaryPushButton, InfoBar, InfoBarPosition, StrongBodyLabel
from qfluentwidgets import RoundMenu
from qfluentwidgets import FluentIcon
from qfluentwidgets import PushButton

from Base.Base import Base
from Widget.APITypeCard import APITypeCard
from Widget.InterfaceDropZoneWidget import InterfaceDropZoneWidget
from Widget.LineEditMessageBox import LineEditMessageBox
from UserInterface.Platform.APIEditPage import APIEditPage
from UserInterface.Platform.ArgsEditPage import ArgsEditPage
from UserInterface.Platform.LimitEditPage import LimitEditPage


# 可拖动的接口按钮类,继承 DropDownPushButton，添加拖放功能
class DraggableAPIButton(DropDownPushButton):
    def __init__(self, *args, api_tag: str = "", **kwargs):
        super().__init__(*args, **kwargs)
        
        self.api_tag = api_tag  # 存储接口的唯一标识

    # 鼠标左键按下事件
    def mouseMoveEvent(self, e):
        if e.buttons() != Qt.LeftButton:
            return

        # 创建一个 QDrag 对象
        drag = QDrag(self)
        
        # 创建 QMimeData 来存储拖动的数据
        mime_data = QMimeData()

        # 使用自定义的MIME类型来识别拖放操作
        mime_data.setData("application/x-api-tag", self.api_tag.encode('utf-8')) # 将 api_tag 编码后存入
        mime_data.setText(self.text()) # 同时可以存一个文本，用于显示
        drag.setMimeData(mime_data)
        
        # 设置拖动时显示的小图标
        pixmap = self.grab()
        drag.setPixmap(pixmap)
        drag.setHotSpot(e.pos() - self.rect().topLeft())

        # 开始拖动
        drag.exec_(Qt.MoveAction)


# 拖放按钮的目标区域类
class APISettingDropArea(QFrame, Base):

    apiDropped = pyqtSignal(str, str) # 信号，当有接口被拖放进来时发射

    def __init__(self, setting_key: str, text: str, parent=None):
        super().__init__(parent)
        self.setting_key = setting_key
        self.setAcceptDrops(True)  # 允许此小部件接收拖放
        self.setObjectName('api-setting-drop-area')
        self.setFrameShape(QFrame.StyledPanel)
        self.setFrameShadow(QFrame.Sunken)
        self.setMinimumHeight(60)

        # 设置样式
        self.setStyleSheet("""
            #api-setting-drop-area {
                border: 2px dashed #a0a0a0;
                border-radius: 8px;
                background-color: transparent;
            }
        """)

        # 内部布局
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(15, 10, 15, 10)
        
        self.title_label = StrongBodyLabel(text)
        
        self.api_name_label = CaptionLabel(self.tra("拖动一个接口到这里"))
        self.api_name_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        
        self.layout.addWidget(self.title_label)
        self.layout.addStretch(1)
        self.layout.addWidget(self.api_name_label)
        
        self.current_api_tag = None

    def dragEnterEvent(self, event):
        # 检查拖动的数据类型
        if event.mimeData().hasFormat("application/x-api-tag"):
            event.acceptProposedAction()
            self.setStyleSheet("""
                #api-setting-drop-area {
                    border: 2px solid #1E90FF;
                    background-color: transparent;
                    border-radius: 8px;
                }
            """)
        else:
            event.ignore()

    def dragLeaveEvent(self, event):
        # 恢复原始样式
        self.setStyleSheet("""
            #api-setting-drop-area {
                border: 2px dashed #a0a0a0;
                border-radius: 8px;
                background-color: transparent;
            }
        """)

    def dropEvent(self, event):
        # 当拖放发生时，获取数据
        api_tag = event.mimeData().data("application/x-api-tag").data().decode('utf-8')
        
        # 发射信号，通知主窗口
        self.apiDropped.emit(self.setting_key, api_tag)
        event.acceptProposedAction()
        self.dragLeaveEvent(None) # 恢复样式

    # 更新显示，并保存当前选择的接口tag
    def update_display(self, api_name: str, api_tag: str):
        if api_name and api_tag:
            self.api_name_label.setText(api_name)
            self.current_api_tag = api_tag
        else:
            self.api_name_label.setText(self.tra("拖动一个接口到这里"))
            self.current_api_tag = None


class PlatformPage(QFrame, Base):

    # 自定义平台默认配置
    CUSTOM = {
        "tag": "",
        "group": "custom",
        "name": "",
        "api_url": "https://api.lingyiwanwu.com/v1",
        "api_key": "",
        "api_format": "OpenAI",
        "rpm_limit": 4096,
        "tpm_limit": 8000000,
        "model": "gpt-4o",
        "top_p": 1.0,
        "temperature": 1.0,
        "presence_penalty": 0.0,
        "frequency_penalty": 0.0,
        "think_switch": False,
        "think_depth": "low",
        "auto_complete": True,

        "model_datas": [
            "gpt-4o",
            "gpt-4o-mini",
            "gpt-4-turbo",
            "claude-3-5-haiku",
            "claude-3-5-sonnet",
        ],
        "format_datas": [
            "OpenAI",
            "Anthropic",
            "Google"
        ],
        "extra_body": {},
        "key_in_settings": [
            "api_url",
            "api_key",
            "api_format",
            "rpm_limit",
            "tpm_limit",
            "model",
            "auto_complete",
            "top_p",
            "temperature",
            "presence_penalty",
            "frequency_penalty",
            "extra_body",
            "think_switch",
            "think_depth",
            "thinking_budget"
        ],
    }

    def __init__(self, text: str, window):
            super().__init__(window)
            self.setObjectName(text.replace(" ", "-"))

            # 默认配置
            self.default = {
                "api_settings":{
                            "translate": None,
                            "polish": None
                            }
            }

            self.window = window # 全局变量
            self.load_preset() # 读取合并配置

            self.container = QVBoxLayout(self)
            self.container.setSpacing(15) # 增加间距以容纳新卡片
            self.container.setContentsMargins(24, 24, 24, 24)

            # 读取合并配置
            config = self.save_config(self.load_config_from_default())

            # 布局组件
            self.add_head_widget(self.container, config)
            self.add_body_widget(self.container, config)
            self.add_foot_widget(self.container, config)
            
            self.container.addStretch(1) 

            # 添加分割线
            self.container.addWidget(HorizontalSeparator())
            
            self.add_interface_settings_widget(self.container, config)

            self.container.addStretch(1) 
            
            self.subscribe(Base.EVENT.API_TEST_DONE, self.api_test_done)

    # 从文件加载
    def load_file(self, path: str) -> dict:
        result = {}

        if os.path.exists(path):
            with open(path, "r", encoding = "utf-8") as reader:
                result = json.load(reader)
        else:
            self.error(f"未找到 {path} 文件 ...")

        return result

    # 执行接口测试
    def api_test(self, tag: str):
        # 载入配置文件
        config = self.load_config()
        platform = config.get("platforms").get(tag)
        if Base.work_status == Base.STATUS.IDLE:
            # 更新运行状态
            Base.work_status = Base.STATUS.API_TEST

            # 创建事件参数
            data = copy.deepcopy(platform)

            # 触发事件
            self.emit(Base.EVENT.API_TEST_START, data)
        else:
            self.warning_toast("", self.tra("接口测试正在执行中，请稍后再试"))

    # 接口测试完成
    def api_test_done(self, event: int, data: dict):
        # 更新运行状态
        Base.work_status = Base.STATUS.IDLE

        if len(data.get("failure", [])) > 0:
            info_cont = self.tra("接口测试结果：成功") + f"   {len(data.get("success", []))}"+ "......" + self.tra("失败") + f"{   len(data.get("failure", []))}" + "......"
            self.error_toast("", info_cont)
        else:
            info_cont = self.tra("接口测试结果：成功") + f"   {len(data.get("success", []))}"+ "......" + self.tra("失败") + f"{   len(data.get("failure", []))}" + "......"
            self.success_toast("", info_cont)

    # 加载并更新预设配置
    def load_preset(self):
        # 这个函数的主要目的是保证可以通过预设文件对内置的接口的固定属性进行更新
        preset = self.load_file("./Resource/platforms/preset.json")
        config = self.load_config()

        # 从配置文件中非自定义读取接口信息数据并使用预设数据更新
        p_platforms = preset.get("platforms", {})
        c_platforms = config.get("platforms", {})
        # 遍历预设数据中的接口信息
        for k, p_platform in p_platforms.items():
            # 在配置数据中查找相同的接口
            if k in c_platforms:
                c_platform = c_platforms.get(k, {})
                # 如果该字段属于用户自定义字段，且配置数据中该字段的值合法，则使用此值更新预设数据
                for setting in p_platform.get("key_in_settings", []):
                    if c_platform.get(setting, None) != None:
                        p_platform[setting] = c_platform.get(setting, None)

        # 从配置文件中读取自定义接口信息数据并使用预设数据更新
        custom = {k: v for k, v in config.get("platforms", {}).items() if v.get("group") == "custom"}
        # 遍历自定义模型数据
        for _, platform in custom.items():
            for k, v in self.CUSTOM.items():
                # 如果该字段的值不合法，则使用预设数据更新该字段的值
                if platform.get(k, None) == None:
                    platform[k] = v

                # 如果字段不属于用户自定义字段，且不在保护字段范围内，则使用预设数据更新该字段的值！！！
                if k not in self.CUSTOM.get("key_in_settings", []) and k not in ("tag", "name", "group","model_datas","extra_body"):
                    platform[k] = v

        # 汇总数据并更新配置数据中的接口信息
        platforms = {}
        platforms.update(preset.get("platforms", {}))
        platforms.update(custom)
        config["platforms"] = platforms

        # 保存并返回
        return self.save_config(config)

    # 删除平台
    def delete_platform(self, tag: str) -> None:
        # 载入配置文件
        config = self.load_config()

        # 删除对应的平台
        del config["platforms"][tag]

        # 保存配置文件
        self.save_config(config)

        # 更新所有控件
        self.update_custom_platform_widgets(self.flow_card)

    # 重命名平台
    def rename_platform(self, tag: str) -> None:
        # 定义对话框关闭时的回调函数
        def message_box_close(widget, new_name: str):
            if not new_name.strip():
                self.warning_toast("", self.tra("接口名称不能为空"))
                return

            config = self.load_config()

            # 检查平台是否存在
            if tag not in config["platforms"]:
                self.error_toast("", self.tra("接口不存在"))
                return

            # 更新平台名称
            config["platforms"][tag]["name"] = new_name.strip()

            # 保存配置文件
            self.save_config(config)

            # 更新所有控件
            self.update_custom_platform_widgets(self.flow_card)

            self.success_toast("", self.tra("接口重命名成功"))

        # 载入配置文件
        config = self.load_config()

        # 检查平台是否存在
        if tag not in config["platforms"]:
            self.error_toast("", self.tra("接口不存在"))
            return

        
        current_name = config["platforms"][tag].get("name", "")

        
        message_box = LineEditMessageBox(
            self.window,
            self.tra("请输入新的接口名称"),
            message_box_close=message_box_close,
            default_text=current_name # 设置默认文本为当前名称
        )

        message_box.exec()

    # 生成 UI 描述数据
    def generate_ui_datas(self, platforms: dict, is_custom: bool) -> list:
        ui_datas = []

        for k, v in platforms.items():
            # k 就是 tag，我们需要把它传递下去
            base_data = {
                "tag": k,  
                "name": v.get("name"),
                "icon": v.get("icon"),
            }
            if not is_custom:
                base_data["menus"] = [
                    (FluentIcon.EDIT, self.tra("编辑接口"), partial(self.show_api_edit_page, k)),
                    (FluentIcon.SCROLL, self.tra("编辑限速"), partial(self.show_limit_edit_page, k)),
                    (FluentIcon.DEVELOPER_TOOLS, self.tra("编辑参数"), partial(self.show_args_edit_page, k)),
                    (FluentIcon.SEND, self.tra("测试接口"), partial(self.api_test, k)),
                ]
            else:
                base_data["menus"] = [
                    (FluentIcon.EDIT, self.tra("编辑接口"), partial(self.show_api_edit_page, k)),
                    (FluentIcon.LABEL, self.tra("更名接口"), partial(self.rename_platform, k)),
                    (FluentIcon.SCROLL, self.tra("编辑限速"), partial(self.show_limit_edit_page, k)),
                    (FluentIcon.DEVELOPER_TOOLS, self.tra("编辑参数"), partial(self.show_args_edit_page, k)),
                    (FluentIcon.DELETE, self.tra("删除接口"), partial(self.delete_platform, k)),
                    (FluentIcon.SEND, self.tra("测试接口"), partial(self.api_test, k)),
                ]
            ui_datas.append(base_data)
        return ui_datas
    

    # 显示编辑接口对话框
    def show_api_edit_page(self, key: str):
        APIEditPage(self.window, key).exec()

    # 显示编辑参数对话框
    def show_args_edit_page(self, key: str):
        ArgsEditPage(self.window, key).exec()

    # 显示编辑限额对话框
    def show_limit_edit_page(self, key: str):
        LimitEditPage(self.window, key).exec()

    # 初始化按钮的方法
    def init_drop_down_push_button(self, widget, datas):
        for item in datas:
            # 使用新的可拖动按钮类
            drop_down_push_button = DraggableAPIButton(
                item.get("name"), 
                api_tag=item.get("tag") # 传递 api_tag
            )

            if item.get("icon"):
                icon_name = item.get("icon") + '.png'
                icon_path = os.path.join(".", "Resource", "platforms", "Icon", icon_name)                                                  
                drop_down_push_button.setIcon(QIcon(icon_path))

            drop_down_push_button.setFixedWidth(192)
            drop_down_push_button.setContentsMargins(4, 0, 4, 0)

            widget.add_widget(drop_down_push_button)

            menu = RoundMenu(item.get("name"))
            for k, v in enumerate(item.get("menus")):
                menu.addAction(Action(v[0], v[1], triggered=v[2]))
                if k != len(item.get("menus")) - 1:
                    menu.addSeparator()
            drop_down_push_button.setMenu(menu)

    # 更新自定义平台控件
    def update_custom_platform_widgets(self, widget):
        config = self.load_config()
        platforms = {k:v for k, v in config.get("platforms").items() if v.get("group") == "custom"}

        widget.take_all_widgets()
        self.init_drop_down_push_button(
            widget,
            self.generate_ui_datas(platforms, True)
        )

    # 添加头部-本地接口
    def add_head_widget(self, parent, config):
        def init(widget):
            # 添加按钮
            help_button = PushButton(self.tra("教程"))
            help_button.setIcon(FluentIcon.HELP)
            help_button.setContentsMargins(4, 0, 4, 0)
            help_button.clicked.connect(lambda: QDesktopServices.openUrl(QUrl("https://github.com/SakuraLLM/SakuraLLM/wiki")))
            widget.add_widget_to_head(help_button)

            # 更新子控件
            self.init_drop_down_push_button(
                widget,
                self.generate_ui_datas(platforms, False),
            )

        # 本地接口分类的接口数据 
        platforms = {k:v for k, v in config.get("platforms").items() if v.get("group") == "local"}
        parent.addWidget(
            APITypeCard(
                self.tra("本地接口"),
                self.tra("管理应用内置的本地大语言模型的接口"),
                icon = FluentIcon.CONNECT,
                init = init,
            )
        )

    # 添加主体-在线接口
    def add_body_widget(self, parent, config):

        platforms = {k:v for k, v in config.get("platforms").items() if v.get("group") == "online"}
        parent.addWidget(
            APITypeCard(
                self.tra("官方接口"),
                self.tra("管理应用内置的主流大语言模型的官方接口"),
                icon = FluentIcon.ROBOT,
                init = lambda widget: self.init_drop_down_push_button(
                    widget,
                    self.generate_ui_datas(platforms, False),
                ),
            )
        )

    # 添加底部-自定义接口
    def add_foot_widget(self, parent, config):

        def message_box_close(widget, text: str):
            config = self.load_config()

            # 生成一个随机 TAG
            tag = f"custom_platform_{random.randint(100000, 999999)}"

            # 修改和保存配置
            platform = copy.deepcopy(self.CUSTOM)
            platform["tag"] = tag
            platform["name"] = text.strip()
            config["platforms"][tag] = platform
            self.save_config(config)

            # 更新ui
            self.update_custom_platform_widgets(self.flow_card)

        def on_add_button_clicked(widget):
            message_box = LineEditMessageBox(
                self.window,
                self.tra("请输入新的接口名称"),
                message_box_close = message_box_close
            )

            message_box.exec()

        def init(widget):
            # 添加新增按钮
            add_button = PrimaryPushButton(self.tra("新增"))
            add_button.setIcon(FluentIcon.ADD_TO)
            add_button.setContentsMargins(4, 0, 4, 0)
            add_button.clicked.connect(lambda: on_add_button_clicked(self))
            widget.add_widget_to_head(add_button)

            # 更新ui
            self.update_custom_platform_widgets(widget)

        self.flow_card = APITypeCard(
            self.tra("自定义接口"),
            self.tra("在此添加和管理任何符合 OpenAI 格式或者 Anthropic 格式的大语言模型的接口"),
            icon = FluentIcon.ASTERISK,
            init = init,
        )
        parent.addWidget(self.flow_card)


    def add_interface_settings_widget(self, parent, config):
        self.drop_areas = {} # 用于存储所有拖放区域的引用


        # 创建新的布局组件实例
        self.interface_drop_zone = InterfaceDropZoneWidget(
            self.tra("设置不同任务所使用的接口"),
            self
        )
        
        # 创建并添加拖放区域到新组件中
        settings_map = {
            "translate": self.tra("翻译接口"),
            "polish": self.tra("润色接口"),
        }
        
        # 从配置中加载已保存的设置
        saved_settings = config.get("api_settings", {})
        all_platforms = config.get("platforms", {})
        
        for key, name in settings_map.items():
            drop_area = APISettingDropArea(key, name, self)
            # 连接信号到槽函数
            drop_area.apiDropped.connect(self.handle_api_drop)
            
            # 使用新组件的方法添加拖放区
            self.interface_drop_zone.add_drop_area(drop_area)
            self.drop_areas[key] = drop_area

            # 初始化显示
            api_tag = saved_settings.get(key)
            if api_tag and api_tag in all_platforms:
                api_name = all_platforms[api_tag].get("name")
                drop_area.update_display(api_name, api_tag)
        
        # 将整个新组件添加到主布局
        parent.addWidget(self.interface_drop_zone)


    # 处理拖放事件的槽函数
    def handle_api_drop(self, setting_key: str, api_tag: str):
        config = self.load_config()
        
        # 检查接口是否存在
        if api_tag not in config["platforms"]:
            print(f"接口 '{api_tag}' 不存在!")
            return

        # 更新配置
        if "api_settings" not in config:
            config["api_settings"] = {}
        config["api_settings"][setting_key] = api_tag
        self.save_config(config)

        # 更新UI显示
        api_name = config["platforms"][api_tag].get("name")
        if setting_key in self.drop_areas:
            self.drop_areas[setting_key].update_display(api_name, api_tag)
        
        setting_name = self.drop_areas[setting_key].title_label.text()
        InfoBar.success(
            title=self.tra("设置成功"),
            content=f"  {api_name}",
            duration=3000,
            parent=self.window,
            position=InfoBarPosition.TOP
        )


================================================
FILE: UserInterface/PolishingSettings/PolishingBasicSettingsPage.py
================================================
from PyQt5.QtCore import QEvent
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QVBoxLayout
from qfluentwidgets import HorizontalSeparator

from Base.Base import Base
from Widget.SpinCard import SpinCard
from Widget.ComboBoxCard import ComboBoxCard

class PolishingBasicSettingsPage(QFrame, Base):

    def __init__(self, text: str, window) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "polishing_mode_selection": "translated_text_polish",
            "polishing_pre_line_counts": 0,
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24) # 左、上、右、下

        # 添加控件
        self.add_widget_polishing_mode(self.container, config)
        self.container.addWidget(HorizontalSeparator())
        self.add_widget_pre_line(self.container, config)
        # 填充
        self.container.addStretch(1)

    # 页面每次展示时触发
    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.show_event(self, event) if hasattr(self, "show_event") else None

    # 润色模式
    def add_widget_polishing_mode(self, parent, config) -> None:
        # 定义模式配对列表（显示文本, 存储值）
        mode_pairs = [
            (self.tra("原文"), "source_text_polish"),
            (self.tra("译文"), "translated_text_polish")
        ]
        
        # 生成翻译后的配对列表
        translated_pairs = [(self.tra(display), value) for display, value in mode_pairs]

        def init(widget) -> None:
            current_config = self.load_config()
            
            # 根据配置确定当前模式值
            if current_config.get("polishing_mode_selection", "") == "translated_text_polish":
                current_value = "translated_text_polish"
            else:
                current_value = "source_text_polish"
                
            # 通过存储值查找对应的索引
            index = next(
                (i for i, (_, value) in enumerate(translated_pairs) if value == current_value),
                0  # 默认选择第一个选项
            )
            widget.set_current_index(max(0, index))

        def current_text_changed(widget, text: str) -> None:
            # 通过显示文本查找对应的存储值
            value = next(
                (value for display, value in translated_pairs if display == text),
                "translated_text_polish"  # 默认值
            )
            
            config = self.load_config()
            if value == "translated_text_polish":
                config["polishing_mode_selection"] = "translated_text_polish"
            else:
                config["polishing_mode_selection"] = "source_text_polish"
                
            self.save_config(config)

        # 创建选项列表（使用翻译后的显示文本）
        options = [display for display, value in translated_pairs]

        self.mode_combo_box = ComboBoxCard(
            self.tra("润色模式选择"),
            self.tra("选择需要润色的文本范围\n选择【原文】将润色原文文本，原文不需要翻译情况下使用\n选择【译文】将润色译文文本，在原文翻译完成后再使用"),
            options,
            init=init,
            current_text_changed=current_text_changed,
        )
        parent.addWidget(self.mode_combo_box)


    # 参考上文行数
    def add_widget_pre_line(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("polishing_pre_line_counts"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["polishing_pre_line_counts"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("参考上文行数"),
                self.tra("行数不宜设置过大，建议10行以内"),
                init = init,
                value_changed = value_changed,
            )
        )



================================================
FILE: UserInterface/PolishingSettings/PolishingStylePromptPage.py
================================================
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import Action
from qfluentwidgets import FluentIcon
from qfluentwidgets import MessageBox
from qfluentwidgets import PlainTextEdit

from Base.Base import Base
from Widget.CommandBarCard import CommandBarCard
from Widget.SwitchButtonCard import SwitchButtonCard

class PolishingStylePromptPage(QFrame, Base):

    def __init__(self, text: str, window):
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "polishing_style_switch": False,
            "polishing_style_content": (
                "根据原文语境，可以适当调整，使表达更生动形象，提升冲击力与张力"
            ),
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24) # 左、上、右、下

        # 添加控件
        self.add_widget_header(self.container, config)
        self.add_widget_body(self.container, config)
        self.add_widget_footer(self.container, config, window)

    # 头部
    def add_widget_header(self, parent, config):
        def widget_init(widget):
            widget.set_checked(config.get("polishing_style_switch"))

        def widget_callback(widget, checked: bool):
            config = self.load_config()
            config["polishing_style_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自定义润色风格"),
                self.tra("启用此功能后，将根据本页中设置的内容构建润色风格要求，并补充到基础提示词中"),
                widget_init,
                widget_callback,
            )
        )

    # 主体
    def add_widget_body(self, parent, config):
        self.plain_text_edit = PlainTextEdit(self)
        self.plain_text_edit.setPlainText(config.get("polishing_style_content"))
        parent.addWidget(self.plain_text_edit)

    # 底部
    def add_widget_footer(self, parent, config, window):
        self.command_bar_card = CommandBarCard()
        parent.addWidget(self.command_bar_card)

        # 添加命令
        self.add_command_bar_action_01(self.command_bar_card)
        self.add_command_bar_action_02(self.command_bar_card, window)
    # 保存
    def add_command_bar_action_01(self, parent):
        def callback():
            # 读取配置文件
            config = self.load_config()

            # 从表格更新数据
            config["polishing_style_content"] = self.plain_text_edit.toPlainText().strip()

            # 保存配置文件
            config = self.save_config(config)

            # 弹出提示
            info_cont = self.tra("数据已保存") + " ..."
            self.success_toast("", info_cont)

        parent.add_action(
            Action(FluentIcon.SAVE, self.tra("保存"), parent, triggered = callback),
        )

    # 重置
    def add_command_bar_action_02(self, parent, window):
        def callback():
            info_cont1 = self.tra("是否确认重置为默认数据")  + " ... ？"
            message_box = MessageBox("Warning", info_cont1, window)
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))

            if not message_box.exec():
                return

            # 清空控件
            self.plain_text_edit.setPlainText("")

            # 读取配置文件
            config = self.load_config()

            # 加载默认设置
            config["polishing_style_content"] = self.default.get("polishing_style_content")

            # 保存配置文件
            config = self.save_config(config)

            # 向控件更新数据
            self.plain_text_edit.setPlainText(config.get("polishing_style_content"))

            # 弹出提示
            info_cont2 = self.tra("数据已重置")  + " ... "
            self.success_toast("", info_cont2)

        parent.add_action(
            Action(FluentIcon.DELETE,self.tra("重置"), parent, triggered = callback),
        )


================================================
FILE: UserInterface/PolishingSettings/PolishingSystemPromptPage.py
================================================
import uuid
from PyQt5.QtWidgets import ( QWidget, QVBoxLayout, QHBoxLayout, QGridLayout, QFrame)
from PyQt5.QtCore import Qt,  pyqtSignal
from qfluentwidgets import CaptionLabel, CardWidget, FluentWindow, HorizontalSeparator, IconWidget, LineEdit, MessageBoxBase, PrimaryPushButton, PushButton as FluentPushButton, ScrollArea, StrongBodyLabel, TextEdit, FluentIcon


from Base.Base import Base
from ModuleFolders.PromptBuilder.PromptBuilderPolishing import PromptBuilderPolishing
from ModuleFolders.PromptBuilder.PromptBuilderEnum import PromptBuilderEnum

# 提示词卡片
class PromptCard(Base,CardWidget):
    prompt_selected = pyqtSignal(dict) # 信号：提示词卡片被点击
    delete_requested = pyqtSignal(str) # 信号：请求删除提示词
    edit_requested = pyqtSignal(dict) # 信号：请求编辑提示词

    def __init__(self, prompt_data, parent=None):
        super().__init__(parent)
        self.prompt_data = prompt_data
        self.is_system = prompt_data.get("type") == "system"
        self.setObjectName("PromptCard")
        self.init_ui()

    def init_ui(self):
        self.setCursor(Qt.PointingHandCursor)
        self.setMinimumHeight(120)
        self.setMaximumHeight(180)
        self.setMinimumWidth(200)

        main_v_layout = QVBoxLayout(self)
        main_v_layout.setContentsMargins(10, 10, 10, 10)
        main_v_layout.setSpacing(5)

        name_label = StrongBodyLabel(self.prompt_data["name"])
        name_label.setWordWrap(True)

        content_preview = CaptionLabel(self.prompt_data["content"][:130] + "...")
        content_preview.setWordWrap(True)

        main_v_layout.addWidget(name_label)
        main_v_layout.addWidget(content_preview)
        main_v_layout.addStretch(1)

        bottom_h_layout = QHBoxLayout()
        bottom_h_layout.setContentsMargins(0, 0, 0, 0)

        if not self.is_system:
            button_container = QHBoxLayout()
            button_container.addStretch(1)

            edit_button = FluentPushButton(self.tra("编辑"))
            edit_button.clicked.connect(self.on_edit_requested)
            edit_button.setFocusPolicy(Qt.NoFocus)
            button_container.addWidget(edit_button)

            delete_button = FluentPushButton(self.tra("删除"))
            delete_button.clicked.connect(self.on_delete_requested)
            delete_button.setFocusPolicy(Qt.NoFocus)
            button_container.addWidget(delete_button)
            bottom_h_layout.addLayout(button_container)
        else:
            bottom_h_layout.addStretch(1)
            system_tag = CaptionLabel(self.tra("系统预设"))
            bottom_h_layout.addWidget(system_tag, alignment=Qt.AlignRight)

        main_v_layout.addLayout(bottom_h_layout)
        self.setAutoFillBackground(True)

    # 设置默认样式
    def set_default_style(self):
        self.setStyleSheet("")

    # 设置选中样式
    def set_selected_style(self):
        self.setStyleSheet(f"""
            PromptCard#PromptCard {{
                border: 2px solid #0078D4; /* 蓝色边框 */
                background-color: rgba(0, 120, 212, 0.1); /* 半透明背景 */
                border-radius: 8px;
            }}
        """)

    # 响应删除请求
    def on_delete_requested(self):
        self.delete_requested.emit(self.prompt_data["id"])

    # 响应编辑请求
    def on_edit_requested(self):
        self.edit_requested.emit(self.prompt_data)

    # 鼠标点击事件处理
    def mousePressEvent(self, event):
        child_widget = self.childAt(event.pos())
        is_on_button = False
        if child_widget:
            parent = child_widget
            while parent is not None:
                if isinstance(parent, FluentPushButton):
                    is_on_button = True
                    break
                parent = parent.parent()

        if not is_on_button and event.button() == Qt.LeftButton:
            self.prompt_selected.emit(self.prompt_data)

# 提示词编辑对话框
class AddEditPromptDialog(Base,MessageBoxBase):
    def __init__(self, prompt_data=None, parent=None):
        super().__init__(parent)
        self.prompt_data = prompt_data
        self.is_edit_mode = prompt_data is not None
        self.init_ui()

        self.yesButton.setText(self.tra('保存'))
        self.cancelButton.setText(self.tra('取消'))

    def init_ui(self):
        container = QWidget(self)
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 10, 0, 0)
        layout.setSpacing(10)

        # 调整对话框尺寸
        self.widget.setMinimumWidth(900)
        self.widget.setMinimumHeight(600)

        name_label = StrongBodyLabel(self.tra("卡片名称:"), container)
        self.name_edit = LineEdit(container)
        if self.is_edit_mode:
            self.name_edit.setText(self.prompt_data["name"])

        content_label = StrongBodyLabel(self.tra("提示词内容:"), container)
        self.content_edit = TextEdit(container)

        if self.is_edit_mode:
            self.content_edit.setPlainText(self.prompt_data["content"])

        layout.addWidget(name_label)
        layout.addWidget(self.name_edit)
        layout.addWidget(content_label)
        layout.addWidget(self.content_edit)

        self.viewLayout.addWidget(container)

    def get_data(self):
        name = self.name_edit.text().strip()
        content = self.content_edit.toPlainText().strip()
        if not name or not content:
            return None

        if self.is_edit_mode:
            return {"id": self.prompt_data["id"], "name": name, "content": content, "type": "user"}
        else:
            return {"id": str(uuid.uuid4()), "name": name, "content": content, "type": "user"}


# 主界面
class PolishingSystemPromptPage(QFrame, Base):

    def __init__(self, text: str, window: FluentWindow) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "polishing_prompt_selection":{"last_selected_id": PromptBuilderEnum.POLISH_COMMON,"prompt_content": ""},
            "polishing_user_prompt_data": [],
        }

        # 载入并合并配置
        config = self.save_config(self.load_config_from_default())

        # 载入配置文件
        config = self.load_config()

        # 获取用户配置
        self.default_prompt = self.get_default_prompt(config)
        selected_prompt = config.get("polishing_prompt_selection",{})
        self.user_prompts = config.get("polishing_user_prompt_data",[])
        self.all_prompts = self.default_prompt + self.user_prompts
        last_selected_id = selected_prompt.get("last_selected_id","")

        # 组装界面并初步显示
        self.init_ui()
        self.update_prompt_cards()

        # 启动时恢复上次选择
        self.selected_prompt_card = None
        initial_prompt_to_display = None

        # 在所有提示词中查找与保存的ID匹配的项
        if last_selected_id:
            for p in self.all_prompts:
                if p['id'] == last_selected_id:
                    initial_prompt_to_display = p
                    break
        
        # 如果没有找到，则默认显示第一个
        if not initial_prompt_to_display and self.all_prompts:
            initial_prompt_to_display = self.all_prompts[0]
            
        # 如果存在可显示的提示词，则显示它
        if initial_prompt_to_display:
            self.display_prompt_details(initial_prompt_to_display)

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(0, 10, 0, 0) 

        # 设置顶部卡片
        self.top_display_card = CardWidget(self)
        top_card_layout = QVBoxLayout(self.top_display_card)
        top_card_layout.setContentsMargins(20, 15, 20, 15)
        top_card_layout.setSpacing(12)

        # 设置顶部卡片标题
        header_layout = QHBoxLayout()
        header_layout.setSpacing(8)
        
        pin_icon = IconWidget(FluentIcon.PIN, self.top_display_card)
        pin_icon.setFixedSize(18, 18)
        
        title_label = StrongBodyLabel(self.tra("当前提示词"), self.top_display_card)

        header_layout.addWidget(pin_icon)
        header_layout.addWidget(title_label)
        header_layout.addStretch(1)
        top_card_layout.addLayout(header_layout)

        # 添加分割线
        top_card_layout.addWidget(HorizontalSeparator())

        # 设置顶部卡片内容显示
        name_layout = QHBoxLayout()
        name_label_title = StrongBodyLabel(self.tra("名称："), self.top_display_card)
        self.selected_prompt_name_label = StrongBodyLabel("")
        name_layout.addWidget(name_label_title)
        name_layout.addWidget(self.selected_prompt_name_label)
        name_layout.addStretch(1)
        top_card_layout.addLayout(name_layout)
        
        # 设置顶部卡片内容文本框
        self.selected_prompt_content_text = TextEdit()
        self.selected_prompt_content_text.setReadOnly(True)
        self.selected_prompt_content_text.setMinimumHeight(200)
        #self.selected_prompt_content_text.setMaximumHeight(200)

        top_card_layout.addWidget(self.selected_prompt_content_text)
        
        # 将顶部卡片添加到主布局
        main_layout.addWidget(self.top_display_card, 1)

        # 设置底部卡片
        self.bottom_grid_card = CardWidget(self)
        bottom_card_layout = QVBoxLayout(self.bottom_grid_card)
        bottom_card_layout.setContentsMargins(20, 15, 20, 15) # 统一边距风格
        bottom_card_layout.setSpacing(12) # 统一间距风格

        header_layout = QHBoxLayout()
        card_square_label = StrongBodyLabel(self.tra("提示词广场"))
        header_layout.addWidget(card_square_label)
        header_layout.addStretch(1)
        self.add_new_prompt_button =  PrimaryPushButton(FluentIcon.ADD, self.tra("创建新提示词"), self)
        self.add_new_prompt_button.clicked.connect(self.open_add_prompt_dialog)
        header_layout.addWidget(self.add_new_prompt_button)
        bottom_card_layout.addLayout(header_layout)

        self.scroll_area = ScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll_area.setStyleSheet("background-color: transparent; border: none;")

        self.card_container_widget = QWidget()
        self.card_container_widget.setStyleSheet("background-color: transparent;")
        self.card_grid_layout = QGridLayout(self.card_container_widget)
        self.card_grid_layout.setSpacing(15)
        self.card_grid_layout.setAlignment(Qt.AlignTop | Qt.AlignLeft)

        self.scroll_area.setWidget(self.card_container_widget)
        bottom_card_layout.addWidget(self.scroll_area)

        main_layout.addWidget(self.bottom_grid_card, 3)
        self.setLayout(main_layout)

    # 获取系统提示词
    def get_default_prompt(self, config):

        # 获取系统预设提示词内容
        conmon_name = self.tra("通用")
        common_id = PromptBuilderEnum.POLISH_COMMON
        common_prompt_content = PromptBuilderPolishing.get_system_default(config)

        # 组装默认提示词列表
        default_prompt = [
            {
                "id": common_id,
                "name": conmon_name,
                "content": common_prompt_content,
                "type": "system"
            }
        ]

        return default_prompt

    # 保存当前选择
    def save_last_selection(self, prompt_id,prompt_content):

        config = self.load_config()
        config["polishing_prompt_selection"] = {"last_selected_id": prompt_id,"prompt_content": prompt_content}
        self.save_config(config)

    # 保存新的用户提示词
    def save_user_prompts(self):
        config = self.load_config()
        config["polishing_user_prompt_data"] = self.user_prompts
        self.save_config(config)

    # 清楚界面
    def clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
            elif child.layout():
                self.clear_layout(child.layout())

    # 更新提示词广场的卡片
    def update_prompt_cards(self):
        self.clear_layout(self.card_grid_layout)
        self.all_prompts = self.default_prompt + self.user_prompts

        prompts_to_display = self.all_prompts[:]

        num_cols = 3
        row, col = 0, 0
        for i, prompt_data in enumerate(prompts_to_display):
            card = PromptCard(prompt_data)
            card.prompt_selected.connect(self.display_prompt_details)

            if prompt_data.get("type") != "system":
                card.delete_requested.connect(self.delete_user_prompt)
                card.edit_requested.connect(self.handle_edit_request)

            self.card_grid_layout.addWidget(card, row, col)
            col += 1
            if col >= num_cols:
                col = 0
                row += 1

    # 查找指定ID的提示词卡片
    def find_card_widget(self, prompt_id):
        for i in range(self.card_grid_layout.count()):
            item = self.card_grid_layout.itemAt(i)
            if item:
                widget = item.widget()
                if isinstance(widget, PromptCard) and widget.prompt_data["id"] == prompt_id:
                    return widget
        return None
    
    # 高亮显示指定的提示词卡片
    def highlight_card(self, card_to_highlight_widget):
        if self.selected_prompt_card and self.selected_prompt_card != card_to_highlight_widget:
            self.selected_prompt_card.set_default_style()

        if card_to_highlight_widget:
            card_to_highlight_widget.set_selected_style()
            self.selected_prompt_card = card_to_highlight_widget
        else:
            self.selected_prompt_card = None

    # 显示选中的提示词详情
    def display_prompt_details(self, prompt_data):
        self.selected_prompt_name_label.setText(f"{prompt_data['name']}")
        self.selected_prompt_content_text.setPlainText(prompt_data['content'])

        card_widget_to_select = self.find_card_widget(prompt_data["id"])
        self.highlight_card(card_widget_to_select)

        self.save_last_selection(prompt_data['id'],prompt_data['content'])

    # 处理编辑请求
    def handle_edit_request(self, prompt_data_to_edit):
        self.open_add_prompt_dialog(prompt_data_to_edit)

    # 打开添加或编辑提示词对话框
    def open_add_prompt_dialog(self, prompt_to_edit=None):
        actual_prompt_to_edit = prompt_to_edit
        if isinstance(prompt_to_edit, bool) and not prompt_to_edit:
            actual_prompt_to_edit = None

        dialog = AddEditPromptDialog(actual_prompt_to_edit, self)

        if dialog.exec_():
            data = dialog.get_data()
            if data:
                is_new_prompt = not actual_prompt_to_edit

                if not is_new_prompt and actual_prompt_to_edit:
                    for i, p in enumerate(self.user_prompts):
                        if p["id"] == data["id"]:
                            self.user_prompts[i] = data
                            break
                else:
                    self.user_prompts.append(data)

                self.save_user_prompts()
                self.update_prompt_cards()

                newly_added_or_edited_card_instance = self.find_card_widget(data["id"])
                if newly_added_or_edited_card_instance:
                    self.display_prompt_details(data)
                elif self.all_prompts:
                    self.display_prompt_details(self.all_prompts[0])


    # 删除用户提示词
    def delete_user_prompt(self, prompt_id_to_delete):
        id_of_currently_selected = None
        if self.selected_prompt_card:
            id_of_currently_selected = self.selected_prompt_card.prompt_data["id"]

        self.user_prompts = [p for p in self.user_prompts if p["id"] != prompt_id_to_delete]
        self.save_user_prompts()

        self.update_prompt_cards()

        if id_of_currently_selected == prompt_id_to_delete:
            self.selected_prompt_name_label.setText("")
            self.selected_prompt_content_text.clear()
            self.selected_prompt_card = None
            if self.all_prompts:
                self.display_prompt_details(self.all_prompts[0])
        elif id_of_currently_selected:
            card_to_reselect = self.find_card_widget(id_of_currently_selected)
            if card_to_reselect:
                self.display_prompt_details(card_to_reselect.prompt_data)
            elif self.all_prompts:
                self.display_prompt_details(self.all_prompts[0])
            else:
                self.selected_prompt_name_label.setText("")
                self.selected_prompt_content_text.clear()
                self.selected_prompt_card = None


================================================
FILE: UserInterface/Settings/AppSettingsPage.py
================================================
import os
import sys
import json
import subprocess

from PyQt5.QtCore import Qt
from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QVBoxLayout
from PyQt5.QtWidgets import QFileDialog

from qfluentwidgets import PushButton
from qfluentwidgets import FluentIcon
from qfluentwidgets import MessageBox
from qfluentwidgets import SwitchButton
from qfluentwidgets import SingleDirectionScrollArea

from Base.Base import Base
from Widget.EmptyCard import EmptyCard
from Widget.ComboBoxCard import ComboBoxCard
from Widget.LineEditCard import LineEditCard
from Widget.SwitchButtonCard import SwitchButtonCard

class AppSettingsPage(QWidget, Base):

    def __init__(self, text: str, window) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "proxy_url": "",
            "proxy_enable": False,
            "font_hinting": True,
            "scale_factor": "AUTO",
            "interface_language_setting": "简中",
            "auto_check_update": True,
            "label_input_exclude_rule": "",
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setContentsMargins(0, 0, 0, 0)

        # 设置滚动容器
        self.scroller = SingleDirectionScrollArea(self, orient = Qt.Vertical)
        self.scroller.setWidgetResizable(True)
        self.scroller.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        self.container.addWidget(self.scroller)

        # 设置容器
        self.vbox_parent = QWidget(self)
        self.vbox_parent.setStyleSheet("QWidget { background: transparent; }")
        self.vbox = QVBoxLayout(self.vbox_parent)
        self.vbox.setSpacing(8)
        self.vbox.setContentsMargins(24, 24, 24, 24) # 左、上、右、下
        self.scroller.setWidget(self.vbox_parent)

        # 添加控件
        self.add_widget_proxy(self.vbox, config)
        self.add_widget_font_hinting(self.vbox, config)
        self.add_widget_auto_check_update(self.vbox, config) # 使用子线程进行更新检查
        self.add_widget_debug_mode(self.vbox, config)
        self.add_widget_scale_factor(self.vbox, config)
        self.add_widget_interface_language_setting(self.vbox, config)
        self.add_widget_exclude_rule(self.vbox, config)
        self.add_widget_app_profile(self.vbox, config, window)

        # 填充
        self.vbox.addStretch(1)

    # 网络代理地址
    def add_widget_proxy(self, parent, config) -> None:

        def checked_changed(swicth_button, checked: bool) -> None:
            swicth_button.setChecked(checked)

            config = self.load_config()
            config["proxy_enable"] = checked
            self.save_config(config)

            # 获取并设置网络代理
            proxy_url = config["proxy_url"]
            if checked == False or proxy_url == "":
                os.environ.pop("http_proxy", None)
                os.environ.pop("https_proxy", None)
                info = self.tra("网络代理已关闭")
                self.info(info)
            else:
                os.environ["http_proxy"] = proxy_url
                os.environ["https_proxy"] = proxy_url
                info = self.tra("网络代理已启用，代理地址")
                self.info(f"{info}：{proxy_url}")

        def init(widget) -> None:
            widget.set_text(config.get("proxy_url"))
            widget.set_placeholder_text(self.tra("请输入网络代理地址"))

            swicth_button = SwitchButton()
            swicth_button.setOnText(self.tra("启用"))
            swicth_button.setOffText(self.tra("禁用"))
            swicth_button.setChecked(config.get("proxy_enable", False))
            swicth_button.checkedChanged.connect(lambda checked: checked_changed(swicth_button, checked))
            widget.add_spacing(8)
            widget.add_widget(swicth_button)

            # 获取并设置网络代理
            checked = config["proxy_enable"]
            proxy_url = config["proxy_url"]
            if checked == False or proxy_url == "":
                os.environ.pop("http_proxy", None)
                os.environ.pop("https_proxy", None)
            else:
                os.environ["http_proxy"] = proxy_url
                os.environ["https_proxy"] = proxy_url
                info = self.tra("网络代理已启用，代理地址")
                self.info(f"{info}：{proxy_url}")

        def text_changed(widget, text: str) -> None:
            config = self.load_config()
            config["proxy_url"] = text.strip()
            self.save_config(config)

        parent.addWidget(
            LineEditCard(
                self.tra("网络代理地址"),
                self.tra("启用该功能后，将使用设置的代理地址向接口发送请求，例如 http://127.0.0.1:7890"),
                init = init,
                text_changed = text_changed,
            )
        )

    # 应用字体优化
    def add_widget_font_hinting(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_checked(config.get("font_hinting"))

        def checked_changed(widget, checked: bool) -> None:
            config = self.load_config()
            config["font_hinting"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("应用字体优化"),
                self.tra("启用此功能后，字体的边缘渲染将更加圆润（将在应用重启后生效）"),
                init = init,
                checked_changed = checked_changed,
            )
        )

    # 调整模式
    def add_widget_debug_mode(self, parent, config) -> None:
        def init(widget) -> None:
            debug_path = os.path.join(".", "debug.txt")
            widget.set_checked(os.path.isfile(debug_path))

        def checked_changed(widget, checked: bool) -> None:
            debug_path = os.path.join(".", "debug.txt")
            if checked == True:
                open(debug_path, "w").close()
            else:
                os.remove(debug_path) if os.path.isfile(debug_path) else None

            # 重置调试模式检查状态
            self.reset_debug()

        parent.addWidget(
            SwitchButtonCard(
                self.tra("调试模式"),
                self.tra("启用此功能后，应用将显示额外的调试信息"),
                init = init,
                checked_changed = checked_changed,
            )
        )

    # 全局缩放比例
    def add_widget_scale_factor(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_current_index(max(0, widget.find_text(config.get("scale_factor"))))

        def current_text_changed(widget, text: str) -> None:
            config = self.load_config()
            config["scale_factor"] = text
            self.save_config(config)

        parent.addWidget(
            ComboBoxCard(
                self.tra("全局缩放比例"),
                self.tra("启用此功能后，应用界面将按照所选比例进行缩放（将在应用重启后生效）"),
                ["AUTO", "50%", "75%", "125%", "150%", "200%"],
                init = init,
                current_text_changed = current_text_changed,
            )
        )


    # 语言
    def add_widget_interface_language_setting(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_current_index(max(0, widget.find_text(config.get("interface_language_setting"))))

        def current_text_changed(widget, text: str) -> None:
            config = self.load_config()
            config["interface_language_setting"] = text
            self.save_config(config)

        parent.addWidget(
            ComboBoxCard(
                self.tra("界面语言设置"),
                self.tra("应用界面将按照所选语言进行显示（将在应用重启后生效）"),
                ["简中", "繁中", "English", "日本語"],
                init = init,
                current_text_changed = current_text_changed,
            )
        )

    # 自动检查更新
    def add_widget_auto_check_update(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_checked(config.get("auto_check_update", True))

        def checked_changed(widget, checked: bool) -> None:
            config = self.load_config()
            config["auto_check_update"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自动检查更新"),
                self.tra("启用此功能后，应用将在启动时自动检查是否有新版本"),
                init = init,
                checked_changed = checked_changed,
            )
        )


    def add_widget_exclude_rule(self, parent, config) -> None:
        """文件/目录排除规则"""
        def init(widget) -> None:
            widget.set_text(config.get("label_input_exclude_rule"))
            widget.set_placeholder_text(self.tra("*.log,aaa/*"))

        def text_changed(widget, text: str) -> None:
            config = self.load_config()
            config["label_input_exclude_rule"] = text.strip()
            self.save_config(config)

        parent.addWidget(
            LineEditCard(
                self.tra("文件/目录排除规则"),
                self.tra("*.log 表示排除所有结尾为 .log 的文件，aaa/* 表示排除输入文件夹下整个 aaa 目录，多个规则用英文逗号分隔"),
                init=init,
                text_changed=text_changed,
            )
        )

    # 应用配置切换
    def add_widget_app_profile(self, parent, config, window) -> None:

        # 重启应用
        def restart_app() -> None:
            subprocess.Popen([sys.executable] + sys.argv)
            sys.exit(0)

        # 导入配置文件
        def import_profile_file(path) -> None:
            profile = {}

            if os.path.exists(path):
                with open(path, "r", encoding = "utf-8") as reader:
                    profile = json.load(reader)
            else:
                self.error_toast("", self.tra("配置文件不存在！"))
                return

            # 确认框
            message_box = MessageBox("Warning", self.tra("是否确认导入选中的配置文件，导入后应用将自动重启"), window)
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))
            if message_box.exec():
                self.success_toast("", self.tra("配置文件导入成功，应用即将自动重启！"))
            else:
                return

            # 保存配置文件
            config = self.load_config()
            for k, v in profile.items():
                if k != "platforms":
                    config[k] = v
            self.save_config(config)

            # 重启应用
            QTimer.singleShot(1000, restart_app)

        # 导出配置文件
        def export_profile_file(path) -> None:
            config = self.load_config()
            del config["platforms"]

            with open(f"{path}/ainiee_profile.json", "w", encoding = "utf-8") as writer:
                writer.write(json.dumps(config, indent = 4, ensure_ascii = False))

            info_cont = self.tra("配置已导出为") + " \"ainiee_profile.json\" ..."
            self.success_toast("", info_cont)

        # 导入按钮点击事件
        def on_improt_button_clicked() -> None:
            path, _ = QFileDialog.getOpenFileName(None, self.tra("选择文件"), "", "json files (*.json)")

            if path == None or path == "":
                return

            import_profile_file(path)
        # 导出按钮点击事件
        def on_exprot_button_clicked() -> None:
            path = QFileDialog.getExistingDirectory(None, self.tra("选择文件夹"), "")

            if path == None or path == "":
                return

            export_profile_file(path)

        def init(widget) -> None:
            improt_button = PushButton(self.tra("导入"), self)
            improt_button.setIcon(FluentIcon.DOWNLOAD)
            improt_button.setContentsMargins(4, 0, 4, 0)
            improt_button.clicked.connect(on_improt_button_clicked)

            export_button = PushButton(self.tra("导出"), self)
            export_button.setIcon(FluentIcon.SHARE)
            export_button.setContentsMargins(4, 0, 4, 0)
            export_button.clicked.connect(on_exprot_button_clicked)

            widget.add_widget(improt_button)
            widget.add_spacing(16)
            widget.add_widget(export_button)

        parent.addWidget(
            EmptyCard(
                self.tra("应用配置切换"),
                self.tra("可以将当前应用的除接口信息以外的所有设置导出为配置文件，以方便根据不同项目切换配置（导入配置后应用将自动重启）"),
                init = init,
            )
        )


================================================
FILE: UserInterface/Settings/OutputSettingsPage.py
================================================

from PyQt5.QtWidgets import QFileDialog, QFrame
from PyQt5.QtWidgets import QVBoxLayout
from qfluentwidgets import FluentIcon, HorizontalSeparator

from Base.Base import Base
from Widget.ComboBoxCard import ComboBoxCard
from Widget.PushButtonCard import PushButtonCard
from Widget.SwitchButtonCard import SwitchButtonCard
from Widget.ComboBoxCard import ComboBoxCard
from Widget.LineEditCard import LineEditCard

class OutputSettingsPage(QFrame, Base):

    def __init__(self, text: str, window) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "label_output_path": "./output",
            "polishing_output_path": "./polish_output",
            "auto_set_output_path": True,
            "output_filename_suffix": "_translated", 
            "bilingual_text_order": "translation_first", 
            "response_conversion_toggle": False,
            "opencc_preset": "s2t",
            "keep_original_encoding": False,
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24) # 左、上、右、下

        # 添加控件
        self.add_widget_translation_output_path(self.container, config)
        self.add_widget_polishing_output_path(self.container, config)
        self.add_widget_auto_set(self.container, config)
        self.container.addWidget(HorizontalSeparator())
        self.add_widget_filename_suffix(self.container, config)
        self.add_widget_bilingual_text_order(self.container, config)
        self.add_widget_encoding(self.container, config)
        self.container.addWidget(HorizontalSeparator())
        self.add_widget_opencc(self.container, config)
        self.add_widget_opencc_preset(self.container, config)
        # 填充
        self.container.addStretch(1)

    # 翻译输出文件夹
    def add_widget_translation_output_path(self, parent, config) -> None:
        def widget_init(widget):
            info_cont = self.tra("当前输出文件夹为") + f" {config.get("label_output_path")}"
            widget.set_description(info_cont)
            widget.set_text(self.tra("选择文件夹"))
            widget.set_icon(FluentIcon.FOLDER_ADD)

        def widget_callback(widget) -> None:
            # 选择文件夹
            path = QFileDialog.getExistingDirectory(None, "选择文件夹", "")
            if path == None or path == "":
                return

            # 更新UI
            info_cont = self.tra("当前输出文件夹为") + f" {path.strip()}"
            widget.set_description(info_cont)

            # 更新并保存配置
            config = self.load_config()
            config["label_output_path"] = path.strip()
            self.save_config(config)

        # 拖拽文件夹回调
        def drop_callback(widget, dropped_text) -> None:
            if not dropped_text:
                return

            # 更新UI
            info_cont = self.tra("当前输出文件夹为") + f" {dropped_text.strip()}"
            widget.set_description(info_cont)

            # 更新并保存配置
            config = self.load_config()
            config["label_output_path"] = dropped_text.strip()
            self.save_config(config)


        parent.addWidget(
            PushButtonCard(
                self.tra("翻译输出文件夹"),
                "",
                widget_init,
                widget_callback,
                drop_callback,
            )
        )

    # 润色输出文件夹
    def add_widget_polishing_output_path(self, parent, config) -> None:
        def widget_init(widget):
            info_cont = self.tra("当前输出文件夹为") + f" {config.get("polishing_output_path")}"
            widget.set_description(info_cont)
            widget.set_text(self.tra("选择文件夹"))
            widget.set_icon(FluentIcon.FOLDER_ADD)

        def widget_callback(widget) -> None:
            # 选择文件夹
            path = QFileDialog.getExistingDirectory(None, "选择文件夹", "")
            if path == None or path == "":
                return

            # 更新UI
            info_cont = self.tra("当前输出文件夹为") + f" {path.strip()}"
            widget.set_description(info_cont)

            # 更新并保存配置
            config = self.load_config()
            config["polishing_output_path"] = path.strip()
            self.save_config(config)

        # 拖拽文件夹回调
        def drop_callback(widget, dropped_text) -> None:
            if not dropped_text:
                return

            # 更新UI
            info_cont = self.tra("当前输出文件夹为") + f" {dropped_text.strip()}"
            widget.set_description(info_cont)

            # 更新并保存配置
            config = self.load_config()
            config["polishing_output_path"] = dropped_text.strip()
            self.save_config(config)


        parent.addWidget(
            PushButtonCard(
                self.tra("润色输出文件夹"),
                "",
                widget_init,
                widget_callback,
                drop_callback,
            )
        )

    # 自动设置输出文件夹开关
    def add_widget_auto_set(self, parent, config) -> None:
        def widget_init(widget) -> None:
            widget.set_checked(config.get("auto_set_output_path"))

        def widget_callback(widget, checked: bool) -> None:
            config = self.load_config()
            config["auto_set_output_path"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自动设置输出文件夹"),
                self.tra("启用此功能后，设置为输入文件夹的平级目录，比如输入文件夹为D:/Test/Input，输出文件夹将设置为D:/Test/AiNieeOutput"),
                widget_init,
                widget_callback,
            )
        )

    # 自动编码统一
    def add_widget_encoding(self, parent, config) -> None:
        def widget_init(widget) -> None:
            widget.set_checked(config.get("keep_original_encoding"))

        def widget_callback(widget, checked: bool) -> None:
            config = self.load_config()
            config["keep_original_encoding"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("保持输入输出文件编码一致"),
                self.tra("启用此功能后，输出译文文件的编码将保持为与输入原文文件的编码一致（若字符不兼容，仍会使用utf-8），"
                         "关闭后将始终使用 utf-8 编码（无特殊情况保持关闭即可）"),
                widget_init,
                widget_callback,
            )
        )

    # 自动简繁转换
    def add_widget_opencc(self, parent, config) -> None:
        def widget_init(widget) -> None:
            widget.set_checked(config.get("response_conversion_toggle"))

        def widget_callback(widget, checked: bool) -> None:
            config = self.load_config()
            config["response_conversion_toggle"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自动简繁转换"),
                self.tra("启用此功能后，在翻译完成时将按照设置的字形映射规则进行简繁转换"),
                widget_init,
                widget_callback,
            )
        )

    # 简繁转换预设规则
    def add_widget_opencc_preset(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_current_index(max(0, widget.find_text(config.get("opencc_preset"))))

        def current_text_changed(widget, text: str) -> None:
            config = self.load_config()
            config["opencc_preset"] = text
            self.save_config(config)

        parent.addWidget(
            ComboBoxCard(
                self.tra("简繁转换预设规则"),
                self.tra("进行简繁转换时的字形预设规则，常用的有：简转繁（s2t）、繁转简（t2s）"),
                [
                    "s2t",
                    "s2tw",
                    "s2hk",
                    "s2twp",
                    "t2s",
                    "t2tw",
                    "t2hk",
                    "t2jp",
                    "tw2s",
                    "tw2t",
                    "tw2sp",
                    "hk2s",
                    "hk2t",
                    "jp2t",
                ],
                init = init,
                current_text_changed = current_text_changed,
            )
        )

    # 文件名后缀设置
    def add_widget_filename_suffix(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_text(config.get("output_filename_suffix", "_translated"))
            widget.set_placeholder_text(self.tra("例如: _translated"))

        def text_changed(widget, text: str) -> None:
            config = self.load_config()
            config["output_filename_suffix"] = text.strip()
            self.save_config(config)

        parent.addWidget(
            LineEditCard(
                self.tra("文件名后缀"),
                self.tra("设置输出文件的文件名后缀，例如: _translated"),
                init=init,
                text_changed=text_changed
            )
        )

    # 双语文件文本顺序设置
    def add_widget_bilingual_text_order(self, parent, config) -> None:
        # 创建选项对列表 (显示文本, 存储值)
        order_pairs = [
            (self.tra("原文在上"), "source_first"),
            (self.tra("译文在上"), "translation_first")
        ]
        
        # 生成翻译后的选项列表
        options = [display for display, _ in order_pairs]
        
        def init(widget) -> None:
            current_value = config.get("bilingual_text_order", "original_first")
            # 查找当前值对应的索引
            index = next(
                (i for i, (_, value) in enumerate(order_pairs) if value == current_value),
                0  # 默认选择第一个选项
            )
            widget.set_current_index(max(0, index))

        def current_text_changed(widget, text: str) -> None:
            # 查找显示文本对应的存储值
            value = next(
                (value for display, value in order_pairs if display == text),
                "original_first"  # 默认值
            )
            
            config = self.load_config()
            config["bilingual_text_order"] = value
            self.save_config(config)

        parent.addWidget(
            ComboBoxCard(
                self.tra("双语文件文本顺序"),
                self.tra("设置双语文件中原文和译文的显示顺序，仅支持txt与epub项目"),
                options,
                init=init,
                current_text_changed=current_text_changed
            )
        )


================================================
FILE: UserInterface/Settings/PluginsSettingsPage.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import SingleDirectionScrollArea

from Base.Base import Base
from Widget.SwitchButtonCard import SwitchButtonCard

class PluginsSettingsPage(QFrame, Base):

    def __init__(self, text: str, window, plugin_manager = None):
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "plugins_enable": {},
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 插件管理器
        self.plugin_manager = plugin_manager

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setContentsMargins(0, 0, 0, 0)

        # 设置滚动容器
        self.scroller = SingleDirectionScrollArea(self, orient = Qt.Vertical)
        self.scroller.setWidgetResizable(True)
        self.scroller.setStyleSheet("QScrollArea { border: none; background: transparent; }")
        self.container.addWidget(self.scroller)

        # 设置容器
        self.vbox_parent = QWidget(self)
        self.vbox_parent.setStyleSheet("QWidget { background: transparent; }")
        self.vbox = QVBoxLayout(self.vbox_parent)
        self.vbox.setSpacing(8)
        self.vbox.setContentsMargins(24, 24, 24, 24) # 左、上、右、下
        self.scroller.setWidget(self.vbox_parent)

        # 初始化，确保所有插件的启用状态都具有默认值
        for k, v in self.plugin_manager.get_plugins().items():
            enable = config.get("plugins_enable").get(k, None)

            if enable == None:
                config["plugins_enable"][k] = v.default_enable
            else:
                config["plugins_enable"][k] = enable

        # 更新插件启用状态
        self.save_config(config)
        self.plugin_manager.update_plugins_enable(config.get("plugins_enable"))

        # 添加控件
        for k, v in self.plugin_manager.get_plugins().items():
            def widget_init(widget):
                widget.plugin_name = k
                widget.set_checked(config.get("plugins_enable").get(k))

            def widget_callback(widget, checked: bool):
                config = self.load_config()
                config["plugins_enable"][widget.plugin_name] = checked
                self.save_config(config)

                # 同步更新 plugin_manager 里的插件启用状态
                self.plugin_manager.update_plugins_enable(config.get("plugins_enable"))

            self.vbox.addWidget(
                SwitchButtonCard(
                    f"{v.name}",
                    f"{v.description}",
                    widget_init,
                    widget_callback,
                )
            )

        # 填充
        self.vbox.addStretch(1)


================================================
FILE: UserInterface/Settings/TaskSettingsPage.py
================================================
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QVBoxLayout
from qfluentwidgets import HorizontalSeparator

from Base.Base import Base
from Widget.SpinCard import SpinCard
from Widget.ComboBoxCard import ComboBoxCard

class TaskSettingsPage(QFrame, Base):

    def __init__(self, text: str, window) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "lines_limit_switch": False,
            "tokens_limit_switch": True,
            "lines_limit": 10,
            "tokens_limit": 1024,
            "user_thread_counts": 0,
            "request_timeout": 120,
            "round_limit": 10,
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置容器
        self.vbox = QVBoxLayout(self)
        self.vbox.setSpacing(8)
        self.vbox.setContentsMargins(24, 24, 24, 24)

        # 初始化控件引用
        self.lines_limit_card = None
        self.tokens_limit_card = None
        self.mode_combo_box = None

        # 添加控件
        self.add_widget_01(self.vbox, config)
        self.add_widget_02(self.vbox, config)
        self.add_widget_03(self.vbox, config)
        self.vbox.addWidget(HorizontalSeparator())
        self.add_widget_04(self.vbox, config)
        self.vbox.addWidget(HorizontalSeparator())
        self.add_widget_request_timeout(self.vbox, config)
        self.add_widget_06(self.vbox, config)

        # 根据初始模式设置可见性
        self.update_limit_cards_visibility(config)

        # 填充
        self.vbox.addStretch(1)

    def update_limit_cards_visibility(self, config):
        """根据当前模式更新限制卡片的可见性"""
        if config["lines_limit_switch"]:
            self.tokens_limit_card.hide()
            self.lines_limit_card.show()
        else:
            self.lines_limit_card.hide()
            self.tokens_limit_card.show()

    # 子任务切分模式
    def add_widget_01(self, parent, config) -> None:
        # 定义模式配对列表（显示文本, 存储值）
        mode_pairs = [
            (self.tra("行数模式"), "lines"),
            (self.tra("Token模式"), "tokens")
        ]
        
        # 生成翻译后的配对列表
        translated_pairs = [(self.tra(display), value) for display, value in mode_pairs]

        def init(widget) -> None:
            """初始化时根据配置设置当前选项"""
            current_config = self.load_config()
            
            # 根据配置确定当前模式值
            if current_config.get("lines_limit_switch", False):
                current_value = "lines"
            else:
                current_value = "tokens"
                
            # 通过存储值查找对应的索引
            index = next(
                (i for i, (_, value) in enumerate(translated_pairs) if value == current_value),
                0  # 默认选择第一个选项
            )
            widget.set_current_index(max(0, index))

        def current_text_changed(widget, text: str) -> None:
            """选项变化时更新配置"""
            # 通过显示文本查找对应的存储值
            value = next(
                (value for display, value in translated_pairs if display == text),
                "tokens"  # 默认值
            )
            
            config = self.load_config()
            if value == "lines":
                config["lines_limit_switch"] = True
                config["tokens_limit_switch"] = False
            else:
                config["lines_limit_switch"] = False
                config["tokens_limit_switch"] = True
                
            self.save_config(config)
            self.update_limit_cards_visibility(config)

        # 创建选项列表（使用翻译后的显示文本）
        options = [display for display, value in translated_pairs]

        self.mode_combo_box = ComboBoxCard(
            self.tra("任务切分模式"),
            self.tra("选择任务切分的模式"),
            options,
            init=init,
            current_text_changed=current_text_changed,
        )
        parent.addWidget(self.mode_combo_box)

    # 子任务的最大文本行数
    def add_widget_02(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("lines_limit"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["lines_limit"] = value
            self.save_config(config)

        self.lines_limit_card = SpinCard(
            self.tra("任务的文本行数"),
            self.tra("当任务切分模式设置为 行数模式 时，按此值对原文进行切分"),
            init=init,
            value_changed=value_changed,
        )
        parent.addWidget(self.lines_limit_card)

    # 子任务的最大 Token 数量
    def add_widget_03(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("tokens_limit"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["tokens_limit"] = value
            self.save_config(config)

        self.tokens_limit_card = SpinCard(
            self.tra("任务的 Token 数量"),
            self.tra("当任务切分模式设置为 Token 模式 时，按此值对原文进行切分"),
            init=init,
            value_changed=value_changed,
        )
        parent.addWidget(self.tokens_limit_card)

    # 同时执行的子任务数量
    def add_widget_04(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("user_thread_counts"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["user_thread_counts"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("并发任务数"),
                self.tra("合理设置可以极大的增加翻译速度，请设置为本地模型的 np 值或者参考在线接口的官方文档，设置为 0 为自动模式"),
                init = init,
                value_changed = value_changed,
            )
        )


    # 请求超时时间
    def add_widget_request_timeout(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("request_timeout"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["request_timeout"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("请求超时时间(s)"),
                self.tra("单元任务发起请求时等待模型回复的最长时间，超时仍未收到回复，则会判断为任务失败"),
                init = init,
                value_changed = value_changed,
            )
        )

    # 任务流程的最大轮次
    def add_widget_06(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("round_limit"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["round_limit"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("任务流程的最大轮次"),
                self.tra("当完成一轮任务后，如果还有未翻译/润色的条目，将重新开始新的任务流程，直到翻译/润色完成或者达到最大轮次"),
                init = init,
                value_changed = value_changed,
            )
        )




================================================
FILE: UserInterface/Table/ExclusionListPage.py
================================================
import copy
import pandas
import rapidjson as json
from qfluentwidgets import (Action, FluentIcon, MessageBox, TableWidget, RoundMenu,
                            LineEdit, DropDownPushButton, ToolButton, TransparentToolButton, BodyLabel)

from PyQt5.QtCore import QEvent, Qt, QPoint, QTimer
from PyQt5.QtWidgets import (QFrame, QFileDialog, QHeaderView, QLayout, QVBoxLayout,
                             QTableWidgetItem, QHBoxLayout, QWidget,QAbstractItemView)

from Base.Base import Base
from UserInterface.TableHelper.TableHelper import TableHelper
from Widget.SwitchButtonCard import SwitchButtonCard
from UserInterface import AppFluentWindow

class ExclusionListPage(QFrame, Base):

    KEYS = ("markers", "info", "regex",)
    COLUMN_NAMES = {0: "标记符",1: "备注",2: "正则",}

    def __init__(self, text: str, window: AppFluentWindow) -> None:
        super().__init__(parent=window)
        self.setObjectName(text.replace(" ", "-"))

        self.default = {
            "exclusion_list_switch": False,
            "exclusion_list_data": [],
        }

        # 读取配置
        config = self.save_config(self.load_config_from_default())

        # 搜索相关属性
        self._search_results = []
        self._current_search_index = -1
        self._search_timer = QTimer(self)
        self._search_timer.setSingleShot(True)
        self._search_timer.setInterval(300)
        self._search_timer.timeout.connect(self._perform_search)
        self._current_search_field_index = -1

        # 排序相关属性
        self._sort_column_index = -1  # 记录当前排序的列索引，-1表示未排序
        self._sort_order = Qt.AscendingOrder # 记录当前排序顺序

        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        self.add_widget_head(self.container, config, window)
        self.add_widget_body(self.container, config, window)

        self._reset_search()

    def _get_translated_column_name(self, index: int) -> str:
        return self.tra(self.COLUMN_NAMES.get(index, f"字段{index+1}"))

    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.update_table() # 每次显示时更新，并确保搜索/排序状态重置

    def update_table(self) -> None:
        config = self.load_config()
        TableHelper.update_to_table(self.table, config["exclusion_list_data"], ExclusionListPage.KEYS)
        self._reset_search() # 重置搜索状态
        self._reset_sort_indicator() # 重置排序指示器

    # 右键菜单
    def show_table_context_menu(self, pos: QPoint):

        menu = RoundMenu(parent=self.table)
        has_selection = bool(self.table.selectionModel().selectedRows())

        if has_selection:
            menu.addAction(Action(FluentIcon.ADD_TO, self.tra("插入行"), triggered=self._handle_insert_row))
            menu.addAction(Action(FluentIcon.REMOVE_FROM, self.tra("删除行"), triggered=self._handle_remove_selected_rows))
            menu.addSeparator()

        # 行数统计
        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.LEAF,f"{self.tra('全部行数')}: {row_count}")
        row_count_action.setEnabled(False) # 使其不可点击，仅作为信息显示
        menu.addAction(row_count_action)

        global_pos = self.table.mapToGlobal(pos)
        menu.exec_(global_pos, ani=True)

    # 处理删除选定行
    def _handle_remove_selected_rows(self) -> None:

        indices = self.table.selectionModel().selectedRows()
        if not indices:
            return

        rows_to_remove = sorted([index.row() for index in indices], reverse=True)

        self.table.setUpdatesEnabled(False)
        for row in rows_to_remove:
            self.table.removeRow(row)
        self.table.setUpdatesEnabled(True)

        self._reset_search() # 删除行后重置搜索
        self._reset_sort_indicator() # 删除行后重置排序
        self.success_toast("", self.tra("选取行已移除") + "...")

    # 处理插入行
    def _handle_insert_row(self) -> None:

        selected_rows = {item.row() for item in self.table.selectedItems()}
        insert_pos = self.table.rowCount() # 默认为末尾
        if selected_rows:
             insert_pos = max(selected_rows) + 1

        self.table.insertRow(insert_pos)
        # 滚动到新行
        new_item = QTableWidgetItem("") # 创建一个虚拟项以滚动到该位置
        self.table.setItem(insert_pos, 0, new_item) # 添加到第一列
        self.table.scrollToItem(new_item, QAbstractItemView.ScrollHint.PositionAtCenter)
        self.table.selectRow(insert_pos) # 选择新行
        self.table.editItem(self.table.item(insert_pos, 0)) # 开始编辑第一个单元格

        self._reset_sort_indicator() # 重置排序指示器
        self.success_toast("", self.tra("新行已插入") + "...")


    # 添加头部部件
    def add_widget_head(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("exclusion_list_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["exclusion_list_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("禁翻表"),
                self.tra("通过构建禁翻表来引导模型，禁止翻译文本中的特殊标记符，占位符，代码段等内容\n△触发机制: 文本含有标记符，或者正则表达式匹配生效  ◯填写示例:  //F[N1]  |  游戏文本标记符号  |  //[A-Z]\\[.*?\\]"),
                init=init,
                checked_changed=checked_changed,
            )
        )


    # 添加主体部件
    def add_widget_body(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:
        toolbar_widget = self._create_search_toolbar()
        parent.addWidget(toolbar_widget)
        parent.setSpacing(10)

        def item_changed(item: QTableWidgetItem) -> None:
            item.setTextAlignment(Qt.AlignCenter)
            # 编辑单元格后，不一定需要立即重排序或重置搜索
            # self._reset_search()
            # self.search_input.clear()
            # self._reset_sort_indicator()
            # 后期可以添加自动保存，也可以不添加


        self.table = TableWidget(self)
        parent.addWidget(self.table)

        self.table.setBorderRadius(8)
        self.table.setBorderVisible(True)
        self.table.setWordWrap(True)
        self.table.setColumnCount(len(ExclusionListPage.KEYS))
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_table_context_menu)

        self.table.itemChanged.connect(item_changed)

        header_labels = [self._get_translated_column_name(i) for i in range(len(ExclusionListPage.KEYS))]
        self.table.setHorizontalHeaderLabels(header_labels)

        # 启用排序和连接信号
        self.table.setSortingEnabled(False) # 禁用内置排序
        self.table.horizontalHeader().setSortIndicatorShown(True) # 显示排序指示器空间
        self.table.horizontalHeader().sectionClicked.connect(self._sort_table_by_column) # 连接排序信号

        self.table.resizeRowsToContents() # 调整行高
        self._reset_sort_indicator() # 重置排序指示器

    # 重置排序指示器
    def _reset_sort_indicator(self):
        """清除排序状态和表头的排序指示器。"""
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder
        if hasattr(self, 'table'): 
            self.table.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

    # 排序逻辑处理函数
    def _sort_table_by_column(self, logicalIndex: int):
        """当表头被点击时，按该列对表格数据进行排序。"""
        # 1. 确定排序顺序
        if self._sort_column_index == logicalIndex:
            # 如果点击的是同一列，切换排序顺序
            self._sort_order = Qt.DescendingOrder if self._sort_order == Qt.AscendingOrder else Qt.AscendingOrder
        else:
            # 如果点击的是新列，重置为升序
            self._sort_column_index = logicalIndex
            self._sort_order = Qt.AscendingOrder

        # 2. 获取当前表格数据
        data = TableHelper.load_from_table(self.table, ExclusionListPage.KEYS)

        # 3. 定义排序键函数
        try:
            sort_key_name = ExclusionListPage.KEYS[logicalIndex]
        except IndexError:
            self.logger.warning(f"Invalid column index {logicalIndex} for sorting.")
            return # 无效列索引，不排序

        def get_sort_key(item):
            value = item.get(sort_key_name, "") # 获取值，默认为空字符串
            if value is None: # 处理 None 值
                value = ""
            # 尝试将值转为小写字符串进行不区分大小写的文本排序
            # 注意：如果列包含数字或需要特定类型排序，这里可能需要更复杂的逻辑
            return str(value).lower()

        # 4. 排序数据
        data.sort(key=get_sort_key, reverse=(self._sort_order == Qt.DescendingOrder))


        # 5. 清空并重新填充表格
        self.table.setUpdatesEnabled(False) # 优化性能
        self.table.setRowCount(0) # 清空表格
        TableHelper.update_to_table(self.table, data, ExclusionListPage.KEYS)
        self.table.resizeRowsToContents() # 重新调整行高
        self.table.setUpdatesEnabled(True)

        # 6. 更新表头排序指示器
        self.table.horizontalHeader().setSortIndicator(self._sort_column_index, self._sort_order)

        # 7. 重置搜索状态，因为行顺序已改变
        self._reset_search() # 非常重要！
        self.info_toast("", self.tra("表格已按 '{}' {}排序").format(
            self._get_translated_column_name(logicalIndex),
            self.tra("升序") if self._sort_order == Qt.AscendingOrder else self.tra("降序")
        ))

    # 工具栏
    def _create_search_toolbar(self) -> QWidget:

        toolbar_widget = QWidget(self)
        layout = QHBoxLayout(toolbar_widget)
        layout.setContentsMargins(0, 0, 0, 0) # 工具栏本身无外部边距
        layout.setSpacing(8) # 工具栏项之间的间距

        # 1. 搜索输入框
        self.search_input = LineEdit(self)
        self.search_input.setPlaceholderText(self.tra("搜索表格内容..."))
        self.search_input.setClearButtonEnabled(True)
        self.search_input.textChanged.connect(self._on_search_text_changed) # 使用计时器进行防抖
        layout.addWidget(self.search_input, 1) # 拉伸输入字段

        # 2. 搜索字段下拉菜单
        self.search_field_button = DropDownPushButton(self.tra("全部"), self)
        self.search_field_menu = RoundMenu(parent=self.search_field_button)

        # "全部"字段的Action
        all_action = Action(self.tra("全部"))
        all_action.triggered.connect(lambda: self._set_search_field(-1, self.tra("全部")))
        self.search_field_menu.addAction(all_action)
        self.search_field_menu.addSeparator()

        # 特定字段的Action
        for i, key in enumerate(ExclusionListPage.KEYS):
            col_name = self._get_translated_column_name(i)
            action = Action(col_name)
            # 使用带有默认参数捕获的lambda表达式以传递正确的索引和名称
            action.triggered.connect(lambda checked=False, index=i, name=col_name: self._set_search_field(index, name))
            self.search_field_menu.addAction(action)

        self.search_field_button.setMenu(self.search_field_menu)
        layout.addWidget(self.search_field_button)

        # 3. 搜索结果标签
        self.search_results_label = BodyLabel("", self)
        layout.addWidget(self.search_results_label)

        # 4. 导航按钮 (上/下箭头)
        self.search_prev_button = TransparentToolButton(FluentIcon.UP, self)
        self.search_prev_button.setToolTip(self.tra("上一个结果"))
        self.search_prev_button.clicked.connect(self._navigate_previous)
        self.search_prev_button.setEnabled(False) # 初始禁用
        layout.addWidget(self.search_prev_button)

        self.search_next_button = TransparentToolButton(FluentIcon.DOWN, self)
        self.search_next_button.setToolTip(self.tra("下一个结果"))
        self.search_next_button.clicked.connect(self._navigate_next)
        self.search_next_button.setEnabled(False) # 初始禁用
        layout.addWidget(self.search_next_button)

        # 5.保存重置导入导出按钮
        layout.addStretch(1) # 添加拉伸项以将按钮推到右侧
        self.save_button = ToolButton(FluentIcon.SAVE, self)
        self.save_button.setToolTip(self.tra("保存"))
        self.save_button.clicked.connect(self.save_data)
        layout.addWidget(self.save_button)

        self.reset_button = ToolButton(FluentIcon.DELETE, self)
        self.reset_button.setToolTip(self.tra("重置"))
        self.reset_button.clicked.connect(self.reset_data)
        layout.addWidget(self.reset_button)

        self.import_button = ToolButton(FluentIcon.DOWNLOAD, self)
        self.import_button.setToolTip(self.tra("导入"))
        self.import_button.clicked.connect(self.import_data)
        layout.addWidget(self.import_button)

        self.export_button = ToolButton(FluentIcon.SHARE, self)
        self.export_button.setToolTip(self.tra("导出"))
        self.export_button.clicked.connect(self.export_data)
        layout.addWidget(self.export_button)

        return toolbar_widget

    # 设置搜索字段
    def _set_search_field(self, field_index: int, field_name: str):
        
        self.search_field_button.setText(field_name)
        if self._current_search_field_index != field_index:
            self._current_search_field_index = field_index
            self._perform_search()

    # 搜索逻辑方法
    def _on_search_text_changed(self, text: str):
        
        if not text.strip():
             self._reset_search_results()
             self._update_search_ui()
             self.table.clearSelection()
        self._search_timer.start()

    # 重置搜索结果
    def _reset_search_results(self):
        self._search_results = []
        self._current_search_index = -1

    # 重置搜索状态
    def _reset_search(self):
        """重置搜索状态，但不影响排序状态。"""
        self._reset_search_results()
        if hasattr(self, 'search_input'):
            self.search_input.clear()
            self._current_search_field_index = -1
            if hasattr(self, 'search_field_button'): 
                 self.search_field_button.setText(self.tra("全部"))
            self._update_search_ui()
            if hasattr(self, 'table'): 
                 self.table.clearSelection()

    # 执行搜索
    def _perform_search(self):

        search_text = self.search_input.text().strip().lower()
        self._reset_search_results() # 清除之前的搜索结果

        if not search_text:
            self._update_search_ui()
            if hasattr(self, 'table'): self.table.clearSelection() 
            return

        target_col = self._current_search_field_index
        rows = self.table.rowCount()
        cols = self.table.columnCount()

        for r in range(rows):
            columns_to_search = range(cols) if target_col == -1 else [target_col]
            for c in columns_to_search:
                 # 确保列索引有效
                if c >= cols: continue 
                item = self.table.item(r, c)
                if item and search_text in item.text().lower():
                    self._search_results.append((r, c))
                    if target_col != -1: # 如果搜索特定列，则停止检查此行中的其他列
                         break

        # 如果搜索“全部”导致每行有多个匹配项，则删除重复行
        if target_col == -1:
            unique_results = []
            seen_rows = set()
            for r, c in self._search_results:
                if r not in seen_rows:
                    unique_results.append((r, c)) # 保留该行的第一个列匹配项
                    seen_rows.add(r)
            self._search_results = unique_results


        if self._search_results:
            self._navigate_search_result(0) # 转到第一个结果
        else:
            self._update_search_ui() # 更新UI以显示“0/0”
            if hasattr(self, 'table'): self.table.clearSelection() 

    # 更新搜索UI
    def _update_search_ui(self):

        count = len(self._search_results)
        if count > 0:
            label_text = f"{self._current_search_index + 1}/{count}"
        else:
            # 仅当有搜索文本时显示0/0，否则清除标签
            if hasattr(self, 'search_input') and self.search_input.text().strip(): 
                label_text = "0/0"
            else:
                label_text = "" # 如果没有搜索文本则清除

        if hasattr(self, 'search_results_label'): self.search_results_label.setText(label_text) 

        # 启用/禁用导航按钮
        can_navigate = count > 1
        if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(can_navigate and self._current_search_index > 0) 
        if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(can_navigate and self._current_search_index < count - 1) 
        # 如果只有一个结果，则禁用两个按钮
        if count <= 1:
            if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(False) 
            if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(False) 

    # 导航上一个结果
    def _navigate_previous(self):

        if self._search_results and self._current_search_index > 0:
            self._navigate_search_result(self._current_search_index - 1)

    # 导航下一个结果
    def _navigate_next(self):

        if self._search_results and self._current_search_index < len(self._search_results) - 1:
            self._navigate_search_result(self._current_search_index + 1)

    # 导航到搜索结果
    def _navigate_search_result(self, index: int):

        if not self._search_results or not (0 <= index < len(self._search_results)):
            return

        self._current_search_index = index
        row, col = self._search_results[index]

        # 确保行/列仍然有效
        if hasattr(self, 'table') and row < self.table.rowCount() and col < self.table.columnCount(): 
            item_to_select = self.table.item(row, 0) 
            if item_to_select:
                self.table.clearSelection() # 首先清除之前的选择
                self.table.setCurrentCell(row, col) # 选择特定的单元格
                self.table.selectRow(row) # 选择包含结果的整行
                self.table.scrollToItem(item_to_select, QAbstractItemView.ScrollHint.PositionAtCenter) # 平滑滚动

        self._update_search_ui() # 更新标签和按钮状态

    # 保存方法
    def save_data(self) -> None:
        config = self.load_config()
        config["exclusion_list_data"] = TableHelper.load_from_table(self.table, ExclusionListPage.KEYS)
        self.save_config(config)
        self.success_toast("", self.tra("数据已保存") + " ... ")

    # 重置方法
    def reset_data(self) -> None:
        info_cont1 = self.tra("是否确认重置为默认数据") + " ... ？"
        message_box = MessageBox(self.tra("警告"), info_cont1, self.window())
        message_box.yesButton.setText(self.tra("确认"))
        message_box.cancelButton.setText(self.tra("取消"))

        if not message_box.exec():
            return

        self.table.setRowCount(0)
        config = self.load_config()
        config["exclusion_list_data"] = copy.deepcopy(self.default.get("exclusion_list_data", []))
        self.save_config(config)
        TableHelper.update_to_table(self.table, config.get("exclusion_list_data"), ExclusionListPage.KEYS)
        self.table.resizeRowsToContents()
        self._reset_search() # 重置后重置搜索
        self._reset_sort_indicator() # 重置后重置排序
        self.success_toast("", self.tra("数据已重置") + " ... ")

    # 导入方法
    def import_data(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, self.tra("选择文件"), "", "json 文件 (*.json);;xlsx 文件 (*.xlsx)")
        if not isinstance(path, str) or path == "":
            return
        data = TableHelper.load_from_file(path, ExclusionListPage.KEYS)
        config = self.load_config()

        # 去重逻辑
        current_data = TableHelper.load_from_table(self.table, ExclusionListPage.KEYS)
        current_src_set = {item['markers'] for item in current_data if item.get('markers')} # 处理潜在的空 markers
        new_data_filtered = [item for item in data if item.get('markers') and item['markers'] not in current_src_set] # 确保导入的项目具有 markers

        if not new_data_filtered and data: # 如果所有导入的项目都已存在，则通知
            self.info_toast(self.tra("信息"), self.tra("导入的数据项均已存在于当前表格中"))
            return
        elif not new_data_filtered and not data: # 如果文件为空或格式无效，则通知
            self.warning_toast(self.tra("警告"), self.tra("未从文件中加载到有效数据"))
            return

        # 更新并保存
        # 合并现有数据（来自表格状态）+ 新的已过滤数据
        combined_data = current_data + new_data_filtered
        config["exclusion_list_data"] = combined_data # 直接更新配置

        # 在再次从表格保存配置*之前*更新表格
        TableHelper.update_to_table(self.table, config["exclusion_list_data"], ExclusionListPage.KEYS)
        self.table.resizeRowsToContents() # 导入后调整行高

        # 现在将可能已修改的表格状态保存回配置
        config["exclusion_list_data"] = TableHelper.load_from_table(self.table, ExclusionListPage.KEYS)
        self.save_config(config)
        self._reset_search() # 导入后重置搜索
        self._reset_sort_indicator() # 导入后重置排序
        self.success_toast("", self.tra("数据已导入并更新") + f" ({len(new_data_filtered)} {self.tra('项')})...")

    # 导出方法
    def export_data(self) -> None:
        data = TableHelper.load_from_table(self.table, ExclusionListPage.KEYS)
        if not data:
            self.warning_toast("", self.tra("表格中没有数据可导出"))
            return

        default_filename = self.tra("导出_术语表")

        
        file_filter = "JSON 文件 (*.json);;XLSX 文件 (*.xlsx)"
        path, selected_filter = QFileDialog.getSaveFileName(
            self, self.tra("导出文件"), default_filename, file_filter
        )

        if not path:
            return

        # 根据选择的过滤器确保文件扩展名正确
        if "(*.xlsx)" in selected_filter and not path.lower().endswith(".xlsx"):
            path += ".xlsx"
        elif "(*.json)" in selected_filter and not path.lower().endswith(".json"):
            path += ".json"

        try:
            if path.lower().endswith(".json"):
                with open(path, "w", encoding="utf-8") as writer:
                    writer.write(json.dumps(data, indent=4, ensure_ascii=False))
            elif path.lower().endswith(".xlsx"):
                # 使用 pandas 将数据转换为 DataFrame
                df = pandas.DataFrame(data)
                # 使用 reindex 确保所有列都存在且顺序正确
                df = df.reindex(columns=list(self.KEYS), fill_value="")
                # 将列名重命名为用户友好的译文
                df.columns = [self._get_translated_column_name(i) for i in range(len(self.KEYS))]
                # 将 DataFrame 导出到 Excel 文件，不包含索引列
                df.to_excel(path, index=False)
            else:
                self.error_toast(self.tra("导出失败"), self.tra("不支持的文件类型。请选择 .json 或 .xlsx"))
                return

            self.success_toast("", self.tra("数据已导出到") + f": {path}")

        except Exception as e:
            self.logger.error(f"Failed to export data to {path}: {e}", exc_info=True)
            self.error_toast(self.tra("导出失败"), str(e))




================================================
FILE: UserInterface/Table/PromptDictionaryPage.py
================================================
import copy
import rapidjson as json
import pandas
from qfluentwidgets import (Action, FluentIcon, MessageBox, TableWidget, RoundMenu,
                            LineEdit, DropDownPushButton, ToolButton, TransparentPushButton, TransparentToolButton, BodyLabel)

from PyQt5.QtCore import QEvent, Qt, QPoint, QTimer
from PyQt5.QtWidgets import ( QFrame, QFileDialog, QHeaderView, QLayout, QVBoxLayout,
                             QTableWidgetItem, QHBoxLayout, QWidget,QAbstractItemView)

from Base.Base import Base
from UserInterface.TableHelper.TableHelper import TableHelper
from UserInterface.NameExtractor.NameExtractor import NameExtractor
from Widget.SwitchButtonCard import SwitchButtonCard
from UserInterface import AppFluentWindow

class PromptDictionaryPage(QFrame, Base):

    KEYS = ("src", "dst", "info",)
    COLUMN_NAMES = {0: "原文",1: "译文",2: "描述",}

    def __init__(self, text: str, window: AppFluentWindow) -> None:
        super().__init__(parent=window)
        self.setObjectName(text.replace(" ", "-"))

        self.default = {
            "prompt_dictionary_switch": False,
            "prompt_dictionary_data": [],
        }

        # 订阅术语表翻译完成事件
        self.subscribe(Base.EVENT.GLOSS_TASK_DONE, self.glossary_translation_done)
        # 读取配置
        config = self.save_config(self.load_config_from_default())

        # 搜索相关属性
        self._search_results = []
        self._current_search_index = -1
        self._search_timer = QTimer(self)
        self._search_timer.setSingleShot(True)
        self._search_timer.setInterval(300)
        self._search_timer.timeout.connect(self._perform_search)
        self._current_search_field_index = -1

        # 排序相关属性
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder

        # 工具栏切换状态
        self._secondary_toolbar_visible = False # 新增：追踪副工具栏状态

        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        self.add_widget_head(self.container, config, window)
        self.add_widget_body(self.container, config, window)

    # 翻译字段名字
    def _get_translated_column_name(self, index: int) -> str:
        return self.tra(self.COLUMN_NAMES.get(index, f"字段{index+1}"))

    # 打开页面事件
    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.update_table()

    # 更新表格内容及状态
    def update_table(self) -> None:
        config = self.load_config()
        TableHelper.update_to_table(self.table, config["prompt_dictionary_data"], PromptDictionaryPage.KEYS)
        self._reset_search()
        self._reset_sort_indicator()

    # 右键菜单内容
    def show_table_context_menu(self, pos: QPoint):
        menu = RoundMenu(parent=self.table)
        has_selection = bool(self.table.selectionModel().selectedRows())

        if has_selection:
            menu.addAction(Action(FluentIcon.ADD_TO, self.tra("插入行"), triggered=self._handle_insert_row))
            menu.addAction(Action(FluentIcon.REMOVE_FROM, self.tra("删除行"), triggered=self._handle_remove_selected_rows))
            menu.addSeparator()

        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.LEAF,f"{self.tra('全部行数')}: {row_count}")
        row_count_action.setEnabled(False)
        menu.addAction(row_count_action)

        global_pos = self.table.mapToGlobal(pos)
        menu.exec_(global_pos, ani=True)

    # 删除含操作
    def _handle_remove_selected_rows(self) -> None:
        indices = self.table.selectionModel().selectedRows()
        if not indices:
            return

        rows_to_remove = sorted([index.row() for index in indices], reverse=True)

        self.table.setUpdatesEnabled(False)
        for row in rows_to_remove:
            self.table.removeRow(row)
        self.table.setUpdatesEnabled(True)

        self._reset_search()
        self._reset_sort_indicator()
        self.success_toast("", self.tra("选取行已移除") + "...")

    # 插入行操作
    def _handle_insert_row(self) -> None:
        selected_rows = {item.row() for item in self.table.selectedItems()}
        insert_pos = self.table.rowCount()
        if selected_rows:
             insert_pos = max(selected_rows) + 1

        self.table.insertRow(insert_pos)
        new_item = QTableWidgetItem("")
        self.table.setItem(insert_pos, 0, new_item)
        self.table.scrollToItem(new_item, QAbstractItemView.ScrollHint.PositionAtCenter)
        self.table.selectRow(insert_pos)
        self.table.editItem(self.table.item(insert_pos, 0))

        self._reset_sort_indicator()
        self.success_toast("", self.tra("新行已插入") + "...")

    # 添加头部布局内容
    def add_widget_head(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:
        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("prompt_dictionary_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["prompt_dictionary_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("术语表"),
                self.tra("通过构建术语表来引导模型翻译，可实现统一翻译、补充信息等功能\n△触发机制: 文本含有原名  ◯填写示例:  ダリヤ  |  达莉雅  |  女性的名字"),
                init=init,
                checked_changed=checked_changed,
            )
        )

    # 添加主题布局内容
    def add_widget_body(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:
        toolbar_widget = self._create_search_toolbar()
        parent.addWidget(toolbar_widget)
        parent.setSpacing(10)

        def item_changed(item: QTableWidgetItem) -> None:
            item.setTextAlignment(Qt.AlignCenter)

        self.table = TableWidget(self)
        parent.addWidget(self.table)

        self.table.setBorderRadius(8)
        self.table.setBorderVisible(True)
        self.table.setWordWrap(True)
        self.table.setColumnCount(len(PromptDictionaryPage.KEYS))
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_table_context_menu)
        self.table.itemChanged.connect(item_changed)

        header_labels = [self._get_translated_column_name(i) for i in range(len(PromptDictionaryPage.KEYS))]
        self.table.setHorizontalHeaderLabels(header_labels)
        self.table.setSortingEnabled(False)
        self.table.horizontalHeader().setSortIndicatorShown(True)
        self.table.horizontalHeader().sectionClicked.connect(self._sort_table_by_column)
        self.table.resizeRowsToContents()
        self._reset_sort_indicator()

    def _reset_sort_indicator(self):
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder
        if hasattr(self, 'table'):
            self.table.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

    def _sort_table_by_column(self, logicalIndex: int):
        if self._sort_column_index == logicalIndex:
            self._sort_order = Qt.DescendingOrder if self._sort_order == Qt.AscendingOrder else Qt.AscendingOrder
        else:
            self._sort_column_index = logicalIndex
            self._sort_order = Qt.AscendingOrder

        data = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
        try:
            sort_key_name = PromptDictionaryPage.KEYS[logicalIndex]
        except IndexError:
            self.logger.warning(f"Invalid column index {logicalIndex} for sorting.")
            return

        def get_sort_key(item):
            value = item.get(sort_key_name, "")
            if value is None:
                value = ""
            return str(value).lower()

        data.sort(key=get_sort_key, reverse=(self._sort_order == Qt.DescendingOrder))

        self.table.setUpdatesEnabled(False)
        self.table.setRowCount(0)
        TableHelper.update_to_table(self.table, data, PromptDictionaryPage.KEYS)
        self.table.resizeRowsToContents()
        self.table.setUpdatesEnabled(True)
        self.table.horizontalHeader().setSortIndicator(self._sort_column_index, self._sort_order)
        self._reset_search()
        self.info_toast("", self.tra("表格已按 '{}' {}排序").format(
            self._get_translated_column_name(logicalIndex),
            self.tra("升序") if self._sort_order == Qt.AscendingOrder else self.tra("降序")
        ))

    # 工具栏
    def _create_search_toolbar(self) -> QWidget:
        toolbar_widget = QWidget(self)
        layout = QHBoxLayout(toolbar_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(8)

        # 搜索输入框
        self.search_input = LineEdit(self)
        self.search_input.setPlaceholderText(self.tra("搜索表格内容..."))
        self.search_input.setClearButtonEnabled(True)
        self.search_input.textChanged.connect(self._on_search_text_changed)
        layout.addWidget(self.search_input, 1)

        # 搜索字段下拉菜单
        self.search_field_button = DropDownPushButton(self.tra("全部"), self)
        self.search_field_menu = RoundMenu(parent=self.search_field_button)
        all_action = Action(self.tra("全部"))
        all_action.triggered.connect(lambda: self._set_search_field(-1, self.tra("全部")))
        self.search_field_menu.addAction(all_action)
        self.search_field_menu.addSeparator()
        for i, key in enumerate(PromptDictionaryPage.KEYS):
            col_name = self._get_translated_column_name(i)
            action = Action(col_name)
            action.triggered.connect(lambda checked=False, index=i, name=col_name: self._set_search_field(index, name))
            self.search_field_menu.addAction(action)
        self.search_field_button.setMenu(self.search_field_menu)
        layout.addWidget(self.search_field_button)

        # 搜索结果标签
        self.search_results_label = BodyLabel("", self)
        layout.addWidget(self.search_results_label)

        # 导航按钮
        self.search_prev_button = TransparentToolButton(FluentIcon.UP, self)
        self.search_prev_button.setToolTip(self.tra("上一个结果"))
        self.search_prev_button.clicked.connect(self._navigate_previous)
        self.search_prev_button.setEnabled(False)
        layout.addWidget(self.search_prev_button)

        self.search_next_button = TransparentToolButton(FluentIcon.DOWN, self)
        self.search_next_button.setToolTip(self.tra("下一个结果"))
        self.search_next_button.clicked.connect(self._navigate_next)
        self.search_next_button.setEnabled(False)
        layout.addWidget(self.search_next_button)

        layout.addStretch(1) # 将后续按钮推到右侧

        # --- 主操作按钮组 ---
        self.main_action_buttons_widget = QWidget(self)
        main_action_layout = QHBoxLayout(self.main_action_buttons_widget)
        main_action_layout.setContentsMargins(0,0,0,0)
        main_action_layout.setSpacing(8)

        self.save_button = ToolButton(FluentIcon.SAVE, self)
        self.save_button.setToolTip(self.tra("保存"))
        self.save_button.clicked.connect(self.save_data)
        main_action_layout.addWidget(self.save_button)

        self.reset_button = ToolButton(FluentIcon.DELETE, self)
        self.reset_button.setToolTip(self.tra("重置"))
        self.reset_button.clicked.connect(self.reset_data)
        main_action_layout.addWidget(self.reset_button)

        self.import_button = ToolButton(FluentIcon.DOWNLOAD, self)
        self.import_button.setToolTip(self.tra("导入"))
        self.import_button.clicked.connect(self.import_data)
        main_action_layout.addWidget(self.import_button)

        self.export_button = ToolButton(FluentIcon.SHARE, self)
        self.export_button.setToolTip(self.tra("导出"))
        self.export_button.clicked.connect(self.export_data)
        main_action_layout.addWidget(self.export_button)
        layout.addWidget(self.main_action_buttons_widget)

        # --- 副操作按钮组 (角色提取和简单翻译) ---
        self.secondary_action_buttons_widget = QWidget(self)
        secondary_action_layout = QHBoxLayout(self.secondary_action_buttons_widget)
        secondary_action_layout.setContentsMargins(0,0,0,0)
        secondary_action_layout.setSpacing(8)

        self.name_extractor_button = TransparentPushButton(FluentIcon.PEOPLE,self.tra("角色提取"), self)
        self.name_extractor_button.clicked.connect(self.name_extractor)
        secondary_action_layout.addWidget(self.name_extractor_button)

        self.glossary_translation_button = TransparentPushButton(FluentIcon.SEND_FILL,self.tra("简单翻译"), self)
        self.glossary_translation_button.clicked.connect(self.glossary_translation)
        secondary_action_layout.addWidget(self.glossary_translation_button)
        layout.addWidget(self.secondary_action_buttons_widget)
        self.secondary_action_buttons_widget.setVisible(False) # 初始隐藏

        # --- 工具栏切换按钮 ---
        self.toggle_toolbar_button = TransparentToolButton(FluentIcon.MORE, self)
        #self.toggle_toolbar_button.setToolTip(self.tra("切换到副工具栏"))
        self.toggle_toolbar_button.clicked.connect(self._toggle_toolbar_view)
        layout.addWidget(self.toggle_toolbar_button)

        return toolbar_widget

    # 切换工具栏视图
    def _toggle_toolbar_view(self):
        self._secondary_toolbar_visible = not self._secondary_toolbar_visible
        if self._secondary_toolbar_visible:
            self.main_action_buttons_widget.setVisible(False)
            self.secondary_action_buttons_widget.setVisible(True)
            self.toggle_toolbar_button.setIcon(FluentIcon.MENU) 
            #self.toggle_toolbar_button.setToolTip(self.tra("切换回主工具栏"))
        else:
            self.main_action_buttons_widget.setVisible(True)
            self.secondary_action_buttons_widget.setVisible(False)
            self.toggle_toolbar_button.setIcon(FluentIcon.MORE)
            #self.toggle_toolbar_button.setToolTip(self.tra("切换到副工具栏"))

    # 设置搜索字段
    def _set_search_field(self, field_index: int, field_name: str):
        self.search_field_button.setText(field_name)
        if self._current_search_field_index != field_index:
            self._current_search_field_index = field_index
            self._perform_search()

    # 搜索逻辑方法
    def _on_search_text_changed(self, text: str):
        if not text.strip():
             self._reset_search_results()
             self._update_search_ui()
             self.table.clearSelection()
        self._search_timer.start()

    # 重置搜索结果
    def _reset_search_results(self):
        self._search_results = []
        self._current_search_index = -1

    # 重置搜索状态
    def _reset_search(self):
        """重置搜索状态，但不影响排序状态。"""
        self._reset_search_results()
        if hasattr(self, 'search_input'):
            self.search_input.clear()
            self._current_search_field_index = -1
            if hasattr(self, 'search_field_button'): 
                 self.search_field_button.setText(self.tra("全部"))
            self._update_search_ui()
            if hasattr(self, 'table'): 
                 self.table.clearSelection()

    # 执行搜索
    def _perform_search(self):
        search_text = self.search_input.text().strip().lower()
        self._reset_search_results() # 清除之前的搜索结果

        if not search_text:
            self._update_search_ui()
            if hasattr(self, 'table'): self.table.clearSelection() 
            return

        target_col = self._current_search_field_index
        rows = self.table.rowCount()
        cols = self.table.columnCount()

        for r in range(rows):
            columns_to_search = range(cols) if target_col == -1 else [target_col]
            for c in columns_to_search:
                 # 确保列索引有效
                if c >= cols: continue 
                item = self.table.item(r, c)
                if item and search_text in item.text().lower():
                    self._search_results.append((r, c))
                    if target_col != -1: # 如果搜索特定列，则停止检查此行中的其他列
                         break

        # 如果搜索“全部”导致每行有多个匹配项，则删除重复行
        if target_col == -1:
            unique_results = []
            seen_rows = set()
            for r, c in self._search_results:
                if r not in seen_rows:
                    unique_results.append((r, c)) # 保留该行的第一个列匹配项
                    seen_rows.add(r)
            self._search_results = unique_results


        if self._search_results:
            self._navigate_search_result(0) # 转到第一个结果
        else:
            self._update_search_ui() # 更新UI以显示“0/0”
            if hasattr(self, 'table'): self.table.clearSelection() 

    # 更新搜索UI
    def _update_search_ui(self):
        count = len(self._search_results)
        if count > 0:
            label_text = f"{self._current_search_index + 1}/{count}"
        else:
            # 仅当有搜索文本时显示0/0，否则清除标签
            if hasattr(self, 'search_input') and self.search_input.text().strip(): 
                label_text = "0/0"
            else:
                label_text = "" # 如果没有搜索文本则清除

        if hasattr(self, 'search_results_label'): self.search_results_label.setText(label_text) 

        # 启用/禁用导航按钮
        can_navigate = count > 1
        if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(can_navigate and self._current_search_index > 0) 
        if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(can_navigate and self._current_search_index < count - 1) 
        # 如果只有一个结果，则禁用两个按钮
        if count <= 1:
            if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(False) 
            if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(False) 

    # 导航上一个结果
    def _navigate_previous(self):
        if self._search_results and self._current_search_index > 0:
            self._navigate_search_result(self._current_search_index - 1)

    # 导航下一个结果
    def _navigate_next(self):
        if self._search_results and self._current_search_index < len(self._search_results) - 1:
            self._navigate_search_result(self._current_search_index + 1)

    # 导航到搜索结果
    def _navigate_search_result(self, index: int):
        if not self._search_results or not (0 <= index < len(self._search_results)):
            return

        self._current_search_index = index
        row, col = self._search_results[index]

        # 确保行/列仍然有效
        if hasattr(self, 'table') and row < self.table.rowCount() and col < self.table.columnCount(): 
            item_to_select = self.table.item(row, 0) 
            if item_to_select:
                self.table.clearSelection() # 首先清除之前的选择
                self.table.setCurrentCell(row, col) # 选择特定的单元格
                self.table.selectRow(row) # 选择包含结果的整行
                self.table.scrollToItem(item_to_select, QAbstractItemView.ScrollHint.PositionAtCenter) # 平滑滚动

        self._update_search_ui() # 更新标签和按钮状态

    # 保存方法
    def save_data(self) -> None:
        config = self.load_config()
        config["prompt_dictionary_data"] = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
        self.save_config(config)
        self.success_toast("", self.tra("数据已保存") + " ... ")

    # 重置方法
    def reset_data(self) -> None:
        info_cont1 = self.tra("是否确认重置为默认数据") + " ... ？"
        message_box = MessageBox(self.tra("警告"), info_cont1, self.window())
        message_box.yesButton.setText(self.tra("确认"))
        message_box.cancelButton.setText(self.tra("取消"))

        if not message_box.exec():
            return

        self.table.setRowCount(0)
        config = self.load_config()
        config["prompt_dictionary_data"] = copy.deepcopy(self.default.get("prompt_dictionary_data", []))
        self.save_config(config)
        TableHelper.update_to_table(self.table, config.get("prompt_dictionary_data"), PromptDictionaryPage.KEYS)
        self.table.resizeRowsToContents()
        self._reset_search() # 重置后重置搜索
        self._reset_sort_indicator() # 重置后重置排序
        self.success_toast("", self.tra("数据已重置") + " ... ")

    # 导入方法
    def import_data(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, self.tra("选择文件"), "", "json 文件 (*.json);;xlsx 文件 (*.xlsx)")
        if not isinstance(path, str) or path == "":
            return
        data = TableHelper.load_from_file(path, PromptDictionaryPage.KEYS)
        config = self.load_config()

        # 去重逻辑
        current_data = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
        current_src_set = {item['src'] for item in current_data if item.get('src')} # 处理潜在的空 src
        new_data_filtered = [item for item in data if item.get('src') and item['src'] not in current_src_set] # 确保导入的项目具有 src

        if not new_data_filtered and data: # 如果所有导入的项目都已存在，则通知
            self.info_toast(self.tra("信息"), self.tra("导入的数据项均已存在于当前表格中"))
            return
        elif not new_data_filtered and not data: # 如果文件为空或格式无效，则通知
            self.warning_toast(self.tra("警告"), self.tra("未从文件中加载到有效数据"))
            return

        # 更新并保存
        # 合并现有数据（来自表格状态）+ 新的已过滤数据
        combined_data = current_data + new_data_filtered
        config["prompt_dictionary_data"] = combined_data # 直接更新配置

        # 在再次从表格保存配置*之前*更新表格
        TableHelper.update_to_table(self.table, config["prompt_dictionary_data"], PromptDictionaryPage.KEYS)
        self.table.resizeRowsToContents() # 导入后调整行高

        # 现在将可能已修改的表格状态保存回配置
        config["prompt_dictionary_data"] = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
        self.save_config(config)
        self._reset_search() # 导入后重置搜索
        self._reset_sort_indicator() # 导入后重置排序
        self.success_toast("", self.tra("数据已导入并更新") + f" ({len(new_data_filtered)} {self.tra('项')})...")

    # 导出方法
    def export_data(self) -> None:
        data = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
        if not data:
            self.warning_toast("", self.tra("表格中没有数据可导出"))
            return

        default_filename = self.tra("导出_术语表")

        
        file_filter = "JSON 文件 (*.json);;XLSX 文件 (*.xlsx)"
        path, selected_filter = QFileDialog.getSaveFileName(
            self, self.tra("导出文件"), default_filename, file_filter
        )

        if not path:
            return

        # 根据选择的过滤器确保文件扩展名正确
        if "(*.xlsx)" in selected_filter and not path.lower().endswith(".xlsx"):
            path += ".xlsx"
        elif "(*.json)" in selected_filter and not path.lower().endswith(".json"):
            path += ".json"

        try:
            if path.lower().endswith(".json"):
                with open(path, "w", encoding="utf-8") as writer:
                    writer.write(json.dumps(data, indent=4, ensure_ascii=False))
            elif path.lower().endswith(".xlsx"):
                # 使用 pandas 将数据转换为 DataFrame
                df = pandas.DataFrame(data)
                # 使用 reindex 确保所有列都存在且顺序正确
                df = df.reindex(columns=list(self.KEYS), fill_value="")
                # 将列名重命名为用户友好的译文
                df.columns = [self._get_translated_column_name(i) for i in range(len(self.KEYS))]
                # 将 DataFrame 导出到 Excel 文件，不包含索引列
                df.to_excel(path, index=False)
            else:
                self.error_toast(self.tra("导出失败"), self.tra("不支持的文件类型。请选择 .json 或 .xlsx"))
                return

            self.success_toast("", self.tra("数据已导出到") + f": {path}")

        except Exception as e:
            self.logger.error(f"Failed to export data to {path}: {e}", exc_info=True)
            self.error_toast(self.tra("导出失败"), str(e))


    # 角色提取方法
    def name_extractor(self) -> None:
        path = QFileDialog.getExistingDirectory(self, self.tra("选择文件夹"), "")
        if not path:
            return

        try:
            data = NameExtractor.extract_names_from_folder(self, path)
            if not data:
                self.info_toast(self.tra("信息"), self.tra("在指定文件夹中未找到符合条件的角色名"))
                return

            config = self.load_config()
            current_data = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
            current_src_set = {item['src'] for item in current_data if item.get('src')}
            new_data_filtered = [item for item in data if item.get('src') and item['src'] not in current_src_set]

            if not new_data_filtered:
                self.info_toast(self.tra("信息"), self.tra("均已存在于术语表中"))
                return

            combined_data = current_data + new_data_filtered
            config["prompt_dictionary_data"] = combined_data

            TableHelper.update_to_table(self.table, config["prompt_dictionary_data"], PromptDictionaryPage.KEYS)
            self.table.resizeRowsToContents()

            config["prompt_dictionary_data"] = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
            self.save_config(config)
            self._reset_search()
            self._reset_sort_indicator()
            self.success_toast("", self.tra("术语信息已提取并添加") + f" ({len(new_data_filtered)} {self.tra('项')})...")

        except Exception as e:
            self.error_toast(self.tra("提取失败"), str(e))
            self.logger.error(f"Name extraction failed: {e}", exc_info=True)

    # 简单翻译方法
    def glossary_translation(self) -> None:
        if Base.work_status == Base.STATUS.IDLE:
            Base.work_status = Base.STATUS.GLOSS_TASK
            data = {}
            data["prompt_dictionary_data"] = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)

            if not any(item.get('src') and not item.get('dst') for item in data["prompt_dictionary_data"]):
                    self.info_toast(self.tra("提示"), self.tra("没有需要翻译的术语"))
                    Base.work_status = Base.STATUS.IDLE
                    return

            self.emit(Base.EVENT.GLOSS_TASK_START, data)
            self.info_toast(self.tra("提示"), self.tra("术语表翻译任务已开始..."))
        else:
            self.warning_toast("", self.tra("软件正在执行其他任务中，请稍后再试"))

    # 简单翻译完成订阅方法
    def glossary_translation_done(self, event: int, data: dict):
        Base.work_status = Base.STATUS.IDLE
        status = data.get("status")

        if status == "null":
            self.error_toast("", self.tra("术语表内容为空") + "...")
            return
        elif status == "error":
            error_msg = data.get("message", self.tra("未知错误"))
            self.error_toast(self.tra("术语表翻译失败"), error_msg + "...")
            return
        elif status == "success":
            updated_data = data.get("updated_data")
            if not updated_data:
                self.warning_toast(self.tra("完成"), self.tra("翻译完成，但没有数据被更新"))
                return

            prompt_dictionary_data_table = TableHelper.load_from_table(self.table, PromptDictionaryPage.KEYS)
            updated_map = {item['src']: item['dst'] for item in updated_data if item.get('src') and item.get('dst')}

            something_updated = False
            for i in range(len(prompt_dictionary_data_table)):
                src_text = prompt_dictionary_data_table[i].get("src")
                current_dst = prompt_dictionary_data_table[i].get("dst")
                if src_text in updated_map and (not current_dst or current_dst.strip() == ""):
                    prompt_dictionary_data_table[i]["dst"] = updated_map[src_text]
                    something_updated = True

            if something_updated:
                self.table.setUpdatesEnabled(False)
                TableHelper.update_to_table(self.table, prompt_dictionary_data_table, PromptDictionaryPage.KEYS)
                self.table.resizeRowsToContents()
                self.table.setUpdatesEnabled(True)

                config = self.load_config()
                config["prompt_dictionary_data"] = prompt_dictionary_data_table
                self.save_config(config)
                self._reset_search()
                self._reset_sort_indicator()
                self.success_toast("", self.tra("术语表翻译成功并已更新") + "...")


================================================
FILE: UserInterface/Table/TextReplaceAPage.py
================================================
import copy
import pandas
import rapidjson as json
from qfluentwidgets import (Action, FluentIcon, MessageBox, TableWidget, RoundMenu,
                            LineEdit, DropDownPushButton, ToolButton, TransparentToolButton, BodyLabel)

from PyQt5.QtCore import QEvent, Qt, QPoint, QTimer
from PyQt5.QtWidgets import (QFrame, QFileDialog, QHeaderView, QLayout, QVBoxLayout,
                             QTableWidgetItem, QHBoxLayout, QWidget,QAbstractItemView)

from Base.Base import Base
from UserInterface.TableHelper.TableHelper import TableHelper
from Widget.SwitchButtonCard import SwitchButtonCard
from UserInterface import AppFluentWindow

class TextReplaceAPage(QFrame, Base):

    KEYS = ("src", "dst", "regex",)
    COLUMN_NAMES = {0: "原文本",1: "目标文本",2: "正则",}

    def __init__(self, text: str, window: AppFluentWindow) -> None:
        super().__init__(parent=window)
        self.setObjectName(text.replace(" ", "-"))

        self.default = {
            "pre_translation_switch": False,
            "pre_translation_data": [],
        }

        # 读取配置
        config = self.save_config(self.load_config_from_default())

        # 搜索相关属性
        self._search_results = []
        self._current_search_index = -1
        self._search_timer = QTimer(self)
        self._search_timer.setSingleShot(True)
        self._search_timer.setInterval(300)
        self._search_timer.timeout.connect(self._perform_search)
        self._current_search_field_index = -1

        # 排序相关属性
        self._sort_column_index = -1  # 记录当前排序的列索引，-1表示未排序
        self._sort_order = Qt.AscendingOrder # 记录当前排序顺序

        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        self.add_widget_head(self.container, config, window)
        self.add_widget_body(self.container, config, window)

        self._reset_search()

    def _get_translated_column_name(self, index: int) -> str:
        return self.tra(self.COLUMN_NAMES.get(index, f"字段{index+1}"))

    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.update_table() # 每次显示时更新，并确保搜索/排序状态重置

    def update_table(self) -> None:
        config = self.load_config()
        TableHelper.update_to_table(self.table, config["pre_translation_data"], TextReplaceAPage.KEYS)
        self._reset_search() # 重置搜索状态
        self._reset_sort_indicator() # 重置排序指示器

    # 右键菜单
    def show_table_context_menu(self, pos: QPoint):

        menu = RoundMenu(parent=self.table)
        has_selection = bool(self.table.selectionModel().selectedRows())

        if has_selection:
            menu.addAction(Action(FluentIcon.ADD_TO, self.tra("插入行"), triggered=self._handle_insert_row))
            menu.addAction(Action(FluentIcon.REMOVE_FROM, self.tra("删除行"), triggered=self._handle_remove_selected_rows))
            menu.addSeparator()

        # 行数统计
        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.LEAF,f"{self.tra('全部行数')}: {row_count}")
        row_count_action.setEnabled(False) # 使其不可点击，仅作为信息显示
        menu.addAction(row_count_action)

        global_pos = self.table.mapToGlobal(pos)
        menu.exec_(global_pos, ani=True)

    # 处理删除选定行
    def _handle_remove_selected_rows(self) -> None:

        indices = self.table.selectionModel().selectedRows()
        if not indices:
            return

        rows_to_remove = sorted([index.row() for index in indices], reverse=True)

        self.table.setUpdatesEnabled(False)
        for row in rows_to_remove:
            self.table.removeRow(row)
        self.table.setUpdatesEnabled(True)

        self._reset_search() # 删除行后重置搜索
        self._reset_sort_indicator() # 删除行后重置排序
        self.success_toast("", self.tra("选取行已移除") + "...")

    # 处理插入行
    def _handle_insert_row(self) -> None:

        selected_rows = {item.row() for item in self.table.selectedItems()}
        insert_pos = self.table.rowCount() # 默认为末尾
        if selected_rows:
             insert_pos = max(selected_rows) + 1

        self.table.insertRow(insert_pos)
        # 滚动到新行
        new_item = QTableWidgetItem("") # 创建一个虚拟项以滚动到该位置
        self.table.setItem(insert_pos, 0, new_item) # 添加到第一列
        self.table.scrollToItem(new_item, QAbstractItemView.ScrollHint.PositionAtCenter)
        self.table.selectRow(insert_pos) # 选择新行
        self.table.editItem(self.table.item(insert_pos, 0)) # 开始编辑第一个单元格

        self._reset_sort_indicator() # 重置排序指示器
        self.success_toast("", self.tra("新行已插入") + "...")


    # 添加头部部件
    def add_widget_head(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("pre_translation_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["pre_translation_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("译前替换"),
                self.tra("在翻译开始前，将原文中匹配的部分替换为指定的文本，执行的顺序为从上到下依次替换"),
                init=init,
                checked_changed=checked_changed,
            )
        )


    # 添加主体部件
    def add_widget_body(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:
        toolbar_widget = self._create_search_toolbar()
        parent.addWidget(toolbar_widget)
        parent.setSpacing(10)

        def item_changed(item: QTableWidgetItem) -> None:
            item.setTextAlignment(Qt.AlignCenter)
            # 编辑单元格后，不一定需要立即重排序或重置搜索
            # self._reset_search()
            # self.search_input.clear()
            # self._reset_sort_indicator()
            # 后期可以添加自动保存，也可以不添加


        self.table = TableWidget(self)
        parent.addWidget(self.table)

        self.table.setBorderRadius(8)
        self.table.setBorderVisible(True)
        self.table.setWordWrap(True)
        self.table.setColumnCount(len(TextReplaceAPage.KEYS))
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_table_context_menu)

        self.table.itemChanged.connect(item_changed)

        header_labels = [self._get_translated_column_name(i) for i in range(len(TextReplaceAPage.KEYS))]
        self.table.setHorizontalHeaderLabels(header_labels)

        # 启用排序和连接信号
        self.table.setSortingEnabled(False) # 禁用内置排序
        self.table.horizontalHeader().setSortIndicatorShown(True) # 显示排序指示器空间
        self.table.horizontalHeader().sectionClicked.connect(self._sort_table_by_column) # 连接排序信号

        self.table.resizeRowsToContents() # 调整行高
        self._reset_sort_indicator() # 重置排序指示器

    # 重置排序指示器
    def _reset_sort_indicator(self):
        """清除排序状态和表头的排序指示器。"""
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder
        if hasattr(self, 'table'): 
            self.table.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

    # 排序逻辑处理函数
    def _sort_table_by_column(self, logicalIndex: int):
        """当表头被点击时，按该列对表格数据进行排序。"""
        # 1. 确定排序顺序
        if self._sort_column_index == logicalIndex:
            # 如果点击的是同一列，切换排序顺序
            self._sort_order = Qt.DescendingOrder if self._sort_order == Qt.AscendingOrder else Qt.AscendingOrder
        else:
            # 如果点击的是新列，重置为升序
            self._sort_column_index = logicalIndex
            self._sort_order = Qt.AscendingOrder

        # 2. 获取当前表格数据
        data = TableHelper.load_from_table(self.table, TextReplaceAPage.KEYS)

        # 3. 定义排序键函数
        try:
            sort_key_name = TextReplaceAPage.KEYS[logicalIndex]
        except IndexError:
            self.logger.warning(f"Invalid column index {logicalIndex} for sorting.")
            return # 无效列索引，不排序

        def get_sort_key(item):
            value = item.get(sort_key_name, "") # 获取值，默认为空字符串
            if value is None: # 处理 None 值
                value = ""
            # 尝试将值转为小写字符串进行不区分大小写的文本排序
            # 注意：如果列包含数字或需要特定类型排序，这里可能需要更复杂的逻辑
            return str(value).lower()

        # 4. 排序数据
        data.sort(key=get_sort_key, reverse=(self._sort_order == Qt.DescendingOrder))


        # 5. 清空并重新填充表格
        self.table.setUpdatesEnabled(False) # 优化性能
        self.table.setRowCount(0) # 清空表格
        TableHelper.update_to_table(self.table, data, TextReplaceAPage.KEYS)
        self.table.resizeRowsToContents() # 重新调整行高
        self.table.setUpdatesEnabled(True)

        # 6. 更新表头排序指示器
        self.table.horizontalHeader().setSortIndicator(self._sort_column_index, self._sort_order)

        # 7. 重置搜索状态，因为行顺序已改变
        self._reset_search() # 非常重要！
        self.info_toast("", self.tra("表格已按 '{}' {}排序").format(
            self._get_translated_column_name(logicalIndex),
            self.tra("升序") if self._sort_order == Qt.AscendingOrder else self.tra("降序")
        ))

    # 工具栏
    def _create_search_toolbar(self) -> QWidget:

        toolbar_widget = QWidget(self)
        layout = QHBoxLayout(toolbar_widget)
        layout.setContentsMargins(0, 0, 0, 0) # 工具栏本身无外部边距
        layout.setSpacing(8) # 工具栏项之间的间距

        # 1. 搜索输入框
        self.search_input = LineEdit(self)
        self.search_input.setPlaceholderText(self.tra("搜索表格内容..."))
        self.search_input.setClearButtonEnabled(True)
        self.search_input.textChanged.connect(self._on_search_text_changed) # 使用计时器进行防抖
        layout.addWidget(self.search_input, 1) # 拉伸输入字段

        # 2. 搜索字段下拉菜单
        self.search_field_button = DropDownPushButton(self.tra("全部"), self)
        self.search_field_menu = RoundMenu(parent=self.search_field_button)

        # "全部"字段的Action
        all_action = Action(self.tra("全部"))
        all_action.triggered.connect(lambda: self._set_search_field(-1, self.tra("全部")))
        self.search_field_menu.addAction(all_action)
        self.search_field_menu.addSeparator()

        # 特定字段的Action
        for i, key in enumerate(TextReplaceAPage.KEYS):
            col_name = self._get_translated_column_name(i)
            action = Action(col_name)
            # 使用带有默认参数捕获的lambda表达式以传递正确的索引和名称
            action.triggered.connect(lambda checked=False, index=i, name=col_name: self._set_search_field(index, name))
            self.search_field_menu.addAction(action)

        self.search_field_button.setMenu(self.search_field_menu)
        layout.addWidget(self.search_field_button)

        # 3. 搜索结果标签
        self.search_results_label = BodyLabel("", self)
        layout.addWidget(self.search_results_label)

        # 4. 导航按钮 (上/下箭头)
        self.search_prev_button = TransparentToolButton(FluentIcon.UP, self)
        self.search_prev_button.setToolTip(self.tra("上一个结果"))
        self.search_prev_button.clicked.connect(self._navigate_previous)
        self.search_prev_button.setEnabled(False) # 初始禁用
        layout.addWidget(self.search_prev_button)

        self.search_next_button = TransparentToolButton(FluentIcon.DOWN, self)
        self.search_next_button.setToolTip(self.tra("下一个结果"))
        self.search_next_button.clicked.connect(self._navigate_next)
        self.search_next_button.setEnabled(False) # 初始禁用
        layout.addWidget(self.search_next_button)

        # 5.保存重置导入导出按钮
        layout.addStretch(1) # 添加拉伸项以将按钮推到右侧
        self.save_button = ToolButton(FluentIcon.SAVE, self)
        self.save_button.setToolTip(self.tra("保存"))
        self.save_button.clicked.connect(self.save_data)
        layout.addWidget(self.save_button)

        self.reset_button = ToolButton(FluentIcon.DELETE, self)
        self.reset_button.setToolTip(self.tra("重置"))
        self.reset_button.clicked.connect(self.reset_data)
        layout.addWidget(self.reset_button)

        self.import_button = ToolButton(FluentIcon.DOWNLOAD, self)
        self.import_button.setToolTip(self.tra("导入"))
        self.import_button.clicked.connect(self.import_data)
        layout.addWidget(self.import_button)

        self.export_button = ToolButton(FluentIcon.SHARE, self)
        self.export_button.setToolTip(self.tra("导出"))
        self.export_button.clicked.connect(self.export_data)
        layout.addWidget(self.export_button)

        return toolbar_widget

    # 设置搜索字段
    def _set_search_field(self, field_index: int, field_name: str):
        
        self.search_field_button.setText(field_name)
        if self._current_search_field_index != field_index:
            self._current_search_field_index = field_index
            self._perform_search()

    # 搜索逻辑方法
    def _on_search_text_changed(self, text: str):
        
        if not text.strip():
             self._reset_search_results()
             self._update_search_ui()
             self.table.clearSelection()
        self._search_timer.start()

    # 重置搜索结果
    def _reset_search_results(self):
        self._search_results = []
        self._current_search_index = -1

    # 重置搜索状态
    def _reset_search(self):
        """重置搜索状态，但不影响排序状态。"""
        self._reset_search_results()
        if hasattr(self, 'search_input'):
            self.search_input.clear()
            self._current_search_field_index = -1
            if hasattr(self, 'search_field_button'): 
                 self.search_field_button.setText(self.tra("全部"))
            self._update_search_ui()
            if hasattr(self, 'table'): 
                 self.table.clearSelection()

    # 执行搜索
    def _perform_search(self):

        search_text = self.search_input.text().strip().lower()
        self._reset_search_results() # 清除之前的搜索结果

        if not search_text:
            self._update_search_ui()
            if hasattr(self, 'table'): self.table.clearSelection() 
            return

        target_col = self._current_search_field_index
        rows = self.table.rowCount()
        cols = self.table.columnCount()

        for r in range(rows):
            columns_to_search = range(cols) if target_col == -1 else [target_col]
            for c in columns_to_search:
                 # 确保列索引有效
                if c >= cols: continue 
                item = self.table.item(r, c)
                if item and search_text in item.text().lower():
                    self._search_results.append((r, c))
                    if target_col != -1: # 如果搜索特定列，则停止检查此行中的其他列
                         break

        # 如果搜索“全部”导致每行有多个匹配项，则删除重复行
        if target_col == -1:
            unique_results = []
            seen_rows = set()
            for r, c in self._search_results:
                if r not in seen_rows:
                    unique_results.append((r, c)) # 保留该行的第一个列匹配项
                    seen_rows.add(r)
            self._search_results = unique_results


        if self._search_results:
            self._navigate_search_result(0) # 转到第一个结果
        else:
            self._update_search_ui() # 更新UI以显示“0/0”
            if hasattr(self, 'table'): self.table.clearSelection() 

    # 更新搜索UI
    def _update_search_ui(self):

        count = len(self._search_results)
        if count > 0:
            label_text = f"{self._current_search_index + 1}/{count}"
        else:
            # 仅当有搜索文本时显示0/0，否则清除标签
            if hasattr(self, 'search_input') and self.search_input.text().strip(): 
                label_text = "0/0"
            else:
                label_text = "" # 如果没有搜索文本则清除

        if hasattr(self, 'search_results_label'): self.search_results_label.setText(label_text) 

        # 启用/禁用导航按钮
        can_navigate = count > 1
        if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(can_navigate and self._current_search_index > 0) 
        if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(can_navigate and self._current_search_index < count - 1) 
        # 如果只有一个结果，则禁用两个按钮
        if count <= 1:
            if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(False) 
            if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(False) 

    # 导航上一个结果
    def _navigate_previous(self):

        if self._search_results and self._current_search_index > 0:
            self._navigate_search_result(self._current_search_index - 1)

    # 导航下一个结果
    def _navigate_next(self):

        if self._search_results and self._current_search_index < len(self._search_results) - 1:
            self._navigate_search_result(self._current_search_index + 1)

    # 导航到搜索结果
    def _navigate_search_result(self, index: int):

        if not self._search_results or not (0 <= index < len(self._search_results)):
            return

        self._current_search_index = index
        row, col = self._search_results[index]

        # 确保行/列仍然有效
        if hasattr(self, 'table') and row < self.table.rowCount() and col < self.table.columnCount(): 
            item_to_select = self.table.item(row, 0) 
            if item_to_select:
                self.table.clearSelection() # 首先清除之前的选择
                self.table.setCurrentCell(row, col) # 选择特定的单元格
                self.table.selectRow(row) # 选择包含结果的整行
                self.table.scrollToItem(item_to_select, QAbstractItemView.ScrollHint.PositionAtCenter) # 平滑滚动

        self._update_search_ui() # 更新标签和按钮状态

    # 保存方法
    def save_data(self) -> None:
        config = self.load_config()
        config["pre_translation_data"] = TableHelper.load_from_table(self.table, TextReplaceAPage.KEYS)
        self.save_config(config)
        self.success_toast("", self.tra("数据已保存") + " ... ")

    # 重置方法
    def reset_data(self) -> None:
        info_cont1 = self.tra("是否确认重置为默认数据") + " ... ？"
        message_box = MessageBox(self.tra("警告"), info_cont1, self.window())
        message_box.yesButton.setText(self.tra("确认"))
        message_box.cancelButton.setText(self.tra("取消"))

        if not message_box.exec():
            return

        self.table.setRowCount(0)
        config = self.load_config()
        config["pre_translation_data"] = copy.deepcopy(self.default.get("pre_translation_data", []))
        self.save_config(config)
        TableHelper.update_to_table(self.table, config.get("pre_translation_data"), TextReplaceAPage.KEYS)
        self.table.resizeRowsToContents()
        self._reset_search() # 重置后重置搜索
        self._reset_sort_indicator() # 重置后重置排序
        self.success_toast("", self.tra("数据已重置") + " ... ")

    # 导入方法
    def import_data(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, self.tra("选择文件"), "", "json 文件 (*.json);;xlsx 文件 (*.xlsx)")
        if not isinstance(path, str) or path == "":
            return
        data = TableHelper.load_from_file(path, TextReplaceAPage.KEYS)
        config = self.load_config()

        # 去重逻辑
        current_data = TableHelper.load_from_table(self.table, TextReplaceAPage.KEYS)
        current_src_set = {item['src'] for item in current_data if item.get('src')} # 处理潜在的空 src
        new_data_filtered = [item for item in data if item.get('src') and item['src'] not in current_src_set] # 确保导入的项目具有 src

        if not new_data_filtered and data: # 如果所有导入的项目都已存在，则通知
            self.info_toast(self.tra("信息"), self.tra("导入的数据项均已存在于当前表格中"))
            return
        elif not new_data_filtered and not data: # 如果文件为空或格式无效，则通知
            self.warning_toast(self.tra("警告"), self.tra("未从文件中加载到有效数据"))
            return

        # 更新并保存
        # 合并现有数据（来自表格状态）+ 新的已过滤数据
        combined_data = current_data + new_data_filtered
        config["pre_translation_data"] = combined_data # 直接更新配置

        # 在再次从表格保存配置*之前*更新表格
        TableHelper.update_to_table(self.table, config["pre_translation_data"], TextReplaceAPage.KEYS)
        self.table.resizeRowsToContents() # 导入后调整行高

        # 现在将可能已修改的表格状态保存回配置
        config["pre_translation_data"] = TableHelper.load_from_table(self.table, TextReplaceAPage.KEYS)
        self.save_config(config)
        self._reset_search() # 导入后重置搜索
        self._reset_sort_indicator() # 导入后重置排序
        self.success_toast("", self.tra("数据已导入并更新") + f" ({len(new_data_filtered)} {self.tra('项')})...")

    # 导出方法
    def export_data(self) -> None:
        data = TableHelper.load_from_table(self.table, TextReplaceAPage.KEYS)
        if not data:
            self.warning_toast("", self.tra("表格中没有数据可导出"))
            return

        default_filename = self.tra("导出_术语表")

        
        file_filter = "JSON 文件 (*.json);;XLSX 文件 (*.xlsx)"
        path, selected_filter = QFileDialog.getSaveFileName(
            self, self.tra("导出文件"), default_filename, file_filter
        )

        if not path:
            return

        # 根据选择的过滤器确保文件扩展名正确
        if "(*.xlsx)" in selected_filter and not path.lower().endswith(".xlsx"):
            path += ".xlsx"
        elif "(*.json)" in selected_filter and not path.lower().endswith(".json"):
            path += ".json"

        try:
            if path.lower().endswith(".json"):
                with open(path, "w", encoding="utf-8") as writer:
                    writer.write(json.dumps(data, indent=4, ensure_ascii=False))
            elif path.lower().endswith(".xlsx"):
                # 使用 pandas 将数据转换为 DataFrame
                df = pandas.DataFrame(data)
                # 使用 reindex 确保所有列都存在且顺序正确
                df = df.reindex(columns=list(self.KEYS), fill_value="")
                # 将列名重命名为用户友好的译文
                df.columns = [self._get_translated_column_name(i) for i in range(len(self.KEYS))]
                # 将 DataFrame 导出到 Excel 文件，不包含索引列
                df.to_excel(path, index=False)
            else:
                self.error_toast(self.tra("导出失败"), self.tra("不支持的文件类型。请选择 .json 或 .xlsx"))
                return

            self.success_toast("", self.tra("数据已导出到") + f": {path}")

        except Exception as e:
            self.logger.error(f"Failed to export data to {path}: {e}", exc_info=True)
            self.error_toast(self.tra("导出失败"), str(e))





================================================
FILE: UserInterface/Table/TextReplaceBPage.py
================================================
import copy
import pandas
import rapidjson as json
from qfluentwidgets import (Action, FluentIcon, MessageBox, TableWidget, RoundMenu,
                            LineEdit, DropDownPushButton, ToolButton, TransparentToolButton, BodyLabel)

from PyQt5.QtCore import QEvent, Qt, QPoint, QTimer
from PyQt5.QtWidgets import (QFrame, QFileDialog, QHeaderView, QLayout, QVBoxLayout,
                             QTableWidgetItem, QHBoxLayout, QWidget,QAbstractItemView)

from Base.Base import Base
from UserInterface.TableHelper.TableHelper import TableHelper
from Widget.SwitchButtonCard import SwitchButtonCard
from UserInterface import AppFluentWindow

class TextReplaceBPage(QFrame, Base):

    KEYS = ("src", "dst", "regex",)
    COLUMN_NAMES = {0: "原文本",1: "目标文本",2: "正则",}

    def __init__(self, text: str, window: AppFluentWindow) -> None:
        super().__init__(parent=window)
        self.setObjectName(text.replace(" ", "-"))

        self.default = {
            "post_translation_switch": False,
            "post_translation_data": [],
        }

        # 读取配置
        config = self.save_config(self.load_config_from_default())

        # 搜索相关属性
        self._search_results = []
        self._current_search_index = -1
        self._search_timer = QTimer(self)
        self._search_timer.setSingleShot(True)
        self._search_timer.setInterval(300)
        self._search_timer.timeout.connect(self._perform_search)
        self._current_search_field_index = -1

        # 排序相关属性
        self._sort_column_index = -1  # 记录当前排序的列索引，-1表示未排序
        self._sort_order = Qt.AscendingOrder # 记录当前排序顺序

        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        self.add_widget_head(self.container, config, window)
        self.add_widget_body(self.container, config, window)

        self._reset_search()

    def _get_translated_column_name(self, index: int) -> str:
        return self.tra(self.COLUMN_NAMES.get(index, f"字段{index+1}"))

    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.update_table() # 每次显示时更新，并确保搜索/排序状态重置

    def update_table(self) -> None:
        config = self.load_config()
        TableHelper.update_to_table(self.table, config["post_translation_data"], TextReplaceBPage.KEYS)
        self._reset_search() # 重置搜索状态
        self._reset_sort_indicator() # 重置排序指示器

    # 右键菜单
    def show_table_context_menu(self, pos: QPoint):

        menu = RoundMenu(parent=self.table)
        has_selection = bool(self.table.selectionModel().selectedRows())

        if has_selection:
            menu.addAction(Action(FluentIcon.ADD_TO, self.tra("插入行"), triggered=self._handle_insert_row))
            menu.addAction(Action(FluentIcon.REMOVE_FROM, self.tra("删除行"), triggered=self._handle_remove_selected_rows))
            menu.addSeparator()

        # 行数统计
        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.LEAF,f"{self.tra('全部行数')}: {row_count}")
        row_count_action.setEnabled(False) # 使其不可点击，仅作为信息显示
        menu.addAction(row_count_action)

        global_pos = self.table.mapToGlobal(pos)
        menu.exec_(global_pos, ani=True)

    # 处理删除选定行
    def _handle_remove_selected_rows(self) -> None:

        indices = self.table.selectionModel().selectedRows()
        if not indices:
            return

        rows_to_remove = sorted([index.row() for index in indices], reverse=True)

        self.table.setUpdatesEnabled(False)
        for row in rows_to_remove:
            self.table.removeRow(row)
        self.table.setUpdatesEnabled(True)

        self._reset_search() # 删除行后重置搜索
        self._reset_sort_indicator() # 删除行后重置排序
        self.success_toast("", self.tra("选取行已移除") + "...")

    # 处理插入行
    def _handle_insert_row(self) -> None:

        selected_rows = {item.row() for item in self.table.selectedItems()}
        insert_pos = self.table.rowCount() # 默认为末尾
        if selected_rows:
             insert_pos = max(selected_rows) + 1

        self.table.insertRow(insert_pos)
        # 滚动到新行
        new_item = QTableWidgetItem("") # 创建一个虚拟项以滚动到该位置
        self.table.setItem(insert_pos, 0, new_item) # 添加到第一列
        self.table.scrollToItem(new_item, QAbstractItemView.ScrollHint.PositionAtCenter)
        self.table.selectRow(insert_pos) # 选择新行
        self.table.editItem(self.table.item(insert_pos, 0)) # 开始编辑第一个单元格

        self._reset_sort_indicator() # 重置排序指示器
        self.success_toast("", self.tra("新行已插入") + "...")


    # 添加头部部件
    def add_widget_head(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("post_translation_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["post_translation_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("译后替换"),
                self.tra("在翻译完成后，将译文中匹配的部分替换为指定的文本，执行的顺序为从上到下依次替换"),
                init=init,
                checked_changed=checked_changed,
            )
        )


    # 添加主体部件
    def add_widget_body(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:
        toolbar_widget = self._create_search_toolbar()
        parent.addWidget(toolbar_widget)
        parent.setSpacing(10)

        def item_changed(item: QTableWidgetItem) -> None:
            item.setTextAlignment(Qt.AlignCenter)
            # 编辑单元格后，不一定需要立即重排序或重置搜索
            # self._reset_search()
            # self.search_input.clear()
            # self._reset_sort_indicator()
            # 后期可以添加自动保存，也可以不添加


        self.table = TableWidget(self)
        parent.addWidget(self.table)

        self.table.setBorderRadius(8)
        self.table.setBorderVisible(True)
        self.table.setWordWrap(True)
        self.table.setColumnCount(len(TextReplaceBPage.KEYS))
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_table_context_menu)

        self.table.itemChanged.connect(item_changed)

        header_labels = [self._get_translated_column_name(i) for i in range(len(TextReplaceBPage.KEYS))]
        self.table.setHorizontalHeaderLabels(header_labels)

        # 启用排序和连接信号
        self.table.setSortingEnabled(False) # 禁用内置排序
        self.table.horizontalHeader().setSortIndicatorShown(True) # 显示排序指示器空间
        self.table.horizontalHeader().sectionClicked.connect(self._sort_table_by_column) # 连接排序信号

        self.table.resizeRowsToContents() # 调整行高
        self._reset_sort_indicator() # 重置排序指示器

    # 重置排序指示器
    def _reset_sort_indicator(self):
        """清除排序状态和表头的排序指示器。"""
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder
        if hasattr(self, 'table'): 
            self.table.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

    # 排序逻辑处理函数
    def _sort_table_by_column(self, logicalIndex: int):
        """当表头被点击时，按该列对表格数据进行排序。"""
        # 1. 确定排序顺序
        if self._sort_column_index == logicalIndex:
            # 如果点击的是同一列，切换排序顺序
            self._sort_order = Qt.DescendingOrder if self._sort_order == Qt.AscendingOrder else Qt.AscendingOrder
        else:
            # 如果点击的是新列，重置为升序
            self._sort_column_index = logicalIndex
            self._sort_order = Qt.AscendingOrder

        # 2. 获取当前表格数据
        data = TableHelper.load_from_table(self.table, TextReplaceBPage.KEYS)

        # 3. 定义排序键函数
        try:
            sort_key_name = TextReplaceBPage.KEYS[logicalIndex]
        except IndexError:
            self.logger.warning(f"Invalid column index {logicalIndex} for sorting.")
            return # 无效列索引，不排序

        def get_sort_key(item):
            value = item.get(sort_key_name, "") # 获取值，默认为空字符串
            if value is None: # 处理 None 值
                value = ""
            # 尝试将值转为小写字符串进行不区分大小写的文本排序
            # 注意：如果列包含数字或需要特定类型排序，这里可能需要更复杂的逻辑
            return str(value).lower()

        # 4. 排序数据
        data.sort(key=get_sort_key, reverse=(self._sort_order == Qt.DescendingOrder))


        # 5. 清空并重新填充表格
        self.table.setUpdatesEnabled(False) # 优化性能
        self.table.setRowCount(0) # 清空表格
        TableHelper.update_to_table(self.table, data, TextReplaceBPage.KEYS)
        self.table.resizeRowsToContents() # 重新调整行高
        self.table.setUpdatesEnabled(True)

        # 6. 更新表头排序指示器
        self.table.horizontalHeader().setSortIndicator(self._sort_column_index, self._sort_order)

        # 7. 重置搜索状态，因为行顺序已改变
        self._reset_search() # 非常重要！
        self.info_toast("", self.tra("表格已按 '{}' {}排序").format(
            self._get_translated_column_name(logicalIndex),
            self.tra("升序") if self._sort_order == Qt.AscendingOrder else self.tra("降序")
        ))

    # 工具栏
    def _create_search_toolbar(self) -> QWidget:

        toolbar_widget = QWidget(self)
        layout = QHBoxLayout(toolbar_widget)
        layout.setContentsMargins(0, 0, 0, 0) # 工具栏本身无外部边距
        layout.setSpacing(8) # 工具栏项之间的间距

        # 1. 搜索输入框
        self.search_input = LineEdit(self)
        self.search_input.setPlaceholderText(self.tra("搜索表格内容..."))
        self.search_input.setClearButtonEnabled(True)
        self.search_input.textChanged.connect(self._on_search_text_changed) # 使用计时器进行防抖
        layout.addWidget(self.search_input, 1) # 拉伸输入字段

        # 2. 搜索字段下拉菜单
        self.search_field_button = DropDownPushButton(self.tra("全部"), self)
        self.search_field_menu = RoundMenu(parent=self.search_field_button)

        # "全部"字段的Action
        all_action = Action(self.tra("全部"))
        all_action.triggered.connect(lambda: self._set_search_field(-1, self.tra("全部")))
        self.search_field_menu.addAction(all_action)
        self.search_field_menu.addSeparator()

        # 特定字段的Action
        for i, key in enumerate(TextReplaceBPage.KEYS):
            col_name = self._get_translated_column_name(i)
            action = Action(col_name)
            # 使用带有默认参数捕获的lambda表达式以传递正确的索引和名称
            action.triggered.connect(lambda checked=False, index=i, name=col_name: self._set_search_field(index, name))
            self.search_field_menu.addAction(action)

        self.search_field_button.setMenu(self.search_field_menu)
        layout.addWidget(self.search_field_button)

        # 3. 搜索结果标签
        self.search_results_label = BodyLabel("", self)
        layout.addWidget(self.search_results_label)

        # 4. 导航按钮 (上/下箭头)
        self.search_prev_button = TransparentToolButton(FluentIcon.UP, self)
        self.search_prev_button.setToolTip(self.tra("上一个结果"))
        self.search_prev_button.clicked.connect(self._navigate_previous)
        self.search_prev_button.setEnabled(False) # 初始禁用
        layout.addWidget(self.search_prev_button)

        self.search_next_button = TransparentToolButton(FluentIcon.DOWN, self)
        self.search_next_button.setToolTip(self.tra("下一个结果"))
        self.search_next_button.clicked.connect(self._navigate_next)
        self.search_next_button.setEnabled(False) # 初始禁用
        layout.addWidget(self.search_next_button)

        # 5.保存重置导入导出按钮
        layout.addStretch(1) # 添加拉伸项以将按钮推到右侧
        self.save_button = ToolButton(FluentIcon.SAVE, self)
        self.save_button.setToolTip(self.tra("保存"))
        self.save_button.clicked.connect(self.save_data)
        layout.addWidget(self.save_button)

        self.reset_button = ToolButton(FluentIcon.DELETE, self)
        self.reset_button.setToolTip(self.tra("重置"))
        self.reset_button.clicked.connect(self.reset_data)
        layout.addWidget(self.reset_button)

        self.import_button = ToolButton(FluentIcon.DOWNLOAD, self)
        self.import_button.setToolTip(self.tra("导入"))
        self.import_button.clicked.connect(self.import_data)
        layout.addWidget(self.import_button)

        self.export_button = ToolButton(FluentIcon.SHARE, self)
        self.export_button.setToolTip(self.tra("导出"))
        self.export_button.clicked.connect(self.export_data)
        layout.addWidget(self.export_button)

        return toolbar_widget

    # 设置搜索字段
    def _set_search_field(self, field_index: int, field_name: str):
        
        self.search_field_button.setText(field_name)
        if self._current_search_field_index != field_index:
            self._current_search_field_index = field_index
            self._perform_search()

    # 搜索逻辑方法
    def _on_search_text_changed(self, text: str):
        
        if not text.strip():
             self._reset_search_results()
             self._update_search_ui()
             self.table.clearSelection()
        self._search_timer.start()

    # 重置搜索结果
    def _reset_search_results(self):
        self._search_results = []
        self._current_search_index = -1

    # 重置搜索状态
    def _reset_search(self):
        """重置搜索状态，但不影响排序状态。"""
        self._reset_search_results()
        if hasattr(self, 'search_input'):
            self.search_input.clear()
            self._current_search_field_index = -1
            if hasattr(self, 'search_field_button'): 
                 self.search_field_button.setText(self.tra("全部"))
            self._update_search_ui()
            if hasattr(self, 'table'): 
                 self.table.clearSelection()

    # 执行搜索
    def _perform_search(self):

        search_text = self.search_input.text().strip().lower()
        self._reset_search_results() # 清除之前的搜索结果

        if not search_text:
            self._update_search_ui()
            if hasattr(self, 'table'): self.table.clearSelection() 
            return

        target_col = self._current_search_field_index
        rows = self.table.rowCount()
        cols = self.table.columnCount()

        for r in range(rows):
            columns_to_search = range(cols) if target_col == -1 else [target_col]
            for c in columns_to_search:
                 # 确保列索引有效
                if c >= cols: continue 
                item = self.table.item(r, c)
                if item and search_text in item.text().lower():
                    self._search_results.append((r, c))
                    if target_col != -1: # 如果搜索特定列，则停止检查此行中的其他列
                         break

        # 如果搜索“全部”导致每行有多个匹配项，则删除重复行
        if target_col == -1:
            unique_results = []
            seen_rows = set()
            for r, c in self._search_results:
                if r not in seen_rows:
                    unique_results.append((r, c)) # 保留该行的第一个列匹配项
                    seen_rows.add(r)
            self._search_results = unique_results


        if self._search_results:
            self._navigate_search_result(0) # 转到第一个结果
        else:
            self._update_search_ui() # 更新UI以显示“0/0”
            if hasattr(self, 'table'): self.table.clearSelection() 

    # 更新搜索UI
    def _update_search_ui(self):

        count = len(self._search_results)
        if count > 0:
            label_text = f"{self._current_search_index + 1}/{count}"
        else:
            # 仅当有搜索文本时显示0/0，否则清除标签
            if hasattr(self, 'search_input') and self.search_input.text().strip(): 
                label_text = "0/0"
            else:
                label_text = "" # 如果没有搜索文本则清除

        if hasattr(self, 'search_results_label'): self.search_results_label.setText(label_text) 

        # 启用/禁用导航按钮
        can_navigate = count > 1
        if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(can_navigate and self._current_search_index > 0) 
        if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(can_navigate and self._current_search_index < count - 1) 
        # 如果只有一个结果，则禁用两个按钮
        if count <= 1:
            if hasattr(self, 'search_prev_button'): self.search_prev_button.setEnabled(False) 
            if hasattr(self, 'search_next_button'): self.search_next_button.setEnabled(False) 

    # 导航上一个结果
    def _navigate_previous(self):

        if self._search_results and self._current_search_index > 0:
            self._navigate_search_result(self._current_search_index - 1)

    # 导航下一个结果
    def _navigate_next(self):

        if self._search_results and self._current_search_index < len(self._search_results) - 1:
            self._navigate_search_result(self._current_search_index + 1)

    # 导航到搜索结果
    def _navigate_search_result(self, index: int):

        if not self._search_results or not (0 <= index < len(self._search_results)):
            return

        self._current_search_index = index
        row, col = self._search_results[index]

        # 确保行/列仍然有效
        if hasattr(self, 'table') and row < self.table.rowCount() and col < self.table.columnCount(): 
            item_to_select = self.table.item(row, 0) 
            if item_to_select:
                self.table.clearSelection() # 首先清除之前的选择
                self.table.setCurrentCell(row, col) # 选择特定的单元格
                self.table.selectRow(row) # 选择包含结果的整行
                self.table.scrollToItem(item_to_select, QAbstractItemView.ScrollHint.PositionAtCenter) # 平滑滚动

        self._update_search_ui() # 更新标签和按钮状态

    # 保存方法
    def save_data(self) -> None:
        config = self.load_config()
        config["post_translation_data"] = TableHelper.load_from_table(self.table, TextReplaceBPage.KEYS)
        self.save_config(config)
        self.success_toast("", self.tra("数据已保存") + " ... ")

    # 重置方法
    def reset_data(self) -> None:
        info_cont1 = self.tra("是否确认重置为默认数据") + " ... ？"
        message_box = MessageBox(self.tra("警告"), info_cont1, self.window())
        message_box.yesButton.setText(self.tra("确认"))
        message_box.cancelButton.setText(self.tra("取消"))

        if not message_box.exec():
            return

        self.table.setRowCount(0)
        config = self.load_config()
        config["post_translation_data"] = copy.deepcopy(self.default.get("post_translation_data", []))
        self.save_config(config)
        TableHelper.update_to_table(self.table, config.get("post_translation_data"), TextReplaceBPage.KEYS)
        self.table.resizeRowsToContents()
        self._reset_search() # 重置后重置搜索
        self._reset_sort_indicator() # 重置后重置排序
        self.success_toast("", self.tra("数据已重置") + " ... ")

    # 导入方法
    def import_data(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, self.tra("选择文件"), "", "json 文件 (*.json);;xlsx 文件 (*.xlsx)")
        if not isinstance(path, str) or path == "":
            return
        data = TableHelper.load_from_file(path, TextReplaceBPage.KEYS)
        config = self.load_config()

        # 去重逻辑
        current_data = TableHelper.load_from_table(self.table, TextReplaceBPage.KEYS)
        current_src_set = {item['src'] for item in current_data if item.get('src')} # 处理潜在的空 src
        new_data_filtered = [item for item in data if item.get('src') and item['src'] not in current_src_set] # 确保导入的项目具有 src

        if not new_data_filtered and data: # 如果所有导入的项目都已存在，则通知
            self.info_toast(self.tra("信息"), self.tra("导入的数据项均已存在于当前表格中"))
            return
        elif not new_data_filtered and not data: # 如果文件为空或格式无效，则通知
            self.warning_toast(self.tra("警告"), self.tra("未从文件中加载到有效数据"))
            return

        # 更新并保存
        # 合并现有数据（来自表格状态）+ 新的已过滤数据
        combined_data = current_data + new_data_filtered
        config["post_translation_data"] = combined_data # 直接更新配置

        # 在再次从表格保存配置*之前*更新表格
        TableHelper.update_to_table(self.table, config["post_translation_data"], TextReplaceBPage.KEYS)
        self.table.resizeRowsToContents() # 导入后调整行高

        # 现在将可能已修改的表格状态保存回配置
        config["post_translation_data"] = TableHelper.load_from_table(self.table, TextReplaceBPage.KEYS)
        self.save_config(config)
        self._reset_search() # 导入后重置搜索
        self._reset_sort_indicator() # 导入后重置排序
        self.success_toast("", self.tra("数据已导入并更新") + f" ({len(new_data_filtered)} {self.tra('项')})...")

    # 导出方法
    # 导出方法
    def export_data(self) -> None:
        data = TableHelper.load_from_table(self.table, TextReplaceBPage.KEYS)
        if not data:
            self.warning_toast("", self.tra("表格中没有数据可导出"))
            return

        default_filename = self.tra("导出_术语表")

        
        file_filter = "JSON 文件 (*.json);;XLSX 文件 (*.xlsx)"
        path, selected_filter = QFileDialog.getSaveFileName(
            self, self.tra("导出文件"), default_filename, file_filter
        )

        if not path:
            return

        # 根据选择的过滤器确保文件扩展名正确
        if "(*.xlsx)" in selected_filter and not path.lower().endswith(".xlsx"):
            path += ".xlsx"
        elif "(*.json)" in selected_filter and not path.lower().endswith(".json"):
            path += ".json"

        try:
            if path.lower().endswith(".json"):
                with open(path, "w", encoding="utf-8") as writer:
                    writer.write(json.dumps(data, indent=4, ensure_ascii=False))
            elif path.lower().endswith(".xlsx"):
                # 使用 pandas 将数据转换为 DataFrame
                df = pandas.DataFrame(data)
                # 使用 reindex 确保所有列都存在且顺序正确
                df = df.reindex(columns=list(self.KEYS), fill_value="")
                # 将列名重命名为用户友好的译文
                df.columns = [self._get_translated_column_name(i) for i in range(len(self.KEYS))]
                # 将 DataFrame 导出到 Excel 文件，不包含索引列
                df.to_excel(path, index=False)
            else:
                self.error_toast(self.tra("导出失败"), self.tra("不支持的文件类型。请选择 .json 或 .xlsx"))
                return

            self.success_toast("", self.tra("数据已导出到") + f": {path}")

        except Exception as e:
            self.logger.error(f"Failed to export data to {path}: {e}", exc_info=True)
            self.error_toast(self.tra("导出失败"), str(e))



================================================
FILE: UserInterface/TableHelper/TableHelper.py
================================================
import openpyxl
import rapidjson as json
from qfluentwidgets import TableWidget
from PyQt5.QtWidgets import QTableWidgetItem

class TableHelper():

    def __init__(self) -> None:
        super().__init__()

    # 从表格加载数据
    def load_from_table(table: TableWidget, keys: list[str]) -> list[dict]:
        result = []

        # 遍历每一行
        for row in range(table.rowCount()):
            # 获取当前行所有条目
            data: list[QTableWidgetItem] = [
                table.item(row, col)
                for col in range(table.columnCount())
            ]

            # 检查数据合法性
            if not isinstance(data[0], QTableWidgetItem) or len(data[0].text().strip()) == 0:
                continue

            # 添加数据
            result.append(
                {
                    keys[i]: (data[i].text().strip() if isinstance(data[i], QTableWidgetItem) else "")
                    for i in range(len(keys))
                }
            )

        return result

    # 向表格更新数据
    def update_to_table(table: TableWidget, data: list[dict], keys: list[str]) -> None:
        # 设置表格行数
        table.setRowCount(max(16, len(data)))

        # 去重
        data_unique = {v.get(keys[0], ""): v for v in data}
        data = [v for v in data_unique.values()]

        # 遍历表格
        for row, v in enumerate(data):
            for col in range(table.columnCount()):
                table.setItem(row, col, QTableWidgetItem(v.get(keys[col], "")))

    # 从文件加载数据
    def load_from_file(path: str, keys: list[str]) -> list[dict]:
        result = []

        # 从 json 文件加载数据
        if path.endswith(".json"):
            result = TableHelper.load_from_json_file(path, keys)

        # 从 xlsx 文件加载数据
        if path.endswith(".xlsx"):
            result = TableHelper.load_from_xlsx_file(path, keys)

        return result

    # 从 json 文件加载数据
    def load_from_json_file(path: str, keys: list[str]) -> list[dict]:
            result = []

            # 读取文件
            inputs = []
            with open(path, "r", encoding = "utf-8") as reader:
                inputs = json.load(reader)

            # 标准字典列表
            # [
            #     {
            #         "key": "value",
            #         "key": "value",
            #         "key": "value",
            #     }
            # ]
            if isinstance(inputs, list):
                for data in inputs:
                    # 数据校验
                    if not isinstance(data, dict) or str(data.get(keys[0], "")).strip() == "":
                        continue

                    # 添加数据
                    result.append({
                        keys[i]: str(data.get(keys[i], "")).strip()
                        for i in range(len(keys))
                    })

                # 兼容旧版，保留一段时间用以过度
                if len(result) == 0 and "src" in keys:
                    # 将 keys 中的 "src" 替换为 "srt" 然后重试
                    result = TableHelper.load_from_json_file(path, [("srt" if v == "src" else v) for v in keys])

                    # 将字段换回来
                    for v in result:
                        v["src"] = v.get("srt", "")

            # 标准 KV 字典
            # [
            #     "ダリヤ": "达莉雅"
            # ]
            if isinstance(inputs, dict):
                for k, v in inputs.items():
                    # 数据校验
                    if str(k).strip() == "":
                        continue

                    # 添加数据
                    item = {}
                    for i in range(len(keys)):
                        if i == 0:
                            item[keys[i]] = str(k).strip()
                        elif i == 1:
                            item[keys[i]] = str(v).strip() if v != None else ""
                        else:
                            item[keys[i]] = ""
                    result.append(item)

            return result

    # 从 xlsx 文件加载数据
    def load_from_xlsx_file(path: str, keys: list[str]) -> list[dict]:
        result = []

        sheet = openpyxl.load_workbook(path).active
        for row in range(2, sheet.max_row + 1): # 跳过标题行，从第二行开始
            # 读取每一行的数据
            data: list[str] = [
                sheet.cell(row = row, column = col).value
                for col in range(1, len(keys) + 1)
            ]

            # 检查数据合法性
            if data[0] == None or str(data[0]).strip() == "":
                continue

            # 添加数据
            result.append(
                {
                    keys[i]: str(data[i]).strip() if data[i] != None else ""
                    for i in range(len(keys))
                }
            )

        return result


================================================
FILE: UserInterface/TranslationSettings/CharacterizationPromptPage.py
================================================
import copy
import rapidjson as json
from qfluentwidgets import (Action, FluentIcon, MessageBox, TableWidget, RoundMenu)

from PyQt5.QtCore import QEvent, Qt, QPoint
from PyQt5.QtWidgets import (QFrame, QFileDialog, QHeaderView, QLayout, QVBoxLayout,
                             QTableWidgetItem,QAbstractItemView)

from Base.Base import Base
from UserInterface.TableHelper.TableHelper import TableHelper
from Widget.CommandBarCard import CommandBarCard
from Widget.SwitchButtonCard import SwitchButtonCard
from UserInterface import AppFluentWindow

class CharacterizationPromptPage(QFrame, Base):

    KEYS = (
        "original_name",
        "translated_name",
        "gender",
        "age",
        "personality",
        "speech_style",
        "additional_info"
    )
    COLUMN_NAMES = {0: "原名",1: "译名",2: "性别", 3: "年龄",4: "性格",5: "说话风格",6: "补充信息"}

    def __init__(self, text: str, window: AppFluentWindow) -> None:
        super().__init__(parent=window)
        self.setObjectName(text.replace(" ", "-"))

        self.default = {
            "characterization_switch": False,
            "characterization_data": [
                {
                    "original_name": "遠坂凛",
                    "translated_name": "远坂凛",
                    "gender": "女",
                    "age": "少女",
                    "personality": "高傲，自满",
                    "speech_style": "大小姐，严厉",
                    "additional_info": "在人前言谈举止高雅，对所有人都用敬语，但在熟人面前本性其实是个爱恶作剧和捉弄自己喜欢的人的小恶魔。"
                },
            ],
        }

        # 读取配置
        config = self.save_config(self.load_config_from_default())

        # 排序相关属性
        self._sort_column_index = -1  # 记录当前排序的列索引，-1表示未排序
        self._sort_order = Qt.AscendingOrder # 记录当前排序顺序

        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        self.add_widget_head(self.container, config, window)
        self.add_widget_body(self.container, config, window)
        self.add_widget_foot(self.container, config, window)

    def _get_translated_column_name(self, index: int) -> str:
        return self.tra(self.COLUMN_NAMES.get(index, f"字段{index+1}"))

    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.update_table() # 每次显示时更新，并确保搜索/排序状态重置

    def update_table(self) -> None:
        config = self.load_config()
        TableHelper.update_to_table(self.table, config["characterization_data"], CharacterizationPromptPage.KEYS)
        self._reset_sort_indicator() # 重置排序指示器

    # 右键菜单
    def show_table_context_menu(self, pos: QPoint):

        menu = RoundMenu(parent=self.table)
        has_selection = bool(self.table.selectionModel().selectedRows())

        if has_selection:
            menu.addAction(Action(FluentIcon.ADD_TO, self.tra("插入行"), triggered=self._handle_insert_row))
            menu.addAction(Action(FluentIcon.REMOVE_FROM, self.tra("删除行"), triggered=self._handle_remove_selected_rows))
            menu.addSeparator()

        # 行数统计
        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.LEAF,f"{self.tra('全部行数')}: {row_count}")
        row_count_action.setEnabled(False) # 使其不可点击，仅作为信息显示
        menu.addAction(row_count_action)

        global_pos = self.table.mapToGlobal(pos)
        menu.exec_(global_pos, ani=True)

    # 处理删除选定行
    def _handle_remove_selected_rows(self) -> None:

        indices = self.table.selectionModel().selectedRows()
        if not indices:
            return

        rows_to_remove = sorted([index.row() for index in indices], reverse=True)

        self.table.setUpdatesEnabled(False)
        for row in rows_to_remove:
            self.table.removeRow(row)
        self.table.setUpdatesEnabled(True)

        self._reset_sort_indicator() # 删除行后重置排序
        self.success_toast("", self.tra("选取行已移除") + "...")

    # 处理插入行
    def _handle_insert_row(self) -> None:

        selected_rows = {item.row() for item in self.table.selectedItems()}
        insert_pos = self.table.rowCount() # 默认为末尾
        if selected_rows:
             insert_pos = max(selected_rows) + 1

        self.table.insertRow(insert_pos)
        # 滚动到新行
        new_item = QTableWidgetItem("") # 创建一个虚拟项以滚动到该位置
        self.table.setItem(insert_pos, 0, new_item) # 添加到第一列
        self.table.scrollToItem(new_item, QAbstractItemView.ScrollHint.PositionAtCenter)
        self.table.selectRow(insert_pos) # 选择新行
        self.table.editItem(self.table.item(insert_pos, 0)) # 开始编辑第一个单元格

        self._reset_sort_indicator() # 重置排序指示器
        self.success_toast("", self.tra("新行已插入") + "...")


    # 添加头部部件
    def add_widget_head(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("characterization_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["characterization_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自定义角色介绍"),
                self.tra("启用此功能后，将根据本页中设置的构建角色介绍，并补充到基础提示词中（不支持本地类模型）"),
                init=init,
                checked_changed=checked_changed,
            )
        )


    # 添加主体部件
    def add_widget_body(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def item_changed(item: QTableWidgetItem) -> None:
            item.setTextAlignment(Qt.AlignCenter)
            # 编辑单元格后，不一定需要立即重排序或重置搜索
            # self.search_input.clear()
            # self._reset_sort_indicator()
            # 后期可以添加自动保存，也可以不添加


        self.table = TableWidget(self)
        parent.addWidget(self.table)

        self.table.setBorderRadius(8)
        self.table.setBorderVisible(True)
        self.table.setWordWrap(True)
        self.table.setColumnCount(len(CharacterizationPromptPage.KEYS))
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_table_context_menu)

        self.table.itemChanged.connect(item_changed)

        header_labels = [self._get_translated_column_name(i) for i in range(len(CharacterizationPromptPage.KEYS))]
        self.table.setHorizontalHeaderLabels(header_labels)

        # 启用排序和连接信号
        self.table.setSortingEnabled(False) # 禁用内置排序
        self.table.horizontalHeader().setSortIndicatorShown(True) # 显示排序指示器空间
        self.table.horizontalHeader().sectionClicked.connect(self._sort_table_by_column) # 连接排序信号

        self.table.resizeRowsToContents() # 调整行高
        self._reset_sort_indicator() # 重置排序指示器

    # 重置排序指示器
    def _reset_sort_indicator(self):
        """清除排序状态和表头的排序指示器。"""
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder
        if hasattr(self, 'table'): 
            self.table.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

    # 排序逻辑处理函数
    def _sort_table_by_column(self, logicalIndex: int):
        """当表头被点击时，按该列对表格数据进行排序。"""
        # 1. 确定排序顺序
        if self._sort_column_index == logicalIndex:
            # 如果点击的是同一列，切换排序顺序
            self._sort_order = Qt.DescendingOrder if self._sort_order == Qt.AscendingOrder else Qt.AscendingOrder
        else:
            # 如果点击的是新列，重置为升序
            self._sort_column_index = logicalIndex
            self._sort_order = Qt.AscendingOrder

        # 2. 获取当前表格数据
        data = TableHelper.load_from_table(self.table, CharacterizationPromptPage.KEYS)

        # 3. 定义排序键函数
        try:
            sort_key_name = CharacterizationPromptPage.KEYS[logicalIndex]
        except IndexError:
            self.logger.warning(f"Invalid column index {logicalIndex} for sorting.")
            return # 无效列索引，不排序

        def get_sort_key(item):
            value = item.get(sort_key_name, "") # 获取值，默认为空字符串
            if value is None: # 处理 None 值
                value = ""
            # 尝试将值转为小写字符串进行不区分大小写的文本排序
            # 注意：如果列包含数字或需要特定类型排序，这里可能需要更复杂的逻辑
            return str(value).lower()

        # 4. 排序数据
        data.sort(key=get_sort_key, reverse=(self._sort_order == Qt.DescendingOrder))


        # 5. 清空并重新填充表格
        self.table.setUpdatesEnabled(False) # 优化性能
        self.table.setRowCount(0) # 清空表格
        TableHelper.update_to_table(self.table, data, CharacterizationPromptPage.KEYS)
        self.table.resizeRowsToContents() # 重新调整行高
        self.table.setUpdatesEnabled(True)

        # 6. 更新表头排序指示器
        self.table.horizontalHeader().setSortIndicator(self._sort_column_index, self._sort_order)

        # 7. 重置搜索状态，因为行顺序已改变
        self.info_toast("", self.tra("表格已按 '{}' {}排序").format(
            self._get_translated_column_name(logicalIndex),
            self.tra("升序") if self._sort_order == Qt.AscendingOrder else self.tra("降序")
        ))


    # 底部命令栏
    def add_widget_foot(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        self.command_bar_card = CommandBarCard()
        parent.addWidget(self.command_bar_card)

        self.add_command_bar_action_save(self.command_bar_card, config, window)
        self.add_command_bar_action_reset(self.command_bar_card, config, window)
        self.command_bar_card.add_separator()
        self.add_command_bar_action_import(self.command_bar_card, config, window)
        self.add_command_bar_action_export(self.command_bar_card, config, window)

    # 保存
    def add_command_bar_action_save(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            config = self.load_config()
            config["characterization_data"] = TableHelper.load_from_table(self.table, CharacterizationPromptPage.KEYS)
            self.save_config(config)
            self.success_toast("", self.tra("数据已保存") + " ... ")

        parent.add_action(
            Action(FluentIcon.SAVE, self.tra("保存"), parent, triggered = triggered),
        )

    # 重置
    def add_command_bar_action_reset(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            info_cont1 = self.tra("是否确认重置为默认数据") + " ... ？"
            message_box = MessageBox(self.tra("警告"), info_cont1, self.window())
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))

            if not message_box.exec():
                return

            self.table.setRowCount(0)
            config = self.load_config()
            config["characterization_data"] = copy.deepcopy(self.default.get("characterization_data", []))
            self.save_config(config)
            TableHelper.update_to_table(self.table, config.get("characterization_data"), CharacterizationPromptPage.KEYS)
            self.table.resizeRowsToContents()
            self._reset_sort_indicator() # 重置后重置排序
            self.success_toast("", self.tra("数据已重置") + " ... ")

        parent.add_action(
            Action(FluentIcon.DELETE, self.tra("重置"), parent, triggered = triggered),
        )

    # 导入
    def add_command_bar_action_import(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            path, _ = QFileDialog.getOpenFileName(self, self.tra("选择文件"), "", "json 文件 (*.json);;xlsx 文件 (*.xlsx)")
            if not isinstance(path, str) or path == "":
                return
            data = TableHelper.load_from_file(path, CharacterizationPromptPage.KEYS)
            config = self.load_config()

            # 去重逻辑
            current_data = TableHelper.load_from_table(self.table, CharacterizationPromptPage.KEYS)
            current_src_set = {item['original_name'] for item in current_data if item.get('original_name')} # 处理潜在的空 original_name
            new_data_filtered = [item for item in data if item.get('original_name') and item['original_name'] not in current_src_set] # 确保导入的项目具有 original_name

            if not new_data_filtered and data: # 如果所有导入的项目都已存在，则通知
                self.info_toast(self.tra("信息"), self.tra("导入的数据项均已存在于当前表格中"))
                return
            elif not new_data_filtered and not data: # 如果文件为空或格式无效，则通知
                self.warning_toast(self.tra("警告"), self.tra("未从文件中加载到有效数据"))
                return

            # 更新并保存
            # 合并现有数据（来自表格状态）+ 新的已过滤数据
            combined_data = current_data + new_data_filtered
            config["prompt_dictionary_data"] = combined_data # 直接更新配置

            # 在再次从表格保存配置*之前*更新表格
            TableHelper.update_to_table(self.table, config["prompt_dictionary_data"], CharacterizationPromptPage.KEYS)
            self.table.resizeRowsToContents() # 导入后调整行高

            # 现在将可能已修改的表格状态保存回配置
            config["prompt_dictionary_data"] = TableHelper.load_from_table(self.table, CharacterizationPromptPage.KEYS)
            self.save_config(config)
            self._reset_sort_indicator() # 导入后重置排序
            self.success_toast("", self.tra("数据已导入并更新") + f" ({len(new_data_filtered)} {self.tra('项')})...")

        parent.add_action(
            Action(FluentIcon.DOWNLOAD, self.tra("导入"), parent, triggered = triggered),
        )

    # 导出
    def add_command_bar_action_export(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            data = TableHelper.load_from_table(self.table, CharacterizationPromptPage.KEYS)
            if not data:
                self.warning_toast("", self.tra("表格中没有数据可导出"))
                return

            default_filename = self.tra("导出_角色介绍") + ".json"
            path, _ = QFileDialog.getSaveFileName(self, self.tra("导出文件"), default_filename, "JSON 文件 (*.json)")

            if not path:
                return

            if path.lower().endswith(".json"):
                with open(path, "w", encoding="utf-8") as writer:
                    writer.write(json.dumps(data, indent=4, ensure_ascii=False))
            else:
                self.error_toast(self.tra("导出失败"), self.tra("不支持的文件扩展名"))
                return

            self.success_toast("", self.tra("数据已导出到") + f": {path}")

        parent.add_action(
            Action(FluentIcon.SHARE, self.tra("导出"), parent, triggered = triggered),
        )




================================================
FILE: UserInterface/TranslationSettings/SystemPromptPage.py
================================================
import uuid
from PyQt5.QtWidgets import ( QWidget, QVBoxLayout, QHBoxLayout, QGridLayout, QFrame)
from PyQt5.QtCore import Qt,  pyqtSignal
from qfluentwidgets import CaptionLabel, CardWidget, FluentWindow, HorizontalSeparator, IconWidget, LineEdit, MessageBoxBase, PrimaryPushButton, PushButton as FluentPushButton, ScrollArea, StrongBodyLabel, TextEdit, FluentIcon


from Base.Base import Base
from ModuleFolders.PromptBuilder.PromptBuilder import PromptBuilder
from ModuleFolders.PromptBuilder.PromptBuilderEnum import PromptBuilderEnum

# 提示词卡片
class PromptCard(Base,CardWidget):
    prompt_selected = pyqtSignal(dict) # 信号：提示词卡片被点击
    delete_requested = pyqtSignal(str) # 信号：请求删除提示词
    edit_requested = pyqtSignal(dict) # 信号：请求编辑提示词

    def __init__(self, prompt_data, parent=None):
        super().__init__(parent)
        self.prompt_data = prompt_data
        self.is_system = prompt_data.get("type") == "system"
        self.setObjectName("PromptCard")
        self.init_ui()

    def init_ui(self):
        self.setCursor(Qt.PointingHandCursor)
        self.setMinimumHeight(120)
        self.setMaximumHeight(180)
        self.setMinimumWidth(200)

        main_v_layout = QVBoxLayout(self)
        main_v_layout.setContentsMargins(10, 10, 10, 10)
        main_v_layout.setSpacing(5)

        name_label = StrongBodyLabel(self.prompt_data["name"])
        name_label.setWordWrap(True)

        # 让其自动换行并填充可用空间
        content_preview = CaptionLabel(self.prompt_data["content"][:130] + "...")
        content_preview.setWordWrap(True)

        main_v_layout.addWidget(name_label)
        main_v_layout.addWidget(content_preview)
        main_v_layout.addStretch(1)

        bottom_h_layout = QHBoxLayout()
        bottom_h_layout.setContentsMargins(0, 0, 0, 0)

        if not self.is_system:
            button_container = QHBoxLayout()
            button_container.addStretch(1)

            edit_button = FluentPushButton(self.tra("编辑"))
            edit_button.clicked.connect(self.on_edit_requested)
            edit_button.setFocusPolicy(Qt.NoFocus)
            button_container.addWidget(edit_button)

            delete_button = FluentPushButton(self.tra("删除"))
            delete_button.clicked.connect(self.on_delete_requested)
            delete_button.setFocusPolicy(Qt.NoFocus)
            button_container.addWidget(delete_button)
            bottom_h_layout.addLayout(button_container)
        else:
            bottom_h_layout.addStretch(1)
            system_tag = CaptionLabel(self.tra("系统预设"))
            bottom_h_layout.addWidget(system_tag, alignment=Qt.AlignRight)

        main_v_layout.addLayout(bottom_h_layout)
        self.setAutoFillBackground(True)

    # 设置默认样式
    def set_default_style(self):
        self.setStyleSheet("")

    # 设置选中样式
    def set_selected_style(self):
        self.setStyleSheet(f"""
            PromptCard#PromptCard {{
                border: 2px solid #0078D4; /* 蓝色边框 */
                background-color: rgba(0, 120, 212, 0.1); /* 半透明背景 */
                border-radius: 8px;
            }}
        """)

    # 响应删除请求
    def on_delete_requested(self):
        self.delete_requested.emit(self.prompt_data["id"])

    # 响应编辑请求
    def on_edit_requested(self):
        self.edit_requested.emit(self.prompt_data)

    # 鼠标点击事件处理
    def mousePressEvent(self, event):
        child_widget = self.childAt(event.pos())
        is_on_button = False
        if child_widget:
            parent = child_widget
            while parent is not None:
                if isinstance(parent, FluentPushButton):
                    is_on_button = True
                    break
                parent = parent.parent()

        if not is_on_button and event.button() == Qt.LeftButton:
            self.prompt_selected.emit(self.prompt_data)

# 提示词编辑对话框
class AddEditPromptDialog(Base,MessageBoxBase):
    def __init__(self, prompt_data=None, parent=None):
        super().__init__(parent)
        self.prompt_data = prompt_data
        self.is_edit_mode = prompt_data is not None
        self.init_ui()

        self.yesButton.setText(self.tra('保存'))
        self.cancelButton.setText(self.tra('取消'))

    def init_ui(self):
        container = QWidget(self)
        layout = QVBoxLayout(container)
        layout.setContentsMargins(0, 10, 0, 0)
        layout.setSpacing(10)

        # 调整对话框尺寸
        self.widget.setMinimumWidth(900)
        self.widget.setMinimumHeight(600)

        name_label = StrongBodyLabel(self.tra("卡片名称:"), container)
        self.name_edit = LineEdit(container)
        if self.is_edit_mode:
            self.name_edit.setText(self.prompt_data["name"])

        content_label = StrongBodyLabel(self.tra("提示词内容:"), container)
        self.content_edit = TextEdit(container)

        if self.is_edit_mode:
            self.content_edit.setPlainText(self.prompt_data["content"])

        layout.addWidget(name_label)
        layout.addWidget(self.name_edit)
        layout.addWidget(content_label)
        layout.addWidget(self.content_edit)

        self.viewLayout.addWidget(container)

    def get_data(self):
        name = self.name_edit.text().strip()
        content = self.content_edit.toPlainText().strip()
        if not name or not content:
            return None

        if self.is_edit_mode:
            return {"id": self.prompt_data["id"], "name": name, "content": content, "type": "user"}
        else:
            return {"id": str(uuid.uuid4()), "name": name, "content": content, "type": "user"}

# 主界面
class SystemPromptPage(QFrame, Base):

    def __init__(self, text: str, window: FluentWindow) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "translation_prompt_selection":{"last_selected_id": PromptBuilderEnum.COMMON,"prompt_content": ""},
            "translation_user_prompt_data": [],
        }

        # 载入并合并配置
        config = self.save_config(self.load_config_from_default())

        # 载入配置文件
        config = self.load_config()

        # 获取用户配置
        self.default_prompt = self.get_default_prompt(config)
        selected_prompt = config.get("translation_prompt_selection",{})
        self.user_prompts = config.get("translation_user_prompt_data",[])
        self.all_prompts = self.default_prompt + self.user_prompts
        last_selected_id = selected_prompt.get("last_selected_id","")

        # 组装界面并初步显示
        self.init_ui()
        self.update_prompt_cards()

        # 启动时恢复上次选择
        self.selected_prompt_card = None
        initial_prompt_to_display = None

        # 在所有提示词中查找与保存的ID匹配的项
        if last_selected_id:
            for p in self.all_prompts:
                if p['id'] == last_selected_id:
                    initial_prompt_to_display = p
                    break
        
        # 如果没有找到，则默认显示第一个
        if not initial_prompt_to_display and self.all_prompts:
            initial_prompt_to_display = self.all_prompts[0]
            
        # 如果存在可显示的提示词，则显示它
        if initial_prompt_to_display:
            self.display_prompt_details(initial_prompt_to_display)

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(0, 10, 0, 0) 

        # 设置顶部卡片
        self.top_display_card = CardWidget(self)
        top_card_layout = QVBoxLayout(self.top_display_card)
        top_card_layout.setContentsMargins(20, 15, 20, 15)
        top_card_layout.setSpacing(12)

        # 设置顶部卡片标题
        header_layout = QHBoxLayout()
        header_layout.setSpacing(8)
        
        pin_icon = IconWidget(FluentIcon.PIN, self.top_display_card)
        pin_icon.setFixedSize(18, 18)
        
        title_label = StrongBodyLabel(self.tra("当前提示词"), self.top_display_card)

        header_layout.addWidget(pin_icon)
        header_layout.addWidget(title_label)
        header_layout.addStretch(1)
        top_card_layout.addLayout(header_layout)

        # 添加分割线
        top_card_layout.addWidget(HorizontalSeparator())

        # 设置顶部卡片内容显示
        name_layout = QHBoxLayout()
        name_label_title = StrongBodyLabel(self.tra("名称："), self.top_display_card)
        self.selected_prompt_name_label = StrongBodyLabel("")
        name_layout.addWidget(name_label_title)
        name_layout.addWidget(self.selected_prompt_name_label)
        name_layout.addStretch(1)
        top_card_layout.addLayout(name_layout)
        
        # 设置顶部卡片内容文本框
        self.selected_prompt_content_text = TextEdit()
        self.selected_prompt_content_text.setReadOnly(True)
        self.selected_prompt_content_text.setMinimumHeight(200)
        #self.selected_prompt_content_text.setMaximumHeight(200)

        top_card_layout.addWidget(self.selected_prompt_content_text)
        
        # 将顶部卡片添加到主布局
        main_layout.addWidget(self.top_display_card, 1)

        # 设置底部卡片
        self.bottom_grid_card = CardWidget(self)
        bottom_card_layout = QVBoxLayout(self.bottom_grid_card)
        bottom_card_layout.setContentsMargins(20, 15, 20, 15) # 统一边距风格
        bottom_card_layout.setSpacing(12) # 统一间距风格

        header_layout = QHBoxLayout()
        card_square_label = StrongBodyLabel(self.tra("提示词广场"))
        header_layout.addWidget(card_square_label)
        header_layout.addStretch(1)
        self.add_new_prompt_button =  PrimaryPushButton(FluentIcon.ADD, self.tra("创建新提示词"), self)
        self.add_new_prompt_button.clicked.connect(self.open_add_prompt_dialog)
        header_layout.addWidget(self.add_new_prompt_button)
        bottom_card_layout.addLayout(header_layout)

        self.scroll_area = ScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll_area.setStyleSheet("background-color: transparent; border: none;")

        self.card_container_widget = QWidget()
        self.card_container_widget.setStyleSheet("background-color: transparent;")
        self.card_grid_layout = QGridLayout(self.card_container_widget)
        self.card_grid_layout.setSpacing(15)
        self.card_grid_layout.setAlignment(Qt.AlignTop | Qt.AlignLeft)

        self.scroll_area.setWidget(self.card_container_widget)
        bottom_card_layout.addWidget(self.scroll_area)

        main_layout.addWidget(self.bottom_grid_card, 3)
        self.setLayout(main_layout)

    # 获取系统提示词
    def get_default_prompt(self, config):

        # 获取系统预设提示词内容
        conmon_name = self.tra("通用")
        common_id = PromptBuilderEnum.COMMON
        common_prompt_content = PromptBuilder.get_system_default(config,PromptBuilderEnum.COMMON)

        cot_name = self.tra("思维链")
        cot_id = PromptBuilderEnum.COT
        coT_prompt_content = PromptBuilder.get_system_default(config,PromptBuilderEnum.COT)

        think_name = self.tra("推理模型")
        think_id = PromptBuilderEnum.THINK
        think_prompt_content = PromptBuilder.get_system_default(config,PromptBuilderEnum.THINK)

        # 组装默认提示词列表
        default_prompt = [
            {
                "id": common_id,
                "name": conmon_name,
                "content": common_prompt_content,
                "type": "system"
            },
            {
                "id": cot_id,
                "name": cot_name,
                "content": coT_prompt_content,
                "type": "system"
            },
            {
                "id": think_id,
                "name": think_name,
                "content": think_prompt_content,
                "type": "system"
            }
        ]

        return default_prompt

    # 保存当前选择
    def save_last_selection(self, prompt_id,prompt_content):

        config = self.load_config()
        config["translation_prompt_selection"] = {"last_selected_id": prompt_id,"prompt_content": prompt_content}
        self.save_config(config)

    # 保存新的用户提示词
    def save_user_prompts(self):
        config = self.load_config()
        config["translation_user_prompt_data"] = self.user_prompts
        self.save_config(config)

    # 清楚界面
    def clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
            elif child.layout():
                self.clear_layout(child.layout())

    # 更新提示词广场的卡片
    def update_prompt_cards(self):
        self.clear_layout(self.card_grid_layout)
        self.all_prompts = self.default_prompt + self.user_prompts

        prompts_to_display = self.all_prompts[:]

        num_cols = 3
        row, col = 0, 0
        for i, prompt_data in enumerate(prompts_to_display):
            card = PromptCard(prompt_data)
            card.prompt_selected.connect(self.display_prompt_details)

            if prompt_data.get("type") != "system":
                card.delete_requested.connect(self.delete_user_prompt)
                card.edit_requested.connect(self.handle_edit_request)

            self.card_grid_layout.addWidget(card, row, col)
            col += 1
            if col >= num_cols:
                col = 0
                row += 1

    # 查找指定ID的提示词卡片
    def find_card_widget(self, prompt_id):
        for i in range(self.card_grid_layout.count()):
            item = self.card_grid_layout.itemAt(i)
            if item:
                widget = item.widget()
                if isinstance(widget, PromptCard) and widget.prompt_data["id"] == prompt_id:
                    return widget
        return None
    
    # 高亮显示指定的提示词卡片
    def highlight_card(self, card_to_highlight_widget):
        if self.selected_prompt_card and self.selected_prompt_card != card_to_highlight_widget:
            self.selected_prompt_card.set_default_style()

        if card_to_highlight_widget:
            card_to_highlight_widget.set_selected_style()
            self.selected_prompt_card = card_to_highlight_widget
        else:
            self.selected_prompt_card = None

    # 显示选中的提示词详情
    def display_prompt_details(self, prompt_data):
        self.selected_prompt_name_label.setText(f"{prompt_data['name']}")
        self.selected_prompt_content_text.setPlainText(prompt_data['content'])

        card_widget_to_select = self.find_card_widget(prompt_data["id"])
        self.highlight_card(card_widget_to_select)

        self.save_last_selection(prompt_data['id'],prompt_data['content'])

    # 处理编辑请求
    def handle_edit_request(self, prompt_data_to_edit):
        self.open_add_prompt_dialog(prompt_data_to_edit)

    # 打开添加或编辑提示词对话框
    def open_add_prompt_dialog(self, prompt_to_edit=None):
        actual_prompt_to_edit = prompt_to_edit
        if isinstance(prompt_to_edit, bool) and not prompt_to_edit:
            actual_prompt_to_edit = None

        dialog = AddEditPromptDialog(actual_prompt_to_edit, self)

        if dialog.exec_():
            data = dialog.get_data()
            if data:
                is_new_prompt = not actual_prompt_to_edit

                if not is_new_prompt and actual_prompt_to_edit:
                    for i, p in enumerate(self.user_prompts):
                        if p["id"] == data["id"]:
                            self.user_prompts[i] = data
                            break
                else:
                    self.user_prompts.append(data)

                self.save_user_prompts()
                self.update_prompt_cards()

                newly_added_or_edited_card_instance = self.find_card_widget(data["id"])
                if newly_added_or_edited_card_instance:
                    self.display_prompt_details(data)
                elif self.all_prompts:
                    self.display_prompt_details(self.all_prompts[0])


    # 删除用户提示词
    def delete_user_prompt(self, prompt_id_to_delete):
        id_of_currently_selected = None
        if self.selected_prompt_card:
            id_of_currently_selected = self.selected_prompt_card.prompt_data["id"]

        self.user_prompts = [p for p in self.user_prompts if p["id"] != prompt_id_to_delete]
        self.save_user_prompts()

        self.update_prompt_cards()

        if id_of_currently_selected == prompt_id_to_delete:
            self.selected_prompt_name_label.setText("")
            self.selected_prompt_content_text.clear()
            self.selected_prompt_card = None
            if self.all_prompts:
                self.display_prompt_details(self.all_prompts[0])
        elif id_of_currently_selected:
            card_to_reselect = self.find_card_widget(id_of_currently_selected)
            if card_to_reselect:
                self.display_prompt_details(card_to_reselect.prompt_data)
            elif self.all_prompts:
                self.display_prompt_details(self.all_prompts[0])
            else:
                self.selected_prompt_name_label.setText("")
                self.selected_prompt_content_text.clear()
                self.selected_prompt_card = None


================================================
FILE: UserInterface/TranslationSettings/TranslationExamplePromptPage.py
================================================
import copy
import rapidjson as json
from qfluentwidgets import (Action, FluentIcon, MessageBox, TableWidget, RoundMenu)

from PyQt5.QtCore import QEvent, Qt, QPoint
from PyQt5.QtWidgets import (QFrame, QFileDialog, QHeaderView, QLayout, QVBoxLayout,
                             QTableWidgetItem,QAbstractItemView)

from Base.Base import Base
from UserInterface.TableHelper.TableHelper import TableHelper
from Widget.CommandBarCard import CommandBarCard
from Widget.SwitchButtonCard import SwitchButtonCard
from UserInterface import AppFluentWindow

class TranslationExamplePromptPage(QFrame, Base):

    KEYS = ("src", "dst")
    COLUMN_NAMES = {0: "原文",1: "译文"}

    def __init__(self, text: str, window: AppFluentWindow) -> None:
        super().__init__(parent=window)
        self.setObjectName(text.replace(" ", "-"))

        self.default = {
            "translation_example_switch": False,
            "translation_example_data": [],
        }

        # 读取配置
        config = self.save_config(self.load_config_from_default())

        # 排序相关属性
        self._sort_column_index = -1  # 记录当前排序的列索引，-1表示未排序
        self._sort_order = Qt.AscendingOrder # 记录当前排序顺序

        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24)

        self.add_widget_head(self.container, config, window)
        self.add_widget_body(self.container, config, window)
        self.add_widget_foot(self.container, config, window)

    def _get_translated_column_name(self, index: int) -> str:
        return self.tra(self.COLUMN_NAMES.get(index, f"字段{index+1}"))

    def showEvent(self, event: QEvent) -> None:
        super().showEvent(event)
        self.update_table() # 每次显示时更新，并确保搜索/排序状态重置

    def update_table(self) -> None:
        config = self.load_config()
        TableHelper.update_to_table(self.table, config["translation_example_data"], TranslationExamplePromptPage.KEYS)
        self._reset_sort_indicator() # 重置排序指示器

    # 右键菜单
    def show_table_context_menu(self, pos: QPoint):

        menu = RoundMenu(parent=self.table)
        has_selection = bool(self.table.selectionModel().selectedRows())

        if has_selection:
            menu.addAction(Action(FluentIcon.ADD_TO, self.tra("插入行"), triggered=self._handle_insert_row))
            menu.addAction(Action(FluentIcon.REMOVE_FROM, self.tra("删除行"), triggered=self._handle_remove_selected_rows))
            menu.addSeparator()

        # 行数统计
        row_count = self.table.rowCount()
        row_count_action = Action(FluentIcon.LEAF,f"{self.tra('全部行数')}: {row_count}")
        row_count_action.setEnabled(False) # 使其不可点击，仅作为信息显示
        menu.addAction(row_count_action)

        global_pos = self.table.mapToGlobal(pos)
        menu.exec_(global_pos, ani=True)

    # 处理删除选定行
    def _handle_remove_selected_rows(self) -> None:

        indices = self.table.selectionModel().selectedRows()
        if not indices:
            return

        rows_to_remove = sorted([index.row() for index in indices], reverse=True)

        self.table.setUpdatesEnabled(False)
        for row in rows_to_remove:
            self.table.removeRow(row)
        self.table.setUpdatesEnabled(True)

        self._reset_sort_indicator() # 删除行后重置排序
        self.success_toast("", self.tra("选取行已移除") + "...")

    # 处理插入行
    def _handle_insert_row(self) -> None:

        selected_rows = {item.row() for item in self.table.selectedItems()}
        insert_pos = self.table.rowCount() # 默认为末尾
        if selected_rows:
             insert_pos = max(selected_rows) + 1

        self.table.insertRow(insert_pos)
        # 滚动到新行
        new_item = QTableWidgetItem("") # 创建一个虚拟项以滚动到该位置
        self.table.setItem(insert_pos, 0, new_item) # 添加到第一列
        self.table.scrollToItem(new_item, QAbstractItemView.ScrollHint.PositionAtCenter)
        self.table.selectRow(insert_pos) # 选择新行
        self.table.editItem(self.table.item(insert_pos, 0)) # 开始编辑第一个单元格

        self._reset_sort_indicator() # 重置排序指示器
        self.success_toast("", self.tra("新行已插入") + "...")


    # 添加头部部件
    def add_widget_head(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("translation_example_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["translation_example_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自定义翻译示例"),
                self.tra("启用此功能后，将根据本页中设置的内容构建翻译示例，并补充到基础提示词中（不支持本地类模型）"),
                init=init,
                checked_changed=checked_changed,
            )
        )


    # 添加主体部件
    def add_widget_body(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        def item_changed(item: QTableWidgetItem) -> None:
            item.setTextAlignment(Qt.AlignCenter)
            # 编辑单元格后，不一定需要立即重排序或重置搜索
            # self.search_input.clear()
            # self._reset_sort_indicator()
            # 后期可以添加自动保存，也可以不添加


        self.table = TableWidget(self)
        parent.addWidget(self.table)

        self.table.setBorderRadius(8)
        self.table.setBorderVisible(True)
        self.table.setWordWrap(True)
        self.table.setColumnCount(len(TranslationExamplePromptPage.KEYS))
        self.table.verticalHeader().hide()
        self.table.setAlternatingRowColors(True)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked | QAbstractItemView.SelectedClicked | QAbstractItemView.EditKeyPressed)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_table_context_menu)

        self.table.itemChanged.connect(item_changed)

        header_labels = [self._get_translated_column_name(i) for i in range(len(TranslationExamplePromptPage.KEYS))]
        self.table.setHorizontalHeaderLabels(header_labels)

        # 启用排序和连接信号
        self.table.setSortingEnabled(False) # 禁用内置排序
        self.table.horizontalHeader().setSortIndicatorShown(True) # 显示排序指示器空间
        self.table.horizontalHeader().sectionClicked.connect(self._sort_table_by_column) # 连接排序信号

        self.table.resizeRowsToContents() # 调整行高
        self._reset_sort_indicator() # 重置排序指示器

    # 重置排序指示器
    def _reset_sort_indicator(self):
        """清除排序状态和表头的排序指示器。"""
        self._sort_column_index = -1
        self._sort_order = Qt.AscendingOrder
        if hasattr(self, 'table'): 
            self.table.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

    # 排序逻辑处理函数
    def _sort_table_by_column(self, logicalIndex: int):
        """当表头被点击时，按该列对表格数据进行排序。"""
        # 1. 确定排序顺序
        if self._sort_column_index == logicalIndex:
            # 如果点击的是同一列，切换排序顺序
            self._sort_order = Qt.DescendingOrder if self._sort_order == Qt.AscendingOrder else Qt.AscendingOrder
        else:
            # 如果点击的是新列，重置为升序
            self._sort_column_index = logicalIndex
            self._sort_order = Qt.AscendingOrder

        # 2. 获取当前表格数据
        data = TableHelper.load_from_table(self.table, TranslationExamplePromptPage.KEYS)

        # 3. 定义排序键函数
        try:
            sort_key_name = TranslationExamplePromptPage.KEYS[logicalIndex]
        except IndexError:
            self.logger.warning(f"Invalid column index {logicalIndex} for sorting.")
            return # 无效列索引，不排序

        def get_sort_key(item):
            value = item.get(sort_key_name, "") # 获取值，默认为空字符串
            if value is None: # 处理 None 值
                value = ""
            # 尝试将值转为小写字符串进行不区分大小写的文本排序
            # 注意：如果列包含数字或需要特定类型排序，这里可能需要更复杂的逻辑
            return str(value).lower()

        # 4. 排序数据
        data.sort(key=get_sort_key, reverse=(self._sort_order == Qt.DescendingOrder))


        # 5. 清空并重新填充表格
        self.table.setUpdatesEnabled(False) # 优化性能
        self.table.setRowCount(0) # 清空表格
        TableHelper.update_to_table(self.table, data, TranslationExamplePromptPage.KEYS)
        self.table.resizeRowsToContents() # 重新调整行高
        self.table.setUpdatesEnabled(True)

        # 6. 更新表头排序指示器
        self.table.horizontalHeader().setSortIndicator(self._sort_column_index, self._sort_order)

        # 7. 重置搜索状态，因为行顺序已改变
        self.info_toast("", self.tra("表格已按 '{}' {}排序").format(
            self._get_translated_column_name(logicalIndex),
            self.tra("升序") if self._sort_order == Qt.AscendingOrder else self.tra("降序")
        ))


    # 底部命令栏
    def add_widget_foot(self, parent: QLayout, config: dict, window: AppFluentWindow) -> None:

        self.command_bar_card = CommandBarCard()
        parent.addWidget(self.command_bar_card)

        self.add_command_bar_action_save(self.command_bar_card, config, window)
        self.add_command_bar_action_reset(self.command_bar_card, config, window)
        self.command_bar_card.add_separator()
        self.add_command_bar_action_import(self.command_bar_card, config, window)
        self.add_command_bar_action_export(self.command_bar_card, config, window)

    # 保存
    def add_command_bar_action_save(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            config = self.load_config()
            config["translation_example_data"] = TableHelper.load_from_table(self.table, TranslationExamplePromptPage.KEYS)
            self.save_config(config)
            self.success_toast("", self.tra("数据已保存") + " ... ")

        parent.add_action(
            Action(FluentIcon.SAVE, self.tra("保存"), parent, triggered = triggered),
        )

    # 重置
    def add_command_bar_action_reset(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            info_cont1 = self.tra("是否确认重置为默认数据") + " ... ？"
            message_box = MessageBox(self.tra("警告"), info_cont1, self.window())
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))

            if not message_box.exec():
                return

            self.table.setRowCount(0)
            config = self.load_config()
            config["translation_example_data"] = copy.deepcopy(self.default.get("translation_example_data", []))
            self.save_config(config)
            TableHelper.update_to_table(self.table, config.get("translation_example_data"), TranslationExamplePromptPage.KEYS)
            self.table.resizeRowsToContents()
            self._reset_sort_indicator() # 重置后重置排序
            self.success_toast("", self.tra("数据已重置") + " ... ")

        parent.add_action(
            Action(FluentIcon.DELETE, self.tra("重置"), parent, triggered = triggered),
        )


    # 导入
    def add_command_bar_action_import(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            path, _ = QFileDialog.getOpenFileName(self, self.tra("选择文件"), "", "json 文件 (*.json);;xlsx 文件 (*.xlsx)")
            if not isinstance(path, str) or path == "":
                return
            data = TableHelper.load_from_file(path, TranslationExamplePromptPage.KEYS)
            config = self.load_config()

            # 去重逻辑
            current_data = TableHelper.load_from_table(self.table, TranslationExamplePromptPage.KEYS)
            current_src_set = {item['src'] for item in current_data if item.get('src')} # 处理潜在的空 src
            new_data_filtered = [item for item in data if item.get('src') and item['src'] not in current_src_set] # 确保导入的项目具有 src

            if not new_data_filtered and data: # 如果所有导入的项目都已存在，则通知
                self.info_toast(self.tra("信息"), self.tra("导入的数据项均已存在于当前表格中"))
                return
            elif not new_data_filtered and not data: # 如果文件为空或格式无效，则通知
                self.warning_toast(self.tra("警告"), self.tra("未从文件中加载到有效数据"))
                return

            # 更新并保存
            # 合并现有数据（来自表格状态）+ 新的已过滤数据
            combined_data = current_data + new_data_filtered
            config["prompt_dictionary_data"] = combined_data # 直接更新配置

            # 在再次从表格保存配置*之前*更新表格
            TableHelper.update_to_table(self.table, config["prompt_dictionary_data"], TranslationExamplePromptPage.KEYS)
            self.table.resizeRowsToContents() # 导入后调整行高

            # 现在将可能已修改的表格状态保存回配置
            config["prompt_dictionary_data"] = TableHelper.load_from_table(self.table, TranslationExamplePromptPage.KEYS)
            self.save_config(config)
            self._reset_sort_indicator() # 导入后重置排序
            self.success_toast("", self.tra("数据已导入并更新") + f" ({len(new_data_filtered)} {self.tra('项')})...")

        parent.add_action(
            Action(FluentIcon.DOWNLOAD, self.tra("导入"), parent, triggered = triggered),
        )

    # 导出
    def add_command_bar_action_export(self, parent: CommandBarCard, config: dict, window: AppFluentWindow) -> None:

        def triggered() -> None:
            data = TableHelper.load_from_table(self.table, TranslationExamplePromptPage.KEYS)
            if not data:
                self.warning_toast("", self.tra("表格中没有数据可导出"))
                return

            default_filename = self.tra("导出_翻译示例") + ".json"
            path, _ = QFileDialog.getSaveFileName(self, self.tra("导出文件"), default_filename, "JSON 文件 (*.json)")

            if not path:
                return

            if path.lower().endswith(".json"):
                with open(path, "w", encoding="utf-8") as writer:
                    writer.write(json.dumps(data, indent=4, ensure_ascii=False))
            else:
                self.error_toast(self.tra("导出失败"), self.tra("不支持的文件扩展名"))
                return

            self.success_toast("", self.tra("数据已导出到") + f": {path}")

        parent.add_action(
            Action(FluentIcon.SHARE, self.tra("导出"), parent, triggered = triggered),
        )




================================================
FILE: UserInterface/TranslationSettings/TranslationSettingsPage.py
================================================

from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QVBoxLayout
from qfluentwidgets import HorizontalSeparator, PillPushButton

from Base.Base import Base
from Widget.ComboBoxCard import ComboBoxCard
from Widget.SwitchButtonCard import SwitchButtonCard
from Widget.ComboBoxCard import ComboBoxCard
from Widget.SpinCard import SpinCard
from Widget.FlowCard import FlowCard



class TranslationSettingsPage(QFrame, Base):

    def __init__(self, text: str, window) -> None:
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "source_language": "auto",
            "target_language": "chinese_simplified",
            "pre_line_counts": 0,
            "few_shot_and_example_switch": True,
            "auto_process_text_code_segment": False,
            "response_check_switch": {
                "return_to_original_text_check": True,
                "residual_original_text_check": True,
                "newline_character_count_check": True,
                "reply_format_check": False,
            },
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24) # 左、上、右、下

        # 添加控件
        self.add_widget_source_language(self.container, config)
        self.add_widget_target_language(self.container, config)
        self.container.addWidget(HorizontalSeparator())
        self.add_widget_pre_lines(self.container, config)
        self.add_auto_process_text_code_segment(self.container, config)
        self.add_widget_few_shot_and_example(self.container, config)
        self.container.addWidget(HorizontalSeparator())
        self.add_widget_result_check(self.container, config)

        # 填充
        self.container.addStretch(1)


    # 参考上文行数
    def add_widget_pre_lines(self, parent, config) -> None:
        def init(widget) -> None:
            widget.set_range(0, 9999999)
            widget.set_value(config.get("pre_line_counts"))

        def value_changed(widget, value: int) -> None:
            config = self.load_config()
            config["pre_line_counts"] = value
            self.save_config(config)

        parent.addWidget(
            SpinCard(
                self.tra("参考上文行数"),
                self.tra("行数不宜设置过大，建议10行以内 (不支持本地类接口)"),
                init = init,
                value_changed = value_changed,
            )
        )

    # 原文语言
    def add_widget_source_language(self, parent, config) -> None:
        # 定义语言与值的配对列表（显示文本, 存储值）
        source_language_pairs = [
            (self.tra("自动检测"), "auto"),
            (self.tra("日语"), "japanese"),
            (self.tra("英语"), "english"),
            (self.tra("韩语"), "korean"),
            (self.tra("俄语"), "russian"),
            (self.tra("德语"), "german"),
            (self.tra("法语"), "french"),
            (self.tra("简中"), "chinese_simplified"),
            (self.tra("繁中"), "chinese_traditional"),
            (self.tra("西班牙语"), "spanish"),
        ]

        # 生成翻译后的配对列表
        translated_pairs = [(self.tra(display), value) for display, value in source_language_pairs]

        def init(widget) -> None:
            """初始化时根据存储的值设置当前选项"""
            current_config = self.load_config()
            current_value = current_config.get("source_language", "auto")

            # 通过值查找对应的索引
            index = next(
                (i for i, (_, value) in enumerate(translated_pairs) if value == current_value),
                0  # 默认选择第一个选项
            )
            widget.set_current_index(max(0, index))

        def current_text_changed(widget, text: str) -> None:
            """选项变化时存储对应的值"""
            # 通过显示文本查找对应的值
            value = next(
                (value for display, value in translated_pairs if display == text),
                "auto"  # 默认值
            )
            
            config = self.load_config()
            config["source_language"] = value
            self.save_config(config)

        # 创建选项列表（使用翻译后的显示文本）
        options = [display for display, _ in translated_pairs]

        parent.addWidget(
            ComboBoxCard(
                self.tra("原文语言"),
                self.tra("设置当前项目所使用的原始文本的语言"),
                options,
                init=init,
                current_text_changed=current_text_changed
            )
        )

    # 译文语言
    def add_widget_target_language(self, parent, config) -> None:
        # 定义语言与值的配对列表（显示文本, 存储值）
        target_language_pairs = [
            (self.tra("简中"), "chinese_simplified"),
            (self.tra("繁中"), "chinese_traditional"),
            (self.tra("英语"), "english"),
            (self.tra("日语"), "japanese"),
            (self.tra("韩语"), "korean"),
            (self.tra("俄语"), "russian"),
            (self.tra("德语"), "german"),
            (self.tra("法语"), "french"),
            (self.tra("西班牙语"), "spanish"),
        ]

        # 生成翻译后的配对列表
        translated_pairs = [(self.tra(display), value) for display, value in target_language_pairs]

        def init(widget) -> None:
            """初始化时根据存储的值设置当前选项"""
            current_config = self.load_config()
            current_value = current_config.get("target_language", "chinese_simplified")

            # 通过值查找对应的索引
            index = next(
                (i for i, (_, value) in enumerate(translated_pairs) if value == current_value),
                0  # 默认选择第一个选项
            )
            widget.set_current_index(max(0, index))

        def current_text_changed(widget, text: str) -> None:
            """选项变化时存储对应的值"""
            # 通过显示文本查找对应的值
            value = next(
                (value for display, value in translated_pairs if display == text),
                "chinese_simplified"  # 默认值
            )
            
            config = self.load_config()
            config["target_language"] = value
            self.save_config(config)

        # 创建选项列表（使用翻译后的显示文本）
        options = [display for display, _ in translated_pairs]

        parent.addWidget(
            ComboBoxCard(
                self.tra("译文语言"),
                self.tra("设置当前项目所期望的译文文本的语言"),
                options,
                init=init,
                current_text_changed=current_text_changed
            )
        )


    # 示例模块和预回复模块开关
    def add_widget_few_shot_and_example(self, parent, config) -> None:

        def init(widget: SwitchButtonCard) -> None:
            widget.set_checked(config.get("few_shot_and_example_switch"))

        def checked_changed(widget: SwitchButtonCard, checked: bool) -> None:
            config = self.load_config()
            config["few_shot_and_example_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("动态示例和预回复功能"),
                self.tra("将在构建整体的翻译提示词时，自动生成动态Few-shot和构建模型预回复内容，不支持本地接口"),
                init = init,
                checked_changed = checked_changed,
            )
        )

    # 自动预处理
    def add_auto_process_text_code_segment(self, parent, config) -> None:
        def widget_init(widget) -> None:
            widget.set_checked(config.get("auto_process_text_code_segment"))

        def widget_callback(widget, checked: bool) -> None:
            config = self.load_config()
            config["auto_process_text_code_segment"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自动预处理文本"),
                self.tra(
                "启用此功能后，根据正则库与禁翻表，将在翻译前移除文本首尾的非翻译内容，占位文本中间的非翻译内容，并在翻译后还原"
                ),
                widget_init,
                widget_callback,
            )
        )

    # 结果检查
    def add_widget_result_check(self, parent, config) -> None:
        def on_toggled(checked: bool, key) -> None:
            config = self.load_config()
            config["response_check_switch"][key] = checked
            self.save_config(config)

        def widget_init(widget) -> None:

            info_cont1 = self.tra("原文返回检查")
            info_cont2 = self.tra("翻译残留检查")
            info_cont3 = self.tra("换行符数检查")
            info_cont4 = self.tra("回复格式强检查") 

            pairs = [
                (info_cont1, "return_to_original_text_check"),
                (info_cont2, "residual_original_text_check"),
                (info_cont3, "newline_character_count_check"),
                (info_cont4, "reply_format_check"),
            ]

            for v in pairs:
                pill_push_button = PillPushButton(v[0])
                pill_push_button.setContentsMargins(4, 0, 4, 0) # 左、上、右、下
                pill_push_button.setChecked(config["response_check_switch"].get(v[1]))
                pill_push_button.toggled.connect(lambda checked, key = v[1]: on_toggled(checked, key))
                widget.add_widget(pill_push_button)

        parent.addWidget(
            FlowCard(
                self.tra("翻译结果检查"),
                self.tra("将在翻译结果中检查激活的规则（点亮按钮为激活）：如检测到对应情况，则视为任务执行失败"),
                widget_init
            )
        )


================================================
FILE: UserInterface/TranslationSettings/WorldBuildingPromptPage.py
================================================
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import Action
from qfluentwidgets import FluentIcon
from qfluentwidgets import MessageBox
from qfluentwidgets import PlainTextEdit

from Base.Base import Base
from Widget.CommandBarCard import CommandBarCard
from Widget.SwitchButtonCard import SwitchButtonCard

class WorldBuildingPromptPage(QFrame, Base):

    def __init__(self, text: str, window):
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "world_building_switch": False,
            "world_building_content": (
                "故事发生在魔法世界，到三十岁还保持童真，就可以学会大火球魔法，成为魔法师。"
            ),
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24) # 左、上、右、下

        # 添加控件
        self.add_widget_header(self.container, config)
        self.add_widget_body(self.container, config)
        self.add_widget_footer(self.container, config, window)

    # 头部
    def add_widget_header(self, parent, config):
        def widget_init(widget):
            widget.set_checked(config.get("world_building_switch"))

        def widget_callback(widget, checked: bool):
            config = self.load_config()
            config["world_building_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自定义背景设定"),
                self.tra("启用此功能后，将根据本页中设置的内容构建背景设定提示，并补充到基础提示词中（不支持本地类模型）"),
                widget_init,
                widget_callback,
            )
        )

    # 主体
    def add_widget_body(self, parent, config):
        self.plain_text_edit = PlainTextEdit(self)
        self.plain_text_edit.setPlainText(config.get("world_building_content"))
        parent.addWidget(self.plain_text_edit)

    # 底部
    def add_widget_footer(self, parent, config, window):
        self.command_bar_card = CommandBarCard()
        parent.addWidget(self.command_bar_card)

        # 添加命令
        self.add_command_bar_action_01(self.command_bar_card)
        self.add_command_bar_action_02(self.command_bar_card, window)
    # 保存
    def add_command_bar_action_01(self, parent):
        def callback():
            # 读取配置文件
            config = self.load_config()

            # 从表格更新数据
            config["world_building_content"] = self.plain_text_edit.toPlainText().strip()

            # 保存配置文件
            config = self.save_config(config)

            # 弹出提示
            info_cont = self.tra("数据已保存") + " ..."
            self.success_toast("", info_cont)

        parent.add_action(
            Action(FluentIcon.SAVE, self.tra("保存"), parent, triggered = callback),
        )

    # 重置
    def add_command_bar_action_02(self, parent, window):
        def callback():
            info_cont1 = self.tra("是否确认重置为默认数据")  + " ... ？"
            message_box = MessageBox("Warning", info_cont1, window)
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))

            if not message_box.exec():
                return

            # 清空控件
            self.plain_text_edit.setPlainText("")

            # 读取配置文件
            config = self.load_config()

            # 加载默认设置
            config["world_building_content"] = self.default.get("world_building_content")

            # 保存配置文件
            config = self.save_config(config)

            # 向控件更新数据
            self.plain_text_edit.setPlainText(config.get("world_building_content"))

            # 弹出提示
            info_cont2 = self.tra("数据已重置")  + " ... "
            self.success_toast("", info_cont2)

        parent.add_action(
            Action(FluentIcon.DELETE, self.tra("重置"), parent, triggered = callback),
        )


================================================
FILE: UserInterface/TranslationSettings/WritingStylePromptPage.py
================================================
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import Action
from qfluentwidgets import FluentIcon
from qfluentwidgets import MessageBox
from qfluentwidgets import PlainTextEdit

from Base.Base import Base
from Widget.CommandBarCard import CommandBarCard
from Widget.SwitchButtonCard import SwitchButtonCard

class WritingStylePromptPage(QFrame, Base):

    def __init__(self, text: str, window):
        super().__init__(window)
        self.setObjectName(text.replace(" ", "-"))

        # 默认配置
        self.default = {
            "writing_style_switch": False,
            "writing_style_content": (
                "根据原文语境，可以适当调整，使表达更生动形象，提升译文的冲击力与张力"
            ),
        }

        # 载入并保存默认配置
        config = self.save_config(self.load_config_from_default())

        # 设置主容器
        self.container = QVBoxLayout(self)
        self.container.setSpacing(8)
        self.container.setContentsMargins(24, 24, 24, 24) # 左、上、右、下

        # 添加控件
        self.add_widget_header(self.container, config)
        self.add_widget_body(self.container, config)
        self.add_widget_footer(self.container, config, window)

    # 头部
    def add_widget_header(self, parent, config):
        def widget_init(widget):
            widget.set_checked(config.get("writing_style_switch"))

        def widget_callback(widget, checked: bool):
            config = self.load_config()
            config["writing_style_switch"] = checked
            self.save_config(config)

        parent.addWidget(
            SwitchButtonCard(
                self.tra("自定义翻译风格"),
                self.tra("启用此功能后，将根据本页中设置的内容构建翻译风格要求，并补充到基础提示词中（不支持本地类模型）"),
                widget_init,
                widget_callback,
            )
        )

    # 主体
    def add_widget_body(self, parent, config):
        self.plain_text_edit = PlainTextEdit(self)
        self.plain_text_edit.setPlainText(config.get("writing_style_content"))
        parent.addWidget(self.plain_text_edit)

    # 底部
    def add_widget_footer(self, parent, config, window):
        self.command_bar_card = CommandBarCard()
        parent.addWidget(self.command_bar_card)

        # 添加命令
        self.add_command_bar_action_01(self.command_bar_card)
        self.add_command_bar_action_02(self.command_bar_card, window)
    # 保存
    def add_command_bar_action_01(self, parent):
        def callback():
            # 读取配置文件
            config = self.load_config()

            # 从表格更新数据
            config["writing_style_content"] = self.plain_text_edit.toPlainText().strip()

            # 保存配置文件
            config = self.save_config(config)

            # 弹出提示
            info_cont = self.tra("数据已保存") + " ..."
            self.success_toast("", info_cont)

        parent.add_action(
            Action(FluentIcon.SAVE, self.tra("保存"), parent, triggered = callback),
        )

    # 重置
    def add_command_bar_action_02(self, parent, window):
        def callback():
            info_cont1 = self.tra("是否确认重置为默认数据")  + " ... ？"
            message_box = MessageBox("Warning", info_cont1, window)
            message_box.yesButton.setText(self.tra("确认"))
            message_box.cancelButton.setText(self.tra("取消"))

            if not message_box.exec():
                return

            # 清空控件
            self.plain_text_edit.setPlainText("")

            # 读取配置文件
            config = self.load_config()

            # 加载默认设置
            config["writing_style_content"] = self.default.get("writing_style_content")

            # 保存配置文件
            config = self.save_config(config)

            # 向控件更新数据
            self.plain_text_edit.setPlainText(config.get("writing_style_content"))

            # 弹出提示
            info_cont2 = self.tra("数据已重置")  + " ... "
            self.success_toast("", info_cont2)

        parent.add_action(
            Action(FluentIcon.DELETE,self.tra("重置"), parent, triggered = callback),
        )


================================================
FILE: UserInterface/VersionManager/VersionManager.py
================================================
import os
import re
import sys
import json
import signal
import threading
import requests
from PyQt5.QtCore import pyqtSignal, QObject, Qt
from PyQt5.QtWidgets import (QVBoxLayout, QHBoxLayout, QGridLayout, QWidget)


from qfluentwidgets import (MessageBox, CardWidget, TitleLabel, BodyLabel, StrongBodyLabel,
                            CaptionLabel, PrimaryPushButton, PushButton, ProgressBar,
                            TransparentToolButton, HyperlinkButton, FluentIcon,
                            InfoBar, InfoBarPosition, SubtitleLabel, MessageBoxBase)
from Base.Base import Base

class UpdaterSignals(QObject):
    progress_updated = pyqtSignal(int)
    download_completed = pyqtSignal(str)
    download_failed = pyqtSignal(str)
    update_check_completed = pyqtSignal(bool, str, bool, str)  # has_update, latest_version, check_failed, error_message
    download_url_found = pyqtSignal(str)  # 找到下载URL
    download_url_not_found = pyqtSignal()  # 未找到下载URL
    connection_error = pyqtSignal(int)  # 连接错误，参数为状态码
    general_error = pyqtSignal(str)  # 一般错误，参数为错误信息

# 更新对话框
class UpdateMessageBox(MessageBoxBase):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.hideCancelButton()
        self.hideYesButton()

        self.viewLayout.setContentsMargins(10, 10, 8, 8)
        self.viewLayout.setSpacing(6)
        self.buttonGroup.hide()


class VersionManager(Base):
    # GitHub API URL for releases
    GITHUB_API_URL = "https://api.github.com/repos/NEKOparapa/AiNiee/releases/latest"

    def __init__(self, main_window=None, version = "0.0.0"):
        super().__init__()
        self.main_window = main_window
        self.current_version = self._get_current_version(version)
        self.latest_version = None
        self.latest_version_url = None
        self.download_thread = None
        self.update_dialog = None
        self.signals = UpdaterSignals()

        self.signals.progress_updated.connect(self._update_progress)
        self.signals.download_completed.connect(self._download_completed)
        self.signals.download_failed.connect(self._download_failed)
        self.signals.update_check_completed.connect(self._update_dialog_after_check)
        self.signals.download_url_found.connect(self._start_download_with_url_from_main_thread)
        self.signals.download_url_not_found.connect(lambda: self._show_download_error(self.tra("未找到可下载的更新文件")))
        self.signals.connection_error.connect(self._show_connection_error)
        self.signals.general_error.connect(self._show_download_error)

    def _get_current_version(self,version):
        # re.search 会查找字符串中第一个匹配该模式的位置
        match = re.search(r'\d+(\.\d+)*', version)

        if match:
            return match.group(0) # 返回整个匹配到的字符串
        else:
            return "0.0.0"

    def check_for_updates(self):
        """检查是否需要更新"""
        try:
            response = requests.get(self.GITHUB_API_URL, timeout=10)
            if response.status_code == 200:
                data = response.json()
                # 从 tag_name 中提取版本号，格式为 "AiNiee6.2.3"
                tag_name = data["tag_name"]
                import re
                version_match = re.search(r'AiNiee([\d\.]+)', tag_name)
                if version_match:
                    self.latest_version = version_match.group(1)  # 提取数字部分，如 "6.2.3"
                else:
                    self.latest_version = tag_name.lstrip("v")  # 兼容其他格式

                self.latest_version_url = data["html_url"]

                # 比较版本
                if self._compare_versions(self.latest_version, self.current_version) > 0:
                    return True, self.latest_version
                else:
                    return False, self.current_version
            else:
                self.error(f"Failed to check for updates: {response.status_code}")

                self.check_error = f"{self.tra("HTTP错误")}: {response.status_code}"
                return False, self.current_version
        except Exception as e:
            self.error(f"Error checking for updates: {e}")

            self.check_error = str(e)
            return False, self.current_version

    def _compare_versions(self, version1, version2):
        """比较版本号"""
        v1_parts = [int(x) for x in version1.split(".")]
        v2_parts = [int(x) for x in version2.split(".")]

        # 填充版本号，使得版本号的位数相同
        while len(v1_parts) < 3:
            v1_parts.append(0)
        while len(v2_parts) < 3:
            v2_parts.append(0)

        for i in range(3):
            if v1_parts[i] > v2_parts[i]:
                return 1
            elif v1_parts[i] < v2_parts[i]:
                return -1

        return 0

    def show_update_dialog(self):
        """显示更新对话框"""
        if self.main_window is None:
            self.error("Main window reference is not set")
            return

        # 检查是否有已下载完成的更新文件
        local_filename = os.path.join("downloads", "AiNiee-update.zip")
        download_info_file = os.path.join("downloads", "download_info.json")

        if os.path.exists(local_filename) and os.path.exists(download_info_file):
            try:
                with open(download_info_file, 'r') as f:
                    download_info = json.load(f)

                if download_info.get("status") == "completed":
                    # 已有下载完成的更新文件，直接提示安装
                    msg_box = MessageBox(
                        self.tra("安装更新"),
                        self.tra("发现已下载完成的更新文件，是否立即安装？\n\n安装过程中应用将会关闭。"),
                        self.main_window
                    )
                    msg_box.yesButton.setText(self.tra("立即安装"))
                    msg_box.cancelButton.setText(self.tra("取消"))

                    if msg_box.exec():
                        # 运行更新器
                        self._run_updater(local_filename)
                    return
            except Exception as e:
                self.error(f"Error checking downloaded update: {e}")

        # 检查是否有未完成的下载
        temp_filename = os.path.join("downloads", "AiNiee-update.zip.temp")
        if os.path.exists(temp_filename) and os.path.exists(download_info_file):
            try:
                with open(download_info_file, 'r') as f:
                    download_info = json.load(f)

                if download_info.get("status") == "paused":
                    # 不放逻辑
                    pass
            except Exception as e:
                self.error(f"Error checking paused download: {e}")

        # 创建更新对话框 - 先显示加载状态
        self.update_dialog = UpdateMessageBox(self.main_window)

        # 创建标题卡片
        title_card = CardWidget(self.update_dialog)
        title_layout = QHBoxLayout(title_card)
        title_layout.setContentsMargins(16, 16, 16, 16)

        title_icon = TransparentToolButton(FluentIcon.UPDATE, self.update_dialog)
        title_icon.setFixedSize(32, 32)
        title_layout.addWidget(title_icon)
        title_label = TitleLabel(self.tra("软件更新"), title_card)

        title_layout.addWidget(title_label)
        title_layout.addStretch(1)
        title_card.setMinimumWidth(400)
        self.update_dialog.viewLayout.addWidget(title_card)

        # 创建加载状态卡片
        loading_card = CardWidget(self.update_dialog)
        loading_card.setObjectName("loading_card")
        loading_layout = QVBoxLayout(loading_card)
        loading_layout.setContentsMargins(16, 16, 16, 16)

        # 加载状态文本
        loading_label = SubtitleLabel(self.tra("正在检查更新..."), loading_card)
        loading_label.setAlignment(Qt.AlignCenter)
        loading_layout.addWidget(loading_label)

        # 添加到对话框
        self.update_dialog.viewLayout.addWidget(loading_card)

        # 显示对话框
        self.update_dialog.show()

        # 在后台线程中检查更新
        threading.Thread(target=self._check_update_in_background, daemon=True).start()

    def _check_update_in_background(self):
        """在后台线程中检查更新并更新UI"""
        try:
            # 初始化错误状态
            self.check_error = None

            # 检查更新
            has_update, latest_version = self.check_for_updates()

            # 使用实例变量中的错误信息
            check_error = getattr(self, 'check_error', None)

            # 通过信号在主线程中更新UI
            self.signals.update_check_completed.emit(
                has_update,
                latest_version,
                check_error is not None,
                check_error if check_error else ""
            )
        except Exception as e:
            self.error(f"Error in background update check: {e}")
            # 通过信号在主线程中更新UI，显示错误
            self.signals.update_check_completed.emit(
                False,
                self.current_version,
                True,
                str(e)
            )

    def _update_dialog_after_check(self, has_update, latest_version, check_failed, error_message):
        """更新检查完成后更新对话框内容"""
        # 移除加载状态卡片
        for i in range(self.update_dialog.viewLayout.count()):
            widget = self.update_dialog.viewLayout.itemAt(i).widget()
            if widget and widget.objectName() == "loading_card":
                widget.setParent(None)
                break

        # 在版本信息卡片部分修改
        version_card = CardWidget(self.update_dialog)
        version_layout = QGridLayout(version_card)
        version_layout.setContentsMargins(10, 16, 16, 16)
        version_layout.setVerticalSpacing(6)
        version_layout.setHorizontalSpacing(12)

        # 当前版本
        current_version_label = CaptionLabel(self.tra("当前版本") + ":", version_card)
        current_version_value = StrongBodyLabel(self.current_version, version_card)

        # 最新版本
        latest_version_label = CaptionLabel(self.tra("最新版本") + ":", version_card)

        if check_failed:
            # 检查失败，显示错误信息
            latest_version_value = StrongBodyLabel(self.tra("检查错误"), version_card)
            latest_version_value.setStyleSheet("color: #E53935;") # 红色错误提示
        else:
            # 检查成功，显示版本信息
            latest_version_value = StrongBodyLabel(latest_version, version_card)
            latest_version_value.setProperty("colorful", True)

            # 如果有新版本，显示为特别颜色
            if self._compare_versions(latest_version, self.current_version) > 0:
                latest_version_value.setStyleSheet("color: #2196F3;")

        version_layout.addWidget(current_version_label, 0, 0, Qt.AlignLeft)
        version_layout.addWidget(current_version_value, 0, 1, Qt.AlignLeft)
        version_layout.addWidget(latest_version_label, 1, 0, Qt.AlignLeft)
        version_layout.addWidget(latest_version_value, 1, 1, Qt.AlignLeft)

        # 版本说明文本
        # TODO 也许可以考虑从release的body中提取信息。但考虑到篇幅，可能不太合适（也许可以有概括部分）
        version_info_text = BodyLabel(self.tra("新版本包含了重要的更新和功能改进"), version_card)
        version_info_text.setMinimumHeight(20)  # 设置最小高度
        version_layout.addWidget(version_info_text, 2, 0, 1, 2)

        version_card.setMinimumHeight(100)
        self.update_dialog.viewLayout.addWidget(version_card)

        # 进度卡片 - 添加百分比标签
        progress_card = CardWidget(self.update_dialog)
        progress_layout = QVBoxLayout(progress_card)
        progress_layout.setContentsMargins(16, 16, 16, 16)
        progress_layout.setSpacing(8)

        # 左进度条，右百分比标签
        progress_hor_layout = QHBoxLayout()
        progress_hor_layout.setSpacing(10)

        # 进度条
        self.progress_bar = ProgressBar(progress_card)
        self.progress_bar.setVisible(False)
        self.progress_bar.setValue(0)
        self.progress_bar.setFixedHeight(8)
        self.progress_bar.setCustomBarColor("#A9DCD7", "#32E838") # 浅色和深色
        progress_hor_layout.addWidget(self.progress_bar, 1)

        # 百分比标签
        self.percentage_label = SubtitleLabel("0%", progress_card)
        self.percentage_label.setVisible(False)
        self.percentage_label.setMinimumWidth(50)  # 设置最小宽度确保有足够空间
        self.percentage_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        progress_hor_layout.addWidget(self.percentage_label)
        progress_layout.addLayout(progress_hor_layout)

        # 状态标签
        self.status_label = SubtitleLabel("", progress_card)
        self.status_label.setAlignment(Qt.AlignCenter)
        self.status_label.setWordWrap(True)  # 允许文本换行
        self.status_label.setMinimumHeight(30)  # 设置最小高度

        progress_layout.addWidget(self.status_label)

        progress_card.setMinimumHeight(100)
        self.update_dialog.viewLayout.addWidget(progress_card)

        # 按钮卡片
        button_card = CardWidget(self.update_dialog)
        button_layout = QHBoxLayout(button_card)
        button_layout.setContentsMargins(16, 16, 16, 16)
        button_layout.setSpacing(8)

        # 左侧按钮区域
        left_buttons = QWidget(button_card)
        left_buttons_layout = QHBoxLayout(left_buttons)
        left_buttons_layout.setContentsMargins(0, 0, 0, 0)
        left_buttons_layout.setSpacing(8)

        # 更新按钮
        self.update_button = PrimaryPushButton(self.tra("开始更新"), button_card)
        self.update_button.clicked.connect(self._start_update)
        # 取消按钮
        self.cancel_button = PushButton(self.tra("取消"), button_card)
        self.cancel_button.clicked.connect(self._cancel_update)

        # 暂停按钮
        self.pause_button = PushButton(self.tra("暂停"), button_card)
        self.pause_button.clicked.connect(self._pause_update)
        self.pause_button.setVisible(False)
        self.pause_button.setEnabled(False)

        # 继续按钮
        self.resume_button = PushButton(self.tra("继续"), button_card)
        self.resume_button.clicked.connect(self._resume_update)
        self.resume_button.setVisible(False)
        self.resume_button.setEnabled(False)

        left_buttons_layout.addWidget(self.update_button)
        left_buttons_layout.addWidget(self.cancel_button)
        left_buttons_layout.addWidget(self.pause_button)
        left_buttons_layout.addWidget(self.resume_button)

        # 右侧按钮区域
        right_buttons = QWidget(button_card)
        right_buttons_layout = QHBoxLayout(right_buttons)
        right_buttons_layout.setContentsMargins(0, 0, 0, 0)

        # 查看发布页链接
        self.view_release_button = HyperlinkButton(
            FluentIcon.LINK,
            self.latest_version_url if self.latest_version_url else "#",
            self.tra("查看发布页"),
        )


        right_buttons_layout.addWidget(self.view_release_button)

        button_layout.addWidget(left_buttons)
        button_layout.addStretch(1)
        button_layout.addWidget(right_buttons)
        button_card.setMinimumHeight(50)
        self.update_dialog.viewLayout.addWidget(button_card)

        # 处理不同状态
        if check_failed:
            # 检查失败
            self.update_button.setEnabled(False)
            version_info_text.setText(self.tra("无法检查更新，请稍后再试"))
            self.status_label.setText(f"{self.tra('检查失败')}: {error_message}")
            # 禁用发布页链接
            self.view_release_button.setEnabled(False)
        elif not has_update:
            # 没有更新
            self.update_button.setEnabled(False)
            version_info_text.setText(self.tra("您已经使用最新版本"))
            self.status_label.setText(self.tra("无需更新"))

    def _start_download_with_url(self, url):
        """使用指定URL开始下载"""
        # 重置标志
        self._cancel_download = False
        self._pause_download = False

        # 更新UI
        self.progress_bar.setVisible(True)
        self.percentage_label.setVisible(True)
        self.percentage_label.setText("0%")
        self.status_label.setText(self.tra("正在下载更新..."))
        self.update_button.setEnabled(False)
        self.pause_button.setVisible(True)
        self.pause_button.setEnabled(True)
        self.resume_button.setVisible(False)

        # 启动下载线程
        self.download_thread = threading.Thread(
            target=self._download_update,
            args=(url,)
        )
        self.download_thread.daemon = True
        self.download_thread.start()

    def _start_update(self):
        """开始更新进程"""
        self.progress_bar.setVisible(True)
        self.percentage_label.setVisible(True)
        self.percentage_label.setText("0%")
        self.status_label.setText(self.tra("正在获取下载链接..."))
        self.update_button.setEnabled(False)

        # 在后台线程中获取下载URL
        threading.Thread(target=self._get_download_url_in_background, daemon=True).start()

    def _get_download_url_in_background(self):
        """在后台线程中获取下载URL"""
        try:
            response = requests.get(self.GITHUB_API_URL, timeout=10)
            if response.status_code == 200:
                data = response.json()
                download_url = None

                # 查找.zip扩展名的资产
                for asset in data["assets"]:
                    if asset["name"].endswith(".zip"):
                        download_url = asset["browser_download_url"]
                        break

                # 改用信号更新Ui
                if download_url:
                    # 发送找到下载URL的信号
                    self.signals.download_url_found.emit(download_url)
                else:
                    # 发送未找到下载URL的信号
                    self.signals.download_url_not_found.emit()
            else:
                # 发送连接错误信号
                self.signals.connection_error.emit(response.status_code)
        except Exception as e:
            self.error(f"Error starting update: {e}")
            # 发送一般错误信号
            self.signals.general_error.emit(str(e))

    def _start_download_with_url_from_main_thread(self, url):
        """从主线程中调用_start_download_with_url"""
        self._start_download_with_url(url)

    def _show_download_error(self, error_msg):
        """显示下载错误"""
        self.status_label.setText(self.tra("更新失败"))
        self.update_button.setEnabled(True)
        self.pause_button.setVisible(False)
        self.percentage_label.setVisible(False)

        if self.main_window:
            InfoBar.error(
                title=self.tra("下载错误"),
                content=error_msg,
                orient=Qt.Horizontal,
                isClosable=True,
                position=InfoBarPosition.TOP,
                duration=3000,
                parent=self.main_window
            )

    def _show_connection_error(self, status_code):
        """显示连接错误"""
        self.status_label.setText(self.tra("获取下载链接失败"))
        self.update_button.setEnabled(True)
        self.pause_button.setVisible(False)
        self.percentage_label.setVisible(False)

        if self.main_window:
            InfoBar.error(
                title=self.tra("连接错误"),
                content=f"{self.tra('无法连接到更新服务器')} ({status_code})",
                orient=Qt.Horizontal,
                isClosable=True,
                position=InfoBarPosition.TOP,
                duration=3000,
                parent=self.main_window
            )

    def _download_update(self, url):
        """下载更新文件，支持断点续传"""
        try:
            # 如果目录不存在，则创建
            os.makedirs("downloads", exist_ok=True)

            # 完成的文件名和临时文件名
            local_filename = os.path.join("downloads", "AiNiee-update.zip")
            temp_filename = os.path.join("downloads", "AiNiee-update.zip.temp")
            download_info_file = os.path.join("downloads", "download_info.json")

            # 检查是否已经存在完成的文件
            if os.path.exists(local_filename):
                self.info(f"Found completed download file: {local_filename}")
                self.signals.download_completed.emit(local_filename)
                return

            # 获取文件大小信息
            file_size_response = requests.head(url, allow_redirects=True)
            total_size = int(file_size_response.headers.get('content-length', 0))

            # 记录下载信息
            download_info = {
                "url": url,
                "total_size": total_size,
                "downloaded": 0,
                "status": "downloading"
            }

            # 检查是否存在临时文件，如果存在则续传
            downloaded = 0
            headers = {}

            if os.path.exists(temp_filename) and os.path.exists(download_info_file):
                try:
                    with open(download_info_file, 'r') as f:
                        saved_info = json.load(f)

                    # 验证URL是否相同
                    if saved_info.get("url") == url:
                        downloaded = os.path.getsize(temp_filename)
                        if downloaded < total_size:
                            # 设置Range头部进行续传
                            headers['Range'] = f'bytes={downloaded}-'
                            self.info(f"Resuming download from {downloaded} bytes")
                            download_info["downloaded"] = downloaded
                except Exception as e:
                    self.error(f"Error reading download info: {e}")
                    downloaded = 0

            # 保存下载信息
            with open(download_info_file, 'w') as f:
                json.dump(download_info, f)

            # 开始下载
            mode = 'ab' if downloaded > 0 else 'wb'

            with requests.get(url, stream=True, headers=headers) as r:
                r.raise_for_status()
                block_size = 8192

                with open(temp_filename, mode) as f:
                    for chunk in r.iter_content(chunk_size=block_size):
                        if getattr(self, '_cancel_download', False):
                            # 取消下载
                            download_info["status"] = "canceled"
                            with open(download_info_file, 'w') as info_file:
                                json.dump(download_info, info_file)
                            self.signals.download_failed.emit(self.tra("下载已取消"))
                            return

                        if getattr(self, '_pause_download', False):
                            # 暂停下载
                            download_info["status"] = "paused"
                            download_info["downloaded"] = downloaded
                            with open(download_info_file, 'w') as info_file:
                                json.dump(download_info, info_file)

                            self.signals.download_failed.emit(self.tra("下载已暂停"))
                            return

                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)
                            download_info["downloaded"] = downloaded

                            # 定期更新下载信息
                            if downloaded % (block_size * 100) == 0:
                                with open(download_info_file, 'w') as info_file:
                                    json.dump(download_info, info_file)

                            if total_size > 0:
                                progress = int(downloaded * 100 / total_size)
                                self.signals.progress_updated.emit(progress)

            # 下载完成，将临时文件重命名为正式文件
            download_info["status"] = "completed"
            with open(download_info_file, 'w') as info_file:
                json.dump(download_info, info_file)

            # 重命名文件
            if os.path.exists(temp_filename):
                if os.path.exists(local_filename):
                    os.remove(local_filename)  # 删除已存在的文件
                os.rename(temp_filename, local_filename)
                self.info(f"Download completed and renamed to {local_filename}")

            self.signals.download_completed.emit(local_filename)
        except Exception as e:
            self.error(f"Download failed: {e}")
            self.signals.download_failed.emit(str(e))

    def _update_progress(self, progress):
        """更新进度条和百分比标签"""
        if self.progress_bar and self.percentage_label:
            self.progress_bar.setValue(progress)
            self.percentage_label.setText(f"{progress}%")
            if progress >= 100:
                self.status_label.setText(self.tra("下载完成，准备安装..."))

    def _download_completed(self, filename):
        """Handle download completion"""
        # 先关闭更新对话框，避免UI阻塞
        if self.update_dialog:
            self.update_dialog.accept()

        # 然后显示确认对话框
        msg_box = MessageBox(
            self.tra("更新确认"),
            self.tra("下载完成，是否立即安装更新？\n\n安装过程中应用将会关闭。\n如果选择'稍后安装'，可以通过更新按钮重新安装。"),
            self.main_window
        )
        msg_box.yesButton.setText(self.tra("立即安装"))
        msg_box.cancelButton.setText(self.tra("稍后安装"))

        if msg_box.exec():
            # 通过rust更新器更新
            self._run_updater(filename)
        else:
            # 将下载的文件路径保存到配置文件中，便于稍后安装
            config = self.load_config()
            config["pending_update_file"] = filename
            self.save_config(config)

            # 显示成功提示
            if self.main_window:
                self.main_window.success_toast(self.tra("更新已下载"), self.tra("更新已下载，可以通过更新按钮重新安装"))

    def _download_failed(self, error_msg):
        """Handle download failure or pause"""
        # 检查是否是暂停状态
        if error_msg == self.tra("下载已暂停"):
            # 暂停状态，显示继续按钮
            self.status_label.setText(self.tra("下载已暂停"))
            self.update_button.setEnabled(False)
            self.pause_button.setVisible(False)
            self.resume_button.setVisible(True)
            self.resume_button.setEnabled(True)

            # 不显示错误提示，因为这是用户主动操作
            return

        # 其他失败情况
        self.status_label.setText(f"{self.tra('下载失败')}: {error_msg}")
        self.update_button.setEnabled(True)
        self.pause_button.setVisible(False)
        self.resume_button.setVisible(False)
        self.percentage_label.setVisible(False)

        if self.main_window:
            InfoBar.error(
                title=self.tra("下载失败"),
                content=error_msg,
                orient=Qt.Horizontal,
                isClosable=True,
                position=InfoBarPosition.TOP,
                duration=3000,
                parent=self.main_window
            )

    def _pause_update(self):
        # 只设置暂停标志，UI更新由_download_failed方法处理
        self._pause_download = True
        # 禁用暂停按钮，防止用户多次点击
        self.pause_button.setEnabled(False)

    def _resume_update(self):
        """Resume the update download"""
        self._pause_download = False
        self.resume_button.setVisible(False)
        self.pause_button.setVisible(True)
        self.pause_button.setEnabled(True)
        self.status_label.setText(self.tra("正在恢复下载..."))

        # 读取下载信息文件，获取URL
        try:
            download_info_file = os.path.join("downloads", "download_info.json")
            if os.path.exists(download_info_file):
                with open(download_info_file, 'r') as f:
                    download_info = json.load(f)

                # 获取URL并重新开始下载
                url = download_info.get("url")
                if url:
                    # 启动下载线程
                    self.download_thread = threading.Thread(
                        target=self._download_update,
                        args=(url,)
                    )
                    self.download_thread.daemon = True
                    self.download_thread.start()
                    return
        except Exception as e:
            self.error(f"Error resuming download: {e}")

        # 如果恢复失败，显示错误信息
        self.status_label.setText(self.tra("恢复下载失败"))
        self.update_button.setEnabled(True)
        self.resume_button.setVisible(False)

    def _cancel_update(self):
        """Cancel the update process"""
        # 无论下载线程是否正在运行，都先关闭对话框
        if self.update_dialog:
            self.update_dialog.reject()

        # 如果下载线程正在运行，设置取消标志
        if self.download_thread and self.download_thread.is_alive():
            self._cancel_download = True
            # 显示取消提示
            if self.main_window:
                self.main_window.warning_toast(self.tra("下载取消"), self.tra("正在取消下载，请稍候..."))


    def _run_updater(self, update_file):
        """Run the updater executable"""
        try:
            # Get the current directory
            current_dir = os.path.dirname(os.path.abspath(sys.argv[0]))


            import subprocess
            updater_path = os.path.join(current_dir, "Resource", "Updater", "updater.exe")

            if os.path.exists(updater_path):
                # 使用PowerShell启动更新器
                powershell_command = f'Start-Process -FilePath "{updater_path}" -ArgumentList "{update_file}", "{current_dir}" -WindowStyle Normal'

                # 启动PowerShell并执行命令
                subprocess.Popen([
                    "powershell.exe",
                    "-Command",
                    powershell_command
                ],
                shell=True,
                creationflags=subprocess.CREATE_NO_WINDOW)

                # 退出当前程序
                os.kill(os.getpid(), signal.SIGTERM)

            else:
                self.error(f"Updater not found: {updater_path}")
                self.status_label.setText(self.tra("更新程序未找到"))
                # 显示错误提示
                if self.main_window:
                    InfoBar.error(
                        title=self.tra("更新错误"),
                        content=self.tra("找不到更新程序，请手动下载安装最新版本"),
                        orient=Qt.Horizontal,
                        isClosable=True,
                        position=InfoBarPosition.TOP,
                        duration=3000,
                        parent=self.main_window
                    )
        except Exception as e:
            self.error(f"Failed to run updater: {e}")
            self.status_label.setText(f"{self.tra('启动更新程序失败')}: {str(e)}")
            # 显示错误提示
            if self.main_window:
                InfoBar.error(
                    title=self.tra("更新错误"),
                    content=f"{self.tra('启动更新程序失败')}: {str(e)}",
                    orient=Qt.Horizontal,
                    isClosable=True,
                    position=InfoBarPosition.TOP,
                    duration=3000,
                    parent=self.main_window
                )



================================================
FILE: Widget/ActionCard.py
================================================
###源码
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout
from qfluentwidgets import (CardWidget, StrongBodyLabel, CaptionLabel,
                            PushButton, pyqtSignal)

class ActionCard(CardWidget):
    """
    一个左侧显示描述文本，右侧显示一个操作按钮的卡片组件。
    """
    clicked = pyqtSignal()  # 定义一个点击信号

    def __init__(self, title: str, description: str, button_text: str, icon=None, parent=None):
        super().__init__(parent)
        self.setBorderRadius(4)

        # 主布局
        self.hbox = QHBoxLayout(self)
        self.hbox.setContentsMargins(16, 16, 16, 16)
        self.hbox.setSpacing(12)

        # 左侧文本布局
        self.vbox = QVBoxLayout()
        self.titleLabel = StrongBodyLabel(title, self)
        self.descriptionLabel = CaptionLabel(description, self)
        self.descriptionLabel.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))
        
        self.vbox.addWidget(self.titleLabel)
        self.vbox.addWidget(self.descriptionLabel)
        self.vbox.setSpacing(4)

        # 中间的项目名标签
        self.project_name_label = CaptionLabel("", self)
        self.project_name_label.setObjectName('projectNameLabel')
        self.project_name_label.hide() # 默认隐藏

        # 右侧按钮
        self.button = PushButton(icon, button_text, self) if icon else PushButton(button_text, self)
        self.button.setFixedWidth(120)
        self.button.setFixedHeight(32)

        # 组装布局
        self.hbox.addLayout(self.vbox)
        self.hbox.addStretch(1)
        self.hbox.addWidget(self.project_name_label) # 将项目名标签放在中间
        self.hbox.addStretch(1)
        self.hbox.addWidget(self.button)

        # 信号连接
        self.button.clicked.connect(self.clicked)

    # 设置项目名并显示标签的方法
    def set_project_name(self, name: str):
        """设置项目名并显示标签"""
        if name:
            self.project_name_label.setText(f"项目: {name}")
            self.project_name_label.show()
        else:
            self.project_name_label.hide()
            
    # 隐藏项目名标签的方法
    def hide_project_name(self):
        """隐藏项目名标签"""
        self.project_name_label.hide()


================================================
FILE: Widget/APITypeCard.py
================================================
from PyQt5.QtGui import QColor 
from PyQt5.QtWidgets import QFrame, QHBoxLayout, QVBoxLayout, QWidget 

from qfluentwidgets import (
    CardWidget, FlowLayout, CaptionLabel, StrongBodyLabel,HorizontalSeparator,
    IconWidget, FluentIcon 
)

class APITypeCard(CardWidget):
    def __init__(self, title: str, description: str, icon: FluentIcon = None, parent: QWidget = None, init=None):

        super().__init__(parent)

        # --- 基础设置 ---
        self.setBorderRadius(8) # 增加圆角
        self.setContentsMargins(0, 0, 0, 0) 

        # --- 主垂直布局 ---
        self.container = QVBoxLayout(self)
        self.container.setContentsMargins(16, 12, 16, 16) # 调整边距 (左, 上, 右, 下) 
        self.container.setSpacing(12) 

        # --- 头部区域 (图标 + 文本) ---
        self.head_container = QFrame(self) 
        self.head_hbox = QHBoxLayout(self.head_container)
        self.head_hbox.setContentsMargins(0, 0, 0, 0) # 头部内部无额外边距
        self.head_hbox.setSpacing(12) # 图标和文本之间的间距

        # 可选：添加图标
        self.icon_widget = None
        if icon:
            self.icon_widget = IconWidget(icon, self)
            self.icon_widget.setFixedSize(20, 20) 
            self.head_hbox.addWidget(self.icon_widget)

        # 文本容器 (标题 + 描述)
        self.text_container = QFrame(self) 
        self.text_vbox = QVBoxLayout(self.text_container)
        self.text_vbox.setContentsMargins(0, 0, 0, 0)
        self.text_vbox.setSpacing(4) # 标题和描述之间的间距可以小一些

        self.title_label = StrongBodyLabel(title, self)
        self.text_vbox.addWidget(self.title_label)

        self.description_label = CaptionLabel(description, self)
        self.text_vbox.addWidget(self.description_label)

        self.head_hbox.addWidget(self.text_container, 1) # 让文本区域占据主要空间

        # 添加头部容器到主布局
        self.container.addWidget(self.head_container)

        # --- 分割线 ---

        self.line = HorizontalSeparator(self)
        self.container.addWidget(self.line)

        # --- 流式布局区域 ---
        self.flow_container = QFrame(self) # Frame 用于容纳 FlowLayout
        self.flow_layout = FlowLayout(self.flow_container, needAni=False) 
        self.flow_layout.setContentsMargins(0, 0, 0, 0) # 流式布局本身无边距
        self.flow_layout.setHorizontalSpacing(8) # 水平间距
        self.flow_layout.setVerticalSpacing(8)   # 垂直间距
        self.container.addWidget(self.flow_container)

        # --- 初始化回调 ---
        if init:
            init(self)

    def set_title(self, title: str) -> None:
        """设置卡片标题"""
        self.title_label.setText(title)

    def set_description(self, description: str) -> None:
        """设置卡片描述"""
        self.description_label.setText(description)

    def set_icon(self, icon: FluentIcon) -> None:
        """设置或更新卡片图标"""
        if self.icon_widget:
            self.icon_widget.setIcon(icon)
        elif icon: 
            self.icon_widget = IconWidget(icon, self)
            self.icon_widget.setFixedSize(20, 20)
            # 插入到 HBox 的最前面
            self.head_hbox.insertWidget(0, self.icon_widget)

    def add_widget(self, widget: QWidget) -> None:
        """向流式布局区域添加控件"""
        self.flow_layout.addWidget(widget)

    def add_widget_to_head(self, widget: QWidget, stretch: int = 0) -> None:
        """
        向头部区域添加控件（在文本区域之后）。
        """
        if stretch > 0:
            self.head_hbox.addStretch(stretch)
        self.head_hbox.addWidget(widget)

    def take_all_widgets(self) -> list[QWidget]:
        """移除流式布局中的所有控件并返回它们（不删除）"""
        return self.flow_layout.takeAllWidgets()

    def clear_widgets(self) -> None:
        """移除并删除流式布局中的所有控件"""
        widgets = self.flow_layout.takeAllWidgets()
        for widget in widgets:
            widget.deleteLater()


================================================
FILE: Widget/CombinedLineCard.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout
from qfluentwidgets import CardWidget, LargeTitleLabel, StrongBodyLabel, IconWidget, FluentIcon, BodyLabel, CaptionLabel

class CombinedLineCard(CardWidget):
    def __init__(self,
                 title: str,
                 icon: FluentIcon = None,
                 left_title: str = "Metric 1",
                 right_title: str = "Metric 2",
                 initial_left_value: str = "0",
                 initial_left_unit: str = "",
                 initial_right_value: str = "0",
                 initial_right_unit: str = "",
                 parent: QWidget = None,
                 clicked=None
                 ):
        super().__init__(parent)

        # --- 基本卡片设置 ---
        self.setBorderRadius(8)

        # --- 主布局 ---
        self.mainLayout = QVBoxLayout(self)
        self.mainLayout.setContentsMargins(16, 12, 16, 12)
        self.mainLayout.setSpacing(8)

        # --- 顶部区域：图标（可选）和标题 ---
        self.topLayout = QHBoxLayout()
        self.topLayout.setContentsMargins(0, 0, 0, 0)
        self.topLayout.setSpacing(8)

        if icon:
            self.iconWidget = IconWidget(icon, self)
            self.iconWidget.setFixedSize(18, 18)
            self.topLayout.addWidget(self.iconWidget)
        else:
            self.iconWidget = None

        self.titleLabel = BodyLabel(title, self)
        self.titleLabel.setTextColor("#606060")
        self.topLayout.addWidget(self.titleLabel, 1)

        # --- 底部区域：左右数据和分割线 ---
        self.bottomLayout = QHBoxLayout()
        self.bottomLayout.setContentsMargins(0, 5, 0, 0)
        self.bottomLayout.setSpacing(15) # 左右数据区域和分割线区域的总间距

        # --- 左侧数据 ---
        self.leftDataLayout = QVBoxLayout()
        self.leftDataLayout.setContentsMargins(0, 0, 0, 0)
        self.leftDataLayout.setSpacing(4)
        self.leftDataLayout.setAlignment(Qt.AlignCenter)

        self.leftTitleLabel = CaptionLabel(left_title, self)
        self.leftTitleLabel.setAlignment(Qt.AlignCenter)
        self.leftDataLayout.addWidget(self.leftTitleLabel)

        self.leftValueLayout = QHBoxLayout()
        self.leftValueLayout.setContentsMargins(0, 0, 0, 0)
        self.leftValueLayout.setSpacing(4)
        self.leftValueLayout.setAlignment(Qt.AlignCenter)

        self.leftValueLabel = LargeTitleLabel(initial_left_value, self)
        self.leftUnitLabel = StrongBodyLabel(initial_left_unit, self)
        self.leftUnitLabel.setAlignment(Qt.AlignBottom)
        self.leftUnitLabel.setTextColor("#404040")

        self.leftValueLayout.addStretch(1)
        self.leftValueLayout.addWidget(self.leftValueLabel)
        self.leftValueLayout.addWidget(self.leftUnitLabel)
        self.leftValueLayout.addStretch(1)
        self.leftDataLayout.addLayout(self.leftValueLayout)

        self.bottomLayout.addLayout(self.leftDataLayout, 1)

        # ---分割线 ---
        separatorLayout = QVBoxLayout()
        separatorLayout.setContentsMargins(0, 0, 0, 0) # 内部边距为0
        separatorLayout.setSpacing(0) # 内部间距为0

        separatorLayout.addStretch(1) # 在线上方添加伸缩

        # 创建实际的线 (QWidget)
        line = QWidget(self)
        line.setFixedWidth(1)  # 宽度为1像素，使其成为垂直线
        line.setFixedHeight(35) # 设置线的固定高度，使其变短 
        line.setStyleSheet("QWidget { background-color: #C0C0C0; }")

        separatorLayout.addWidget(line, 0, Qt.AlignCenter) # 将线添加到布局中，水平居中

        separatorLayout.addStretch(1) # 在线下方添加伸缩

        # 将包含线的布局添加到主底部布局中
        self.bottomLayout.addLayout(separatorLayout) # 不设置拉伸因子，让它只占用必要的宽度

        # --- 右侧数据 ---
        self.rightDataLayout = QVBoxLayout()
        self.rightDataLayout.setContentsMargins(0, 0, 0, 0)
        self.rightDataLayout.setSpacing(4)
        self.rightDataLayout.setAlignment(Qt.AlignCenter)

        self.rightTitleLabel = CaptionLabel(right_title, self)
        self.rightTitleLabel.setAlignment(Qt.AlignCenter)
        self.rightDataLayout.addWidget(self.rightTitleLabel)

        self.rightValueLayout = QHBoxLayout()
        self.rightValueLayout.setContentsMargins(0, 0, 0, 0)
        self.rightValueLayout.setSpacing(4)
        self.rightValueLayout.setAlignment(Qt.AlignCenter)

        self.rightValueLabel = LargeTitleLabel(initial_right_value, self)
        self.rightUnitLabel = StrongBodyLabel(initial_right_unit, self)
        self.rightUnitLabel.setAlignment(Qt.AlignBottom)
        self.rightUnitLabel.setTextColor("#404040")

        self.rightValueLayout.addStretch(1)
        self.rightValueLayout.addWidget(self.rightValueLabel)
        self.rightValueLayout.addWidget(self.rightUnitLabel)
        self.rightValueLayout.addStretch(1)
        self.rightDataLayout.addLayout(self.rightValueLayout)

        self.bottomLayout.addLayout(self.rightDataLayout, 1)

        # --- 添加到主容器 ---
        self.mainLayout.addLayout(self.topLayout)
        self.mainLayout.addSpacing(4)
        self.mainLayout.addLayout(self.bottomLayout, 1)

        # --- 添加点击信号 ---
        if clicked:
            self.clicked.connect(clicked)

    # --- 后续方法保持不变 ---
    def set_left_data(self, value: str, unit: str):
        self.leftValueLabel.setText(str(value))
        self.leftUnitLabel.setText(unit)

    def set_right_data(self, value: str, unit: str):
        self.rightValueLabel.setText(str(value))
        self.rightUnitLabel.setText(unit)

    def set_left_title(self, title: str):
        self.leftTitleLabel.setText(title)

    def set_right_title(self, title: str):
        self.rightTitleLabel.setText(title)

    def set_main_title(self, title: str):
        self.titleLabel.setText(title)

    def set_icon(self, icon: FluentIcon):
        if self.iconWidget:
            self.iconWidget.setIcon(icon)

    def set_left_value_color(self, color: str):
        self.leftValueLabel.setStyleSheet(f"color: {color};")

    def set_right_value_color(self, color: str):
        self.rightValueLabel.setStyleSheet(f"color: {color};")

# --- 示例用法 (如果需要测试) ---
if __name__ == '__main__':
    import sys
    from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout
    from qfluentwidgets import FluentIcon

    app = QApplication(sys.argv)
    window = QWidget()
    window.setWindowTitle("CombinedLineCard Example")
    layout = QVBoxLayout(window)

    card1 = CombinedLineCard(
        title="System Status",
        icon=FluentIcon.SPEED_HIGH,
        left_title="CPU Usage",
        right_title="Memory Usage",
        initial_left_value="45",
        initial_left_unit="%",
        initial_right_value="6.8",
        initial_right_unit="GB"
    )

    card2 = CombinedLineCard(
        title="Network Activity",
        icon=FluentIcon.WIFI,
        left_title="Download",
        right_title="Upload",
        initial_left_value="12.5",
        initial_left_unit="MB/s",
        initial_right_value="2.1",
        initial_right_unit="MB/s"
    )
    card2.set_left_value_color("green")
    card2.set_right_value_color("orange")


    layout.addWidget(card1)
    layout.addWidget(card2)
    layout.addStretch(1)
    window.resize(350, 300)
    window.show()
    sys.exit(app.exec_())


================================================
FILE: Widget/ComboBoxCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import ComboBox
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class ComboBoxCard(CardWidget):

    def __init__(self, title: str, description: str, items: list, init = None, current_text_changed = None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.hbox = QHBoxLayout(self)
        self.hbox.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox = QVBoxLayout()

        self.title_label = StrongBodyLabel(title, self)
        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))

        self.vbox.addWidget(self.title_label)
        self.vbox.addWidget(self.description_label)
        self.hbox.addLayout(self.vbox)

        # 填充
        self.hbox.addStretch(1)

        # 下拉框控件
        self.combo_box = ComboBox(self)
        self.combo_box.addItems(items)
        self.hbox.addWidget(self.combo_box)

        if init:
            init(self)

        if current_text_changed:
            self.combo_box.currentTextChanged.connect(lambda text: current_text_changed(self, text))

    def set_items(self, items: list) -> None:
        self.combo_box.clear()
        self.combo_box.addItems(items)

    def find_text(self, text: str) -> int:
        return self.combo_box.findText(text)

    def get_current_text(self) -> str:
        return self.combo_box.currentText()

    def set_current_index(self, index) -> None:
        self.combo_box.setCurrentIndex(index)


================================================
FILE: Widget/CommandBarCard.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QHBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import Action
from qfluentwidgets import CommandBar

class CommandBarCard(CardWidget):

    def __init__(self, ):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.hbox = QHBoxLayout(self)
        self.hbox.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.command_bar = CommandBar()
        self.command_bar.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        self.hbox.addWidget(self.command_bar)

    def add_widget(self, widget):
        return self.hbox.addWidget(widget)

    def add_stretch(self, stretch: int):
        self.hbox.addStretch(stretch)

    def add_spacing(self, spacing: int):
        self.hbox.addSpacing(spacing)

    def add_action(self, action: Action):
        return self.command_bar.addAction(action)

    def add_separator(self):
        self.command_bar.addSeparator()

    def set_minimum_width(self, min_width: int):
        self.command_bar.setMinimumWidth(min_width)


================================================
FILE: Widget/DashboardCard.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout
from qfluentwidgets import CardWidget, LargeTitleLabel, StrongBodyLabel, IconWidget, FluentIcon, BodyLabel 

class DashboardCard(CardWidget):
    def __init__(self,
                 title: str,
                 value: str,
                 unit: str,
                 icon: FluentIcon = None, 
                 parent: QWidget = None, 
                 clicked = None
                 ):
        super().__init__(parent)

        # --- 基本设置 ---
        self.setBorderRadius(8) # 稍大的半径以获得更柔和的外观

        # --- 主布局 ---
        self.mainLayout = QVBoxLayout(self)
        self.mainLayout.setContentsMargins(16, 12, 16, 12) # 调整边距
        self.mainLayout.setSpacing(8) # 各部分之间保持一致的间距

        # --- 顶部区域：图标（可选）和标题 ---
        self.topLayout = QHBoxLayout()
        self.topLayout.setContentsMargins(0, 0, 0, 0)
        self.topLayout.setSpacing(8) # 图标和标题之间的间距

        # 设置图标
        if icon:
            self.iconWidget = IconWidget(icon, self)
            self.iconWidget.setFixedSize(18, 18) # 根据需要调整图标大小
            self.topLayout.addWidget(self.iconWidget)
        else:
            self.iconWidget = None # 如果存在图标则进行跟踪

        self.titleLabel = BodyLabel(title, self) 
        self.titleLabel.setTextColor("#606060")
        self.topLayout.addWidget(self.titleLabel, 1) 

        # --- 中间区域：数值和单位 ---
        self.valueLabel = LargeTitleLabel(value, self)
        self.unitLabel = StrongBodyLabel(unit, self)
        self.unitLabel.setAlignment(Qt.AlignBottom) # 将单位对齐到数值标签行的底部
        self.unitLabel.setTextColor("#404040") 

        self.valueLayout = QHBoxLayout()
        self.valueLayout.setContentsMargins(0, 0, 0, 0)
        self.valueLayout.setSpacing(4) 
        self.valueLayout.setAlignment(Qt.AlignCenter) # 水平居中数值和单位
        self.valueLayout.addStretch(1) # 在之前添加伸缩项
        self.valueLayout.addWidget(self.valueLabel)
        self.valueLayout.addWidget(self.unitLabel)
        self.valueLayout.addStretch(1) # 在之后添加伸缩项

        # 添加进主布局
        self.mainLayout.addLayout(self.topLayout)
        self.mainLayout.addSpacing(4) # 在数值前的少量间距
        self.mainLayout.addLayout(self.valueLayout, 1) 

        # 连接信号
        if clicked:
            self.clicked.connect(clicked) # 连接卡片的点击信号

        # 连接信号示例：带有图标的 CPU 使用率
        #cpu_card = DashboardCard(
        #    title="CPU 使用率",
        #    value="75",
        #    unit="%",
        #    icon=FluentIcon.ACCEPT_MEDIUM,
        #    parent=centralWidget,
        #    clicked=lambda: card_clicked_action("CPU 使用率")
        #)

    def set_value(self, value: str):
        """设置主数值文本。"""
        self.valueLabel.setText(str(value)) # 确保数值是字符串

    def set_unit(self, unit: str):
        """设置单位文本。"""
        self.unitLabel.setText(unit)

    def set_title(self, title: str):
        """设置标题文本。"""
        self.titleLabel.setText(title)

    def set_icon(self, icon: FluentIcon):
        """设置或更新图标。"""
        if self.iconWidget:
            self.iconWidget.setIcon(icon)

    def set_value_color(self, color: str):
        """设置数值标签的颜色（例如，根据状态）。"""
        self.valueLabel.setStyleSheet(f"color: {color};")

        # 设置数值文本颜色
        #cpu_card.set_value_color("orange")



================================================
FILE: Widget/EditableComboBoxCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout, QVBoxLayout, QWidget
from PyQt5.QtCore import pyqtSignal

from qfluentwidgets import (
    CardWidget, CaptionLabel, LineEdit, MessageBoxBase, PushButton, StrongBodyLabel,
    EditableComboBox, SubtitleLabel, FluentIcon, ToolButton, RoundMenu, Action,
    TransparentDropDownToolButton
)


class EditableComboBoxCard(CardWidget):
    # 当用户选择“从接口获取模型”时发出，交由上层页面处理网络请求
    fetch_models_requested = pyqtSignal()
    items_changed = pyqtSignal(list)  # 添加一个信号，用于通知外部选项列表已更改

    def __init__(self, title: str, description: str, items: list[str], init = None, current_text_changed = None, current_index_changed = None):
        super().__init__(None)

        self._items = items.copy()  # 存储原始 items 列表，用于弹出窗口编辑
        # 设置容器
        self.setBorderRadius(4)
        self.container = QHBoxLayout(self)
        self.container.setContentsMargins(16, 16, 16, 16)  # 左、上、右、下

        # 文本控件
        self.vbox = QVBoxLayout()

        self.title_label = StrongBodyLabel(title, self)
        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))

        self.vbox.addWidget(self.title_label)
        self.vbox.addWidget(self.description_label)
        self.container.addLayout(self.vbox)

        # 填充
        self.container.addStretch(1)

        # 下拉框控件
        self.combo_box = EditableComboBox(self)
        self.set_items(items) # 使用 set_items 初始化，确保 _items 被正确设置
        self.container.addWidget(self.combo_box)

        # 编辑/获取 按钮（带下拉菜单）
        self.edit_button = TransparentDropDownToolButton(FluentIcon.EDIT, self)
        menu = RoundMenu(parent=self)
        # 1) 手动编辑列表
        action_edit = Action(self.tra("编辑列表")) if hasattr(self, 'tra') else Action("编辑列表")
        action_edit.triggered.connect(self._show_edit_items_popup)
        menu.addAction(action_edit)
        # 2) 从接口获取模型
        action_fetch = Action(self.tra("从接口获取模型")) if hasattr(self, 'tra') else Action("从接口获取模型")
        action_fetch.triggered.connect(self._emit_fetch_models_requested)
        menu.addAction(action_fetch)

        self.edit_button.setMenu(menu)
        self.container.addWidget(self.edit_button)


        if init:
            init(self)

        if current_text_changed:
            self.combo_box.currentTextChanged.connect(lambda text: current_text_changed(self, text))

        if current_index_changed:
            self.combo_box.currentIndexChanged.connect(lambda index: current_index_changed(self, index))

    # 设置列表条目
    def set_items(self, items: list) -> None:
        self._items = items.copy() # 更新内部存储的 items 列表
        self.combo_box.clear()
        self.combo_box.addItems(items)

    # 通过文本查找索引
    def find_text(self, text: str) -> int:
        return self.combo_box.findText(text)

    # 获取当前文本
    def get_current_text(self) -> str:
        return self.combo_box.currentText()

    # 设置当前索引
    def set_current_index(self, index) -> None:
        self.combo_box.setCurrentIndex(index)

    # 设置宽度
    def set_fixed_width(self, width: int) -> None:
        self.combo_box.setFixedWidth(width)

    # 设置占位符
    def set_placeholder_text(self, text: str) -> None:
        self.combo_box.setPlaceholderText(text)

    # 显示编辑模型框
    def _show_edit_items_popup(self):
        dialog = EditItemsMessageBox(self._items, self.window())  # 使用顶层窗口作为parent，否则位置错乱
        if dialog.exec_():
            new_items = dialog.get_items()
            if new_items:
                self.set_items(new_items)
                self.items_changed.emit(new_items)

    # 发出“从接口获取模型”的信号，由上层决定如何请求与展示
    def _emit_fetch_models_requested(self):
        self.fetch_models_requested.emit()



class EditItemsMessageBox(MessageBoxBase):
    """自定义消息框，用于编辑选项"""

    def __init__(self, items: list[str], parent=None):
        super().__init__(parent)
        self.titleLabel = SubtitleLabel('编辑选项', self)
        self.viewLayout.addWidget(self.titleLabel)

        # 创建垂直布局用于存放所有选项行
        self.rows_layout = QVBoxLayout()
        self.rows_layout.setSpacing(0)  # 设置控件之间的固定间距为0像素
        self.rows_layout.setContentsMargins(0, 0, 0, 0)  # 设置布局的边距为0
        self.viewLayout.addLayout(self.rows_layout)

        # 初始化添加现有选项
        for item in items:
            self._add_row(item)

        # 添加“新增”按钮
        self.add_button = PushButton('添加', self)
        self.add_button.clicked.connect(self._add_new_row)
        self.viewLayout.addWidget(self.add_button)

        # 设置对话框最小宽度
        self.widget.setMinimumWidth(450)

    def _add_row(self, text=''):
        """添加单行（输入框+删除按钮）"""
        row_widget = QWidget()
        h_layout = QHBoxLayout(row_widget)

        # 输入框
        line_edit = LineEdit(row_widget)
        line_edit.setText(text)

        # 删除按钮
        delete_btn = ToolButton(FluentIcon.DELETE, row_widget)
        delete_btn.clicked.connect(lambda: self._delete_row(row_widget))

        # 将控件加入布局
        h_layout.addWidget(line_edit, 1)  # 输入框扩展填充
        h_layout.addWidget(delete_btn)

        self.rows_layout.addWidget(row_widget)

    def _delete_row(self, row_widget):
        """删除指定行"""
        self.rows_layout.removeWidget(row_widget)
        row_widget.deleteLater()

    def _add_new_row(self):
        """添加新空行"""
        self._add_row('')

    def get_items(self) -> list[str]:
        """获取所有非空选项（自动去除首尾空格）"""
        items = []
        for i in range(self.rows_layout.count()):
            row_widget = self.rows_layout.itemAt(i).widget()
            if row_widget:
                line_edit = row_widget.findChild(LineEdit)
                if line_edit:
                    text = line_edit.text().strip()
                    if text:  # 检查文本是否非空，防止用户空添加
                        items.append(text)
        return items


================================================
FILE: Widget/EmptyCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import PushButton
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class EmptyCard(CardWidget):

    def __init__(self, title: str, description: str, init = None, clicked = None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.hbox = QHBoxLayout(self)
        self.hbox.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox = QVBoxLayout()

        self.title_label = StrongBodyLabel(title, self)
        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))

        self.vbox.addWidget(self.title_label)
        self.vbox.addWidget(self.description_label)
        self.hbox.addLayout(self.vbox)

        # 填充
        self.hbox.addStretch(1)

        if init:
            init(self)

    def set_title(self, title: str) -> None:
        self.title_label.setText(title)

    def set_description(self, description: str) -> None:
        self.description_label.setText(description)

    def add_widget(self, widget) -> None:
        self.hbox.addWidget(widget)

    def add_spacing(self, space: int) -> None:
        self.hbox.addSpacing(space)


================================================
FILE: Widget/FlowCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget, HorizontalSeparator
from qfluentwidgets import FlowLayout
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class FlowCard(CardWidget):

    def __init__(self, title: str, description: str, init = None):
        super().__init__(None)
        
        # 设置容器
        self.setBorderRadius(4)
        self.container = QVBoxLayout(self)
        self.container.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 添加头部容器
        self.head_container = QFrame(self)
        self.head_hbox = QHBoxLayout(self.head_container)
        self.head_hbox.setSpacing(8)
        self.head_hbox.setContentsMargins(0, 0, 0, 0)
        self.container.addWidget(self.head_container)

        # 添加文本容器
        self.text_container = QFrame(self)
        self.text_vbox = QVBoxLayout(self.text_container)
        self.text_vbox.setSpacing(8)
        self.text_vbox.setContentsMargins(0, 0, 0, 0)
        self.head_hbox.addWidget(self.text_container)

        self.title_label = StrongBodyLabel(title, self)
        self.text_vbox.addWidget(self.title_label)

        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))
        self.text_vbox.addWidget(self.description_label)

        # 填充
        self.head_hbox.addStretch(1)

        # 添加分割线
        line = HorizontalSeparator()
        self.container.addSpacing(4)
        self.container.addWidget(line)
        self.container.addSpacing(4)

        # 添加流式布局容器
        self.flow_container = QFrame(self)
        self.flow_layout = FlowLayout(self.flow_container, needAni = False)
        self.flow_layout.setSpacing(8)
        self.flow_layout.setContentsMargins(0, 0, 0, 0)
        self.container.addWidget(self.flow_container)

        if init:
            init(self)

    def set_title(self, title: str) -> None:
        self.title_label.setText(title)

    def set_description(self, description: str) -> None:
        self.description_label.setText(description)

    # 添加控件
    def add_widget(self, widget) -> None:
        self.flow_layout.addWidget(widget)

    # 添加控件到头部
    def add_widget_to_head(self, widget) -> None:
        self.head_hbox.addWidget(widget)

    # 移除所有控件并且删除他们
    def take_all_widgets(self) -> None:
        self.flow_layout.takeAllWidgets()


================================================
FILE: Widget/FolderDropCard.py
================================================
import os
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QFileDialog, QSizePolicy
from PyQt5.QtGui import QPainter, QPen, QColor, QFont, QPainterPath
from PyQt5.QtCore import QRect, Qt, pyqtSignal
from qfluentwidgets import BodyLabel, CardWidget,  FluentIcon, PrimaryPushButton

from Base.Base import Base

class InfoBlockWidget(QWidget):
    def __init__(self, text, color=QColor("#E0E0E0"), parent=None):
        super().__init__(parent)
        self.text = text
        self.base_color = QColor(color)
        self.fold_size = 15
        self.corner_radius = 10.0
        self.alpha_level = 170
        self.setMinimumSize(95, 120)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.default_font = QFont("Microsoft YaHei", 9)
        if QFont(self.default_font).family() != "Microsoft YaHei":
             self.default_font = QFont() # Use system default
             self.default_font.setPointSize(9)


    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        rect = self.rect()
        content_width = rect.width() - self.fold_size

        # 设置颜色
        bg_color = QColor(self.base_color)
        bg_color.setAlpha(self.alpha_level)
        fold_highlight = self.base_color.lighter(120)
        fold_highlight.setAlpha(min(255, self.alpha_level + 15))
        border_color = self.base_color.darker(130)
        border_color.setAlpha(self.alpha_level)

        # 绘制主路径
        path = QPainterPath()
        path.moveTo(self.corner_radius, 0)
        path.lineTo(content_width, 0)
        path.lineTo(content_width, self.fold_size)
        path.lineTo(rect.width(), self.fold_size)
        path.lineTo(rect.width(), rect.height() - self.corner_radius)
        path.arcTo(rect.width() - 2*self.corner_radius, rect.height() - 2*self.corner_radius, 
                  2*self.corner_radius, 2*self.corner_radius, 0, -90)
        path.lineTo(self.corner_radius, rect.height())
        path.arcTo(0, rect.height() - 2*self.corner_radius, 
                  2*self.corner_radius, 2*self.corner_radius, 270, -90)
        path.lineTo(0, self.corner_radius)
        path.arcTo(0, 0, 2*self.corner_radius, 2*self.corner_radius, 180, -90)
        path.closeSubpath()
        painter.fillPath(path, bg_color)

        # 绘制折角
        fold_path = QPainterPath()
        fold_path.moveTo(content_width, 0)
        fold_path.lineTo(rect.width(), self.fold_size)
        fold_path.lineTo(content_width, self.fold_size)
        fold_path.closeSubpath()
        painter.fillPath(fold_path, fold_highlight)

        # 绘制边框
        painter.setPen(QPen(border_color, 1))
        painter.drawPath(path)
        painter.drawLine(content_width, self.fold_size, rect.width(), self.fold_size)
        painter.drawLine(content_width, 0, content_width, self.fold_size)

        # 绘制文本
        h_padding = 5 + int(self.corner_radius / 2)
        v_padding = 5 + int(self.corner_radius / 2)
        content_rect = QRect(0, 0, content_width, rect.height())
        draw_rect = content_rect.adjusted(h_padding, v_padding, 0, -v_padding)
        painter.setPen(Qt.black)
        painter.setFont(self.default_font)
        painter.drawText(draw_rect, Qt.AlignCenter | Qt.TextWordWrap, self.text)

class DragDropArea(Base,QWidget):
    pathDropped = pyqtSignal(str) # 文件路径改变信号

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.current_path = ""
        self.is_dragging = False
        self.border_color = QColor("#AAAAAA")
        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)

        # 信息块区域
        flow_container = QWidget()
        info_layout = QHBoxLayout(flow_container)
        #info_layout.setHorizontalSpacing(15)
        #info_layout.setVerticalSpacing(15)

        info_1 = self.tra("书籍")
        info_2 = self.tra("文档")
        info_3 = self.tra("字幕")
        info_5 = self.tra("游戏")
        info_6 = self.tra("数据文件")
        info_7 = self.tra("复杂文档")
        info_8 = self.tra("工程文件")

        # 简化信息块创建
        block_info = [
            (f"{info_1}\n Epub\n TXT", "#AED6F1"),
            (f"{info_2}\n Docx\n MD", "#A9DFBF"),
            (f"{info_3}\n Srt\n Ass\n Vtt\n Lrc", "#FAD7A0"),
            (f"{info_5}\n Renpy\n VNText \n RPGmaker", "#AFEEEE"),
            (f"{info_6}\n Po \n I18Next \n ParaTranz", "#F08080"),
            (f"{info_7}\n PDF\n DOC", "#E6E6FA"),
            (f"{info_8}\n .trans", "#FFFACD"),
        ]

        # 添加弹簧
        info_layout.addStretch(1)
        # 创建信息块
        self.info_blocks = [InfoBlockWidget(text, color) for text, color in block_info]
        for block in self.info_blocks:
            info_layout.addWidget(block)
        # 添加弹簧
        info_layout.addStretch(1)

        # 底部按钮区域
        bottom_layout = QHBoxLayout()
        self.satr_button = PrimaryPushButton(FluentIcon.PLAY, self.tra("直接读取"), self)
        self.satr_button.clicked.connect(self._get_folder)
        self.selectButton = PrimaryPushButton(FluentIcon.FOLDER_ADD, self.tra("拖拽/选择输入文件夹"), self)
        self.selectButton.clicked.connect(self._select_folder)
        bottom_layout.addStretch(1)
        bottom_layout.addWidget(self.satr_button)
        bottom_layout.addWidget(self.selectButton)
        bottom_layout.addStretch(1)

        # 路径显示区域
        path_layout = QHBoxLayout()
        self.pathLabel = BodyLabel("NO PATH", self)
        self.pathLabel.setAlignment(Qt.AlignCenter)
        path_layout.addStretch(1)
        path_layout.addWidget(self.pathLabel)
        path_layout.addStretch(1)

        # 组装布局
        layout.addWidget(flow_container)
        layout.addStretch(1)
        layout.addLayout(path_layout)
        layout.addLayout(bottom_layout)

    def _get_folder(self):
        folder_path = self.current_path
        if folder_path:
            self.update_path(folder_path)

    def _select_folder(self):
        folder_path = QFileDialog.getExistingDirectory(self, self.tra("选择文件夹"))
        if folder_path:
            self.update_path(folder_path)

    def update_path(self, path: str, emit_signal: bool = True): 
        self.current_path = path
        display_path = path if len(path) < 50 else f"...{path[-47:]}"
        info = self.tra("当前路径")
        self.pathLabel.setText(f"{info}: {display_path}")
        self.pathLabel.setToolTip(path)
        if emit_signal: # 只有在需要时才发射信号
            self.pathDropped.emit(path)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        rect = self.rect().adjusted(1, 1, -1, -1)
        
        pen = QPen(self.border_color, 2)
        if self.is_dragging:
            pen.setStyle(Qt.SolidLine)
            pen.setColor(QColor("#aaaaff"))
        else:
            pen.setStyle(Qt.DashLine)
        
        painter.setPen(pen)
        painter.setBrush(Qt.NoBrush)
        painter.drawRoundedRect(rect, 15, 15)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                if url.isLocalFile() and os.path.exists(url.toLocalFile()):
                    event.acceptProposedAction()
                    self.is_dragging = True
                    self.update()
                    return
        event.ignore()

    def dragLeaveEvent(self, event):
        self.is_dragging = False
        self.update()

    def dropEvent(self, event):
        self.is_dragging = False
        self.update()
        
        if not event.mimeData().hasUrls():
            return

        # 获取所有有效本地路径
        urls = event.mimeData().urls()
        paths = [url.toLocalFile() for url in urls if url.isLocalFile() and os.path.exists(url.toLocalFile())]

        if not paths:
            return

        # 根据路径数量进行判断
        if len(paths) == 1:
            # 拖入的是单个文件或文件夹
            single_path = paths[0]

            # 如果是文件夹，则直接使用文件路径
            if os.path.isdir(single_path):
                path_to_use = single_path

            # 如果是文件，获取其所在的父目录
            else:
                path_to_use = single_path # 给单文件夹拖拽功能支持用
                #path_to_use =  os.path.dirname(single_path)

            # 更新路径并发射信号
            self.update_path(path_to_use)
        else:
            # 拖入的是多个文件/文件夹,获取它们共同的父目录
            first_path = paths[0]
            if os.path.isdir(first_path):
                 # 如果用户拖动多个项，其中第一个是文件夹，
                 parent_dir = os.path.dirname(first_path)
            else: # 是文件
                 parent_dir = os.path.dirname(first_path)
            
            self.update_path(parent_dir)

class FolderDropCard(Base,CardWidget):
    pathChanged = pyqtSignal(str)

    def __init__(self, init=None, path_changed=None, parent=None):
        super().__init__(parent)
        self.setMinimumHeight(350)
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 16, 16, 16)
        
        self.dragDropArea = DragDropArea(self)
        self.dragDropArea.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.dragDropArea)
        
        # 连接信号
        self.dragDropArea.pathDropped.connect(self.pathChanged)
        if path_changed:
            self.pathChanged.connect(path_changed)
        
        # 初始化时设置路径
        if init:
            self.setPath(init)

    def setPath(self, path: str):
        # 初始化设置路径时，不发射信号
        self.dragDropArea.update_path(path, emit_signal=False)

    def getPath(self) -> str:
        return self.dragDropArea.current_path


================================================
FILE: Widget/GameDropCard.py
================================================
[Binary file]


================================================
FILE: Widget/GroupCard.py
================================================
[Binary file]


================================================
FILE: Widget/InterfaceDropZoneWidget.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QFrame, QHBoxLayout, QVBoxLayout, QWidget
from qfluentwidgets import CaptionLabel


class InterfaceDropZoneWidget(QFrame):
    """
    一个专用于接口设置的自定义组件。
    包含一个居中对齐的描述标签和一排水平排列的拖放区域。
    """
    def __init__(self, description: str, parent=None):
        super().__init__(parent)
        self.setObjectName("interface-drop-zone-widget")

        # 主垂直布局
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(17, 8, 17, 8) # 上下留出一些边距
        self.main_layout.setSpacing(15)

        # 居中的描述文本
        self.description_label = CaptionLabel(description)
        self.description_label.setAlignment(Qt.AlignCenter)
        self.main_layout.addWidget(self.description_label)

        # 水平排列拖拽区域的容器
        self.drop_areas_container = QFrame(self)
        self.drop_areas_hbox = QHBoxLayout(self.drop_areas_container)
        self.drop_areas_hbox.setContentsMargins(0, 0, 0, 0)
        self.drop_areas_hbox.setSpacing(15) # 设置拖拽区域之间的间距
        self.main_layout.addWidget(self.drop_areas_container)

    def add_drop_area(self, widget: QWidget):
        """向水平布局中添加一个拖拽区域"""
        self.drop_areas_hbox.addWidget(widget)


================================================
FILE: Widget/LineEditCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import LineEdit
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class LineEditCard(CardWidget):

    def __init__(self, title: str, description: str, init = None, text_changed = None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.hbox = QHBoxLayout(self)
        self.hbox.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox_container = QFrame(self)
        self.vbox = QVBoxLayout(self.vbox_container)
        self.vbox.setSpacing(0)
        self.vbox.setContentsMargins(0, 0, 0, 0)
        self.hbox.addWidget(self.vbox_container)

        self.title_label = StrongBodyLabel(title, self)
        self.vbox.addWidget(self.title_label)

        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))
        self.vbox.addWidget(self.description_label)

        # 填充
        self.hbox.addStretch(1)

        # 添加控件
        self.line_edit = LineEdit()
        self.line_edit.setFixedWidth(192)
        self.line_edit.setClearButtonEnabled(True)
        self.hbox.addWidget(self.line_edit)

        if init:
            init(self)

        if text_changed:
            self.line_edit.textChanged.connect(lambda text: text_changed(self, text))

    # 添加控件
    def add_widget(self, widget) -> None:
        self.hbox.addWidget(widget)

    # 添加间隔
    def add_spacing(self, spacing: int) -> None:
        self.hbox.addSpacing(spacing)

    # 获取文本
    def get_text(self) -> str:
        return self.line_edit.text()

    # 设置文本
    def set_text(self, text: str) -> None:
        self.line_edit.setText(text)

    # 设置输入框宽度
    def set_fixed_width(self, width: int) -> None:
        self.line_edit.setFixedWidth(width)

    # 设置占位符
    def set_placeholder_text(self, text: str) -> None:
        self.line_edit.setPlaceholderText(text)


================================================
FILE: Widget/LineEditMessageBox.py
================================================
from qfluentwidgets import LineEdit
from qfluentwidgets import MessageBoxBase
from qfluentwidgets import StrongBodyLabel

class LineEditMessageBox(MessageBoxBase):

    def __init__(self, window, title:str, message_box_close:callable = None, default_text:str = ""):
        super().__init__(parent = window)

        # 初始化
        self.message_box_close = message_box_close

        # 设置框体
        self.yesButton.setText("确定")
        self.cancelButton.setText("取消")

        # 设置主布局
        self.viewLayout.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 标题
        self.title_label = StrongBodyLabel(title, self)
        self.viewLayout.addWidget(self.title_label)

        # 输入框
        self.line_edit = LineEdit(self)
        self.line_edit.setFixedWidth(256)
        self.line_edit.setClearButtonEnabled(True)
        self.line_edit.setText(default_text)
        self.viewLayout.addWidget(self.line_edit)

    # 重写验证方法
    def validate(self):
        if self.line_edit.text().strip() != "":
            if self.message_box_close:
                self.message_box_close(self, self.line_edit.text())

            return True

    # 设置提示文本
    def set_placeholder_text(self, text: str) -> None:
        self.line_edit.setPlaceholderText(text)


================================================
FILE: Widget/PlainTextEditCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget, PlainTextEdit
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class PlainTextEditCard(CardWidget):

    def __init__(self, title: str, description: str, init=None, text_changed=None, min_height=None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.hbox = QHBoxLayout(self)
        self.hbox.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox_container = QFrame(self)
        self.vbox = QVBoxLayout(self.vbox_container)
        self.vbox.setSpacing(0)
        self.vbox.setContentsMargins(0, 0, 0, 0)
        self.hbox.addWidget(self.vbox_container)

        self.title_label = StrongBodyLabel(title, self)
        self.vbox.addWidget(self.title_label)

        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))
        self.vbox.addWidget(self.description_label)

        # 填充
        self.hbox.addStretch(1)

        # 添加控件
        self.PlainText = PlainTextEdit()
        self.PlainText.setFixedWidth(500)
        # 新增：设置最小高度
        if min_height is not None:
            self.PlainText.setMinimumHeight(min_height)
        self.hbox.addWidget(self.PlainText)

        if init:
            init(self)

        if text_changed:
            self.PlainText.textChanged.connect(lambda: text_changed(self, self.PlainText.toPlainText()))

    # 添加控件
    def add_widget(self, widget) -> None:
        self.hbox.addWidget(widget)

    # 添加间隔
    def add_spacing(self, spacing: int) -> None:
        self.hbox.addSpacing(spacing)

    # 获取文本
    def get_text(self) -> str:
        return self.PlainText.toPlainText().strip()  

    # 设置文本
    def set_text(self, text: str) -> None:
        self.PlainText.setPlainText(text)

    # 设置输入框宽度
    def set_fixed_width(self, width: int) -> None:
        self.PlainText.setFixedWidth(width)

    # 设置占位符
    def set_placeholder_text(self, text: str) -> None:
        self.PlainText.setPlaceholderText(text)


================================================
FILE: Widget/ProgressRingCard.py
================================================
[Binary file]


================================================
FILE: Widget/PushButtonCard.py
================================================
from PyQt5.QtCore import QFileInfo
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import PushButton
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class PushButtonCard(CardWidget):

    def __init__(self, title: str, description: str, init = None, clicked = None, drop_callback = None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.container = QHBoxLayout(self)
        self.container.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox = QVBoxLayout()

        self.title_label = StrongBodyLabel(title, self)
        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))

        self.vbox.addWidget(self.title_label)
        self.vbox.addWidget(self.description_label)
        self.container.addLayout(self.vbox)

        # 填充
        self.container.addStretch(1)

        # 添加控件
        self.push_button = PushButton("", self)
        self.container.addWidget(self.push_button)

        if init:
            init(self)

        if clicked:
            self.push_button.clicked.connect(lambda value: clicked(self))

        if drop_callback:
            self.setAcceptDrops(True)
            self.drop_callback = drop_callback

    def set_title(self, title: str) -> None:
        self.title_label.setText(title)

    def set_description(self, description: str) -> None:
        self.description_label.setText(description)

    def set_text(self, text: str) -> None:
        self.push_button.setText(text)

    def set_icon(self, icon: str) -> None:
        self.push_button.setIcon(icon)

    def take_drag_event_dir_path(self, event) -> str:
        if event.mimeData().hasText():
            if event.mimeData().hasUrls():
                urls = event.mimeData().urls()
                for url in urls:
                    local_path = url.toLocalFile()
                    if(QFileInfo(local_path).isDir()):
                        return local_path
        return None

    def dragEnterEvent(self, event):
        if self.take_drag_event_dir_path(event):
            event.acceptProposedAction()
        else:
            event.ignore()
            
    def dragMoveEvent(self, event):
        if self.take_drag_event_dir_path(event):
            event.acceptProposedAction()
        else:
            event.ignore()
            
    def dropEvent(self, event):
        dir_path = self.take_drag_event_dir_path(event)
        if dir_path:
            self.drop_callback(self, dir_path)
            event.acceptProposedAction()
        else:
            event.ignore()


================================================
FILE: Widget/SliderCard.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import Slider
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class SliderCard(CardWidget):

    def __init__(self, title: str, description: str, init = None, value_changed = None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.container = QHBoxLayout(self)
        self.container.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox = QVBoxLayout()

        self.title_label = StrongBodyLabel(title, self)
        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))

        self.vbox.addWidget(self.title_label)
        self.vbox.addWidget(self.description_label)
        self.container.addLayout(self.vbox)

        # 填充
        self.container.addStretch(1)

        # 添加控件
        self.slider = Slider(Qt.Horizontal)
        self.slider.setFixedWidth(256)
        self.slider_value_label = StrongBodyLabel(title, self)
        self.slider_value_label.setFixedWidth(48)
        self.slider_value_label.setAlignment(Qt.AlignCenter)
        self.container.addWidget(self.slider)
        self.container.addWidget(self.slider_value_label)

        if init:
            init(self)

        if value_changed:
            self.slider.valueChanged.connect(lambda value: value_changed(self, value))

    def set_text(self, text:str) -> None:
        self.slider_value_label.setText(text)

    def set_value(self, value: int) -> None:
        self.slider.setValue(value)

    def set_range(self, min: int, max: int) -> None:
        self.slider.setRange(min, max)


================================================
FILE: Widget/SpinCard.py
================================================
[Binary file]


================================================
FILE: Widget/SwitchButtonCard.py
================================================
from PyQt5.QtGui import QColor
from PyQt5.QtWidgets import QHBoxLayout
from PyQt5.QtWidgets import QVBoxLayout

from qfluentwidgets import CardWidget
from qfluentwidgets import SwitchButton
from qfluentwidgets import CaptionLabel
from qfluentwidgets import StrongBodyLabel

class SwitchButtonCard(CardWidget):

    def __init__(self, title: str, description: str, init = None, checked_changed = None):
        super().__init__(None)

        # 设置容器
        self.setBorderRadius(4)
        self.container = QHBoxLayout(self)
        self.container.setContentsMargins(16, 16, 16, 16) # 左、上、右、下

        # 文本控件
        self.vbox = QVBoxLayout()

        self.title_label = StrongBodyLabel(title, self)
        self.description_label = CaptionLabel(description, self)
        self.description_label.setTextColor(QColor(96, 96, 96), QColor(160, 160, 160))

        self.vbox.addWidget(self.title_label)
        self.vbox.addWidget(self.description_label)
        self.container.addLayout(self.vbox)

        # 填充
        self.container.addStretch(1)

        # 添加控件
        self.switch_button = SwitchButton()
        self.switch_button.setOnText("")
        self.switch_button.setOffText("")
        self.container.addWidget(self.switch_button)

        if init:
            init(self)

        if checked_changed:
            self.switch_button.checkedChanged.connect(lambda checked: checked_changed(self, checked))

    # 设置选中状态
    def set_checked(self, checked: bool):
        self.switch_button.setChecked(checked)


================================================
FILE: Widget/VerticalSeparator.py
================================================
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QVBoxLayout


class VerticalSeparator(QWidget):

    def __init__(self):
        super().__init__(None)
        
        # 使用 QVBoxLayout + QWidget + addStretch 来创建短垂直线
        separatorLayout = QVBoxLayout()
        separatorLayout.setContentsMargins(0, 0, 0, 0) # 内部边距为0
        separatorLayout.setSpacing(0) # 内部间距为0

        separatorLayout.addStretch(1) # 在线上方添加伸缩

        # 创建实际的线
        line = QWidget(self)
        line.setFixedWidth(1)  # 宽度为1像素，使其成为垂直线
        line.setFixedHeight(35) # 设置线的固定高度，使其变短 
        line.setStyleSheet("QWidget { background-color: #C0C0C0; }")

        separatorLayout.addWidget(line, 0, Qt.AlignCenter) # 将线添加到布局中，水平居中

        separatorLayout.addStretch(1) # 在线下方添加伸缩


================================================
FILE: Widget/WaveformCard.py
================================================
import time
from collections import deque 

from PyQt5.QtCore import Qt, QTimer, QPointF
from PyQt5.QtGui import QPainter, QColor, QPen, QBrush, QLinearGradient, QPainterPath, QPolygonF
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout, QWidget
from qfluentwidgets import BodyLabel, CardWidget, FluentIcon, IconWidget, themeColor, isDarkTheme

class WaveformWidget(QWidget): 

    def __init__(self, parent=None):
        super().__init__(parent)

        self.DEFAULT_COLOR = QColor(0, 120, 215)
        #self.DEFAULT_COLOR = themeColor() # 如果要跟随主题色
        self.BACKGROUND_COLOR_DARK = QColor(32, 32, 32)
        self.BACKGROUND_COLOR_LIGHT = QColor(245, 245, 245)
        self.GRID_COLOR_DARK = QColor(60, 60, 60)
        self.GRID_COLOR_LIGHT = QColor(220, 220, 220)


        self.num_points = 100       # 显示的数据点数（宽度）
        self.history = deque([0.0] * self.num_points, maxlen=self.num_points) # 使用双端队列

        self.refresh_rate = 10      # 刷新频率（Hz）
        self.last_add_value_time = 0

        # --- 外观配置 ---
        self.line_color = self.DEFAULT_COLOR  # 波形线颜色
        self.line_thickness = 2          # 线宽
        self.fill_enabled = True        # 是否填充区域
        self.gradient_enabled = True    # 是否启用渐变填充
        self.draw_grid = True          # 是否绘制背景网格
        self.grid_rows = 4             # 网格行数
        self.grid_cols = 10            # 网格列数

        # 设置最小尺寸以便布局
        self.setMinimumSize(600, 145)

        # 更新定时器
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.tick)
        self.timer.start(int(1000 / self.refresh_rate))

        # 启用样式表背景样式
        self.setAttribute(Qt.WA_StyledBackground, True)
        # self.setStyleSheet("background-color: transparent;") # 或设置特定颜色

    def tick(self):
        """定时器触发的波形更新"""
        # 如果刷新间隔内没有新数据，重复最后值
        if time.time() - self.last_add_value_time >= (1.0 / self.refresh_rate):
            self.repeat()
        # 即使数据未变化也确保重绘（例如主题变更）
        self.update()


    def paintEvent(self, event):
        """处理控件绘制"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing) # 启用抗锯齿

        width = self.width()
        height = self.height()

        # 1. 绘制背景（可选：或使用样式表）
        bg_color = self.BACKGROUND_COLOR_DARK if isDarkTheme() else self.BACKGROUND_COLOR_LIGHT
        painter.fillRect(self.rect(), bg_color)

        # 2. 绘制网格（可选）
        if self.draw_grid and width > 0 and height > 0:
            grid_color = self.GRID_COLOR_DARK if isDarkTheme() else self.GRID_COLOR_LIGHT
            pen = QPen(grid_color, 0.5, Qt.DotLine) # 细虚线
            painter.setPen(pen)
            # 垂直线
            for i in range(1, self.grid_cols):
                x = width * i / self.grid_cols
                painter.drawLine(QPointF(x, 0), QPointF(x, height))
            # 水平线
            for i in range(1, self.grid_rows):
                y = height * i / self.grid_rows
                painter.drawLine(QPointF(0, y), QPointF(width, y))


        if not self.history or width <= 0 or height <= 1: # 至少需要2像素高度
            return # 无数据或无效尺寸

        # 3. 数据准备和归一化
        # 使用副本避免绘制时数据修改
        history_copy = list(self.history)
        min_val = min(history_copy)
        max_val = max(history_copy)

        # 避免除零和平线情况处理
        data_range = max_val - min_val
        if data_range < 1e-6: # 接近零视为零范围
            # 全零时在底部画平线，非零常数在中线
            norm_factor = 0.0 if abs(max_val) < 1e-6 else 0.5
            normalized_values = [norm_factor] * len(history_copy)
        else:
            # 将值归一化到0.0（底部）到1.0（顶部）
            normalized_values = [(v - min_val) / data_range for v in history_copy]

        # 4. 创建波形多边形/路径
        path = QPainterPath()
        poly = QPolygonF()

        # 计算点间水平步长
        x_step = width / max(1, self.num_points - 1) # 避免除以零

        for i, norm_val in enumerate(normalized_values):
            x = i * x_step
            # 将归一化值映射到控件高度（反转y轴）
            y = height * (1.0 - norm_val)
            # 确保y在绘制范围内
            y = max(0.0, min(height -1.0, y)) # 保持有效区域

            if i == 0:
                path.moveTo(x, y)
            else:
                path.lineTo(x, y)
            poly.append(QPointF(x, y))


        # 5. 绘制填充区域
        if self.fill_enabled and len(poly) > 1:
            fill_path = QPainterPath(path) # 使用线路径作为起点
            # 添加点闭合底部边缘路径
            fill_path.lineTo(poly.last().x(), height) # 右下
            fill_path.lineTo(poly.first().x(), height) # 左下
            fill_path.closeSubpath() # 闭合路径（可选但建议）

            if self.gradient_enabled:
                gradient = QLinearGradient(0, 0, 0, height)
                fill_color_start = QColor(self.line_color)
                fill_color_start.setAlphaF(0.4) # 顶部更透明
                fill_color_end = QColor(self.line_color)
                fill_color_end.setAlphaF(0.1) # 底部更透明
                gradient.setColorAt(0.0, fill_color_start)
                gradient.setColorAt(1.0, fill_color_end)
                brush = QBrush(gradient)
            else:
                fill_color = QColor(self.line_color)
                fill_color.setAlphaF(0.3) # 半透明纯色填充
                brush = QBrush(fill_color)

            painter.setPen(Qt.NoPen) # 填充无边框
            painter.fillPath(fill_path, brush)


        # 6. 绘制波形线
        pen = QPen(self.line_color, self.line_thickness)
        pen.setJoinStyle(Qt.RoundJoin) # 平滑连接
        pen.setCapStyle(Qt.RoundCap)   # 圆角端点
        painter.setPen(pen)
        painter.setBrush(Qt.NoBrush) # 不填充线条
        painter.drawPath(path) # 在填充上方绘制线条


    def repeat(self):
        """在历史数据中重复最后值"""
        last_value = self.history[-1] if self.history else 0.0
        self.history.append(last_value)
        self.update() # 请求重绘

    def sizeHint(self):
        return self.minimumSize()
    

class WaveformCard(CardWidget):
    def __init__(self,
                 title: str,
                 icon: FluentIcon = None, 
                 parent: QWidget = None, 
                 clicked = None
                 ):
        super().__init__(parent)

        # --- 基本卡片设置 ---
        self.setBorderRadius(8) # 稍大的半径以获得更柔和的外观
        # self.setFixedSize(180, 130) # 考虑设置固定或最小尺寸以确保一致性

        # --- 主布局 ---
        self.mainLayout = QVBoxLayout(self)
        self.mainLayout.setContentsMargins(16, 12, 16, 12) # 调整边距
        self.mainLayout.setSpacing(8) # 各部分之间保持一致的间距

        # --- 顶部区域：图标（可选）和标题 ---
        self.topLayout = QHBoxLayout()
        self.topLayout.setContentsMargins(0, 0, 0, 0)
        self.topLayout.setSpacing(8) # 图标和标题之间的间距

        # 设置图标
        if icon:
            self.iconWidget = IconWidget(icon, self)
            self.iconWidget.setFixedSize(18, 18) # 根据需要调整图标大小
            self.topLayout.addWidget(self.iconWidget)
        else:
            self.iconWidget = None # 如果存在图标则进行跟踪

        self.titleLabel = BodyLabel(title, self) 
        self.titleLabel.setTextColor("#606060")
        self.topLayout.addWidget(self.titleLabel, 1) 
        self.mainLayout.addLayout(self.topLayout)
        self.mainLayout.addSpacing(4) # 在数值前的少量间距

        # --- 底部区域 ---
        self.waveform = WaveformWidget(self) 
        self.set_num_points(100) 


        self.valueLayout = QHBoxLayout()
        self.valueLayout.setContentsMargins(0, 0, 0, 0)
        self.valueLayout.setSpacing(4) 
        self.valueLayout.setAlignment(Qt.AlignCenter) # 水平居中数值和单位
        self.valueLayout.addStretch(1) # 在之前添加伸缩项
        self.valueLayout.addWidget(self.waveform)


        # 添加进主布局
        self.mainLayout.addLayout(self.valueLayout, 1) 


        # 连接信号
        if clicked:
            self.clicked.connect(clicked) # 连接卡片的点击信号


    def add_value(self, value: float): # 接收浮点值便于平滑输入
        """添加新数据到波形历史"""
        self.waveform.history.append(float(value))
        self.waveform.last_add_value_time = time.time()
        self.update() # 请求重绘

    def set_num_points(self, points: int):
        """设置水平方向显示的数据点数"""
        if points > 0:
            self.waveform.num_points = points
            # 重新初始化历史数据（尽可能保留旧数据）
            old_data = list(self.waveform.history)
            self.waveform.history = deque([0.0] * self.waveform.num_points, maxlen=self.waveform.num_points)
            # 如果调整后尺寸更小则从末尾填充旧数据，更大则补零
            start_index = max(0, len(old_data) - self.waveform.num_points)
            for i, val in enumerate(old_data[start_index:]):
                # 调整双端队列索引从右侧填充
                deque_index = self.waveform.num_points - (len(old_data) - start_index) + i
                if deque_index < self.waveform.num_points:
                    self.waveform.history[deque_index] = val

            self.waveform.update() # 触发重绘

    def set_line_color(self, color: QColor):
        """设置波形线/填充颜色"""
        self.waveform.line_color = color
        self.waveform.update()

    def set_fill_enabled(self, enabled: bool):
        """设置是否填充曲线下区域"""
        self.waveform.fill_enabled = enabled
        self.waveform.update()

    def set_gradient_enabled(self, enabled: bool):
        """设置填充是否使用渐变"""
        self.waveform.gradient_enabled = enabled
        self.waveform.update()

    def set_draw_grid(self, enabled: bool):
        """设置是否绘制背景网格"""
        self.waveform.draw_grid = enabled
        self.waveform.update()


================================================
FILE: .github/ISSUE_TEMPLATE/bug_issue.yml
================================================
[Binary file]


================================================
FILE: .github/ISSUE_TEMPLATE/opinion.yml
================================================
name: "意见建议 | Feature Request"
description: "如果你有对项目的需求、功能建议、或其他意见，请使用此模板。"
title: "[Opinion]: "
labels: ["enhancement", "discussion"]
assignees: []

body:
  - type: markdown
    attributes:
      value: |
        **⚠ 注意：此处不用于反馈代码报错或编译问题，如果是bug问题反馈，请使用 [问题反馈模板](?template=bug_issue.yml)。**  
        感谢你的宝贵意见或建议，我们会酌情采纳！

  - type: textarea
    id: suggestion
    attributes:
      label: "意见/建议内容"
      description: "请简要描述你的想法或建议。"
      placeholder: "例如：希望新增xx功能，或者修改xx逻辑。"
    validations:
      required: true

  - type: textarea
    id: reason
    attributes:
      label: "为什么需要这个功能或修改？"
      description: "简单说明你提出此意见/建议的原因或背景需求。"
      placeholder: "例如：在实际项目中遇到xx需求场景；希望提升xx效率；等等。"
    validations:
      required: true

  - type: input
    id: relevance
    attributes:
      label: "相关链接或参考"
      description: "如果你有看到类似实现或参考资料，可在此提供链接。"
      placeholder: "例如：相关文档链接、RFC、规范文档等"
    validations:
      required: false

  - type: textarea
    id: additional
    attributes:
      label: "补充信息"
      description: "如果有更多信息，可在此补充。"
      placeholder: "任何与意见或建议相关的额外说明..."
    validations:
      required: false



================================================
FILE: .github/workflows/main.yml
================================================
# .github/workflows/your-workflow-name.yml

name: AiNiee Beta Build.
on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install UPX
        shell: cmd
        run: |
          choco install upx -y

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: 3.12

      - name: Install Requirements
        run: |
          python -m pip install --upgrade pip
          python -m pip install --upgrade setuptools
          python -m pip install -r requirements.txt
          python -m pip install --no-deps -r requirements_no_deps.txt
          python -m pip cache purge

      - name: Build EXE with PyInstaller (--onedir mode)
        # 将原 Build EXE 步骤重命名，更清晰
        run: python .\Tools\pyinstall.py

      - name: Prepare Release Package
        # 将原 Pack Resource 步骤重命名并修改
        run: |
          # 将资源文件夹复制到 PyInstaller 生成的输出目录内部
          Copy-Item -Path "Resource" -Destination "dist\AiNiee\Resource" -Recurse -Force
          Copy-Item -Path "StevExtraction" -Destination "dist\AiNiee\StevExtraction" -Recurse -Force
          Copy-Item -Path "PluginScripts" -Destination "dist\AiNiee\PluginScripts" -Recurse -Force
          
          # 压缩目录,包括dist文件夹，主要是因为updater.exe还没更新，以免自动更新功能出错
          Compress-Archive -Path "dist" -DestinationPath "AiNiee-Beta.zip"

      - name: Delete release
        uses: dev-drprasad/delete-tag-and-release@v1.1 
        with:
          tag_name: Beta
          delete_release: true
          github_token: ${{ secrets.AINIEE }}
        continue-on-error: true

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: Beta
          name: AiNiee-Beta 开发测试版本，由最新源码自动打包 
          draft: false
          prerelease: true
          generate_release_notes: true 
          files: AiNiee-Beta.zip
          token: ${{ secrets.AINIEE }}

